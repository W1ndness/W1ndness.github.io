{"meta":{"title":"W1ndness的技术栈","subtitle":"Based on Hexo-NexT","description":"","author":"LeoLang","url":"https://www.leolang.top","root":"/"},"pages":[{"title":"About","date":"2021-08-09T04:09:27.000Z","updated":"2021-08-09T05:30:52.000Z","comments":true,"path":"about/index.html","permalink":"https://www.leolang.top/about/index.html","excerpt":"","text":""},{"title":"All categories","date":"2021-08-09T04:09:02.000Z","updated":"2021-08-09T04:13:36.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.leolang.top/categories/index.html","excerpt":"","text":""},{"title":"Schedule","date":"2021-08-09T04:09:42.000Z","updated":"2021-08-09T08:16:10.000Z","comments":true,"path":"schedule/index.html","permalink":"https://www.leolang.top/schedule/index.html","excerpt":"","text":""},{"title":"Home","date":"2021-08-09T04:09:17.000Z","updated":"2021-08-09T05:31:10.000Z","comments":true,"path":"home/index.html","permalink":"https://www.leolang.top/home/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-08-09T04:08:20.000Z","updated":"2021-08-09T05:31:42.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.leolang.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"acwing.com/problem/content/854","date":"2022-06-15T02:02:53.790Z","updated":"2022-06-15T02:02:53.790Z","comments":true,"path":"2022/06/15/acwing.com/problem/content/854/","link":"","permalink":"https://www.leolang.top/2022/06/15/acwing.com/problem/content/854/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Users/langshufeng/Library/Application","date":"2022-06-15T02:02:30.121Z","updated":"2022-06-15T02:02:30.121Z","comments":true,"path":"2022/06/15/Users/langshufeng/Library/Application/","link":"","permalink":"https://www.leolang.top/2022/06/15/Users/langshufeng/Library/Application/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"杂谈回 0x01","slug":"杂谈回-0x01","date":"2022-04-24T16:00:00.000Z","updated":"2022-04-27T13:26:51.383Z","comments":true,"path":"2022/04/25/杂谈回-0x01/","link":"","permalink":"https://www.leolang.top/2022/04/25/%E6%9D%82%E8%B0%88%E5%9B%9E-0x01/","excerpt":"杂谈回 0x01 HTML 与 bs4 的爱恨情仇","text":"杂谈回 0x01 HTML 与 bs4 的爱恨情仇 1.0 写在前面 创立这个 “杂谈回” 专栏的主要目的是为了记录一些编码过程中遇到的问题。（其实就是不想再踩坑了。。） 以后可能会写形形色色的奇怪问题，这些奇奇怪怪的问题可能属于各个领域，用各种不同语言实现…… 这个专栏可能不会像以前的学习博文一样，这里篇幅可能会很短，把问题说清楚说明白，再把解决的办法记录下来就好了，格式也会相对的随意一点 :)，不想在这里再强迫症了…… 那么下面就开始吧！ 1.1 关于 HTML 和如何解析 HTML HTML，超文本标记语言，英语叫 HyperText Markup Language，简称是HTML，这是一种用于创建网页的标准标记语言。我本人没系统学过前端三件套（HTML、CSS、JS），不过没吃过猪肉不等于没见过猪跑，学了 CS 这几年也每天都在这些东西里摸，尤其是开始做手头大创项目之后。 从我个人看来，HTML 其实是一种写的格式很随意的语言。它不像那些高级语言严格要求缩进，要求大小写不同，要求语法必须怎么怎么写…… 它就只是只要你遵循那些个标签去写，就能大概的实现出你想在浏览器展示给别人的东西。 既然“随意”，那么 HTML 页面之间其实不会像一众高级语言一样有一种 “范式” ，说的学术一点就是难以泛化，个性化或者特化很严重。说这个不只是为了说 HTML 之间到底差别多大，还有一层意思就是 HTML 的写法可以很随意，这就导致了我们这次杂谈回要说的问题（我踩的坑） 。 伴随着大量 Web 资源的产生，人们希望通过某种方式能够获取 Web 资源，之后能够存储到本地。或者是为了方便之后查找，或者是为了后续的分析。总之，这就引出了我们的第二个话题：如何解析 HTML ，使得我们能够获得在这一页面里的信息。 1.2 Python 爬虫：requests 和 bs4 上面我们提到了，我们想要去获得一个网页中的信息。那么这时候就需要一个东西，它能够爬取网页中我们想要的内容。那这个东西就叫做 “爬虫”。 爬虫可能有很多种实现，不过最常见的应该是 Python 去实现一个爬虫。了解过 Python 爬虫的人都知道，写爬虫逃不开这几个库：requests, bs4, selenium。其中最常用的，也是很多网上的教程教，有大量博文的两个库就是 requests 和 bs4。 requests 其实是一个模拟浏览器怎么拿到网页的一个库，这里了解过计算机网络应用层一些内容的可能会知道我在说什么，如果不知道也没关系。总之呢，这就是一个能够获取到一个网页 HTML 源码的库。 bs4，也就是大名鼎鼎的 Beautiful Soup，这是一个用来解析 HTML 的库。这里需要提到，HTML 在被浏览器解析的时候会先被构造成一个树型结构。详细的我写过一篇博客，传送门：Beautiful Soup 学习笔记（一） | W1ndness的技术栈 (leolang.top) 里面前一部分介绍的比较详细了。不得不说，这是一个很 NB 的库，它能够做到浏览器做到的事情，也就是把整一个 HTML 段解析为一个 soup 实例，其实也就是 HTML 对应的 DOM 树。它也能够做到 JavaScript 能做到的一些操作，比如节点层次关系上的游走等等。 那么结合这两个库，我们就可以很容易的拿到我们想要的东西，爬虫也大多是由这两个库先做了一个前期的数据获取工作。 1.3 不规范的 HTML 书写 现在我们进入正题。为什么这篇杂谈起了这么个标题呢？这就和不规范的 HTML 书写有关系。 在 HTML 里，有这样的一系列标签能够被解释为标题，格式是 &lt;hX&gt; ，\\(X\\in\\{1, 2, 3,4 ,5 ,6\\}\\) 。我们一般规定这种标题标签里是直接写一个字符串作为标题被解析的。这样 bs4 在解析的时候也能够正确的发现标题。可是最近发现了这样的诡异写法： &lt;h1> &lt;p> A h1 title... &lt;/p> &lt;/h1> 正常来说，这种诡异格式在被浏览器解析的时候就会出现问题，但浏览器确实是正常解析了，但 bs4 不会，这就导致了无法正确发现这一个 &lt;h1&gt; 的问题。 先看一些比较正常的错误，来自某一篇 CSDN 博客（传送门：关于p、h标签嵌套问题、嵌套规则汇总），这里没提到上述的问题，但的确他给了我解释这个问题产生原因的灵感。 对于 &lt;p&gt; 标签，正常来说是不能进行嵌套的：（写的时候编辑器已经开始不同意了） &lt;p> &lt;p>Nice to meet you&lt;/p> &lt;p>你最棒&lt;/p> &lt;/p> 最后会变成这样： 发现浏览器给我们补上了一个 ”回“ 的 &lt;/p&gt; ，然后最后出现了一个空的 &lt;p&gt;&lt;/p&gt; 。 他提到了这样的嵌套规则： 块级元素与块级元素平级、内嵌元素与内嵌元素平级 块级元素可以包含内联元素或某些块元素，但是内联元素不能包含块元素，它只能包含其他的内联元素。 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素：h1~h6、p、dt li标签可以包含标签，因为li和div标签都是装载内容的容器,地位平等，没有级别之分。 块级元素与块级元素并列、内嵌元素与内嵌元素并列： &lt;div>&lt;h2>&lt;/h2>&lt;p>&lt;/p>&lt;/div> —— 对 &lt;div>&lt;a href=”#”>&lt;/a>&lt;span>&lt;/span>&lt;/div> —— 对 &lt;div>&lt;h2>&lt;/h2>&lt;span>&lt;/span>&lt;/div> —— 错 这给我发现 bs4 解析错误提供了思路，我立马就去查了 bs4 对于这一段的解析结果，果不其然…… 它变成了这样： &lt;h1>&lt;/h1> &lt;p> A h1 title... &lt;/p> 直接就把这个标题串到了下一个标签里了。说实话，想要解决这里我想过了很多办法，最终选择了从根上整治，那就是直接把爬下来的 HTML 源码修改。 既然我只要这里是个标题就行了，那么我何不直接把内层的嵌套给剥离，之后保留标题等级，再还给 HTML，这样操作下来实际上这一段 HTML 的语义是没有变化的，仍然表示这里是一个一级标题。于是，我选择了最粗暴的方式：正则表达式。 Python 的正则库 re 有一个功能非常强大的函数，叫做 re.sub() 。这个函数是用来实现正则替换的，它的强大之处不在于替换这个功能本身，而是在于它的一个参数。先来看一下官方文档的说明：（传送门 re --- 正则表达式操作 — Python 3.10.4 文档） re.sub(pattern, repl, string, count=0, flags=0) ​ 返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。 如果样式没有找到，则不加改变地返回 string。 repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，\\n 会被转换为一个换行符，\\r 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 \\&amp; 会保持原样。 向后引用像是 \\6 会用样式中第 6 组所匹配到的子字符串来替换。 ​ 如果 repl 是一个函数，那它会对每个非重复的 pattern 的情况调用。这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串。 ​ 样式可以是一个字符串或者一个 样式对象 。 ​ 可选参数 count 是要替换的最大次数；count 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以 sub('x*', '-', 'abxd') 返回 '-a-b--d-' 。 ​ 在字符串类型的 repl 参数里，如上所述的转义和向后引用中，\\g&lt;name&gt; 会使用命名组合 name，（在 (?P&lt;name&gt;…) 语法中定义） \\g&lt;number&gt; 会使用数字组；\\g&lt;2&gt; 就是 \\2，但它避免了二义性，如 \\g&lt;2&gt;0。 \\20 就会被解释为组20，而不是组2后面跟随一个字符 '0'。向后引用 \\g&lt;0&gt; 把 pattern 作为一整个组进行引用。 正则表达式中存在着这样一种操作：命名分组。熟悉正则表达式的一定知道，我们通过一对 () 括起一个分组，我们也能命名分组、捕获分组（分组引用）。 如文档中说明的一样，参数 repl 支持传入一个函数对象，这个函数它能够对匹配到的分组进行一个小的逻辑处理（即做一个 ”替换“），之后将新的字符串返回。那么我们这里就可以通过这样的方式摘除内部的 &lt;p&gt; 标签，从而去还给 bs4 一个规范的 HTML 文本。 对于一个这样嵌套形式的文本，我们设定的匹配正则表达式如下： \"&lt;h(?P&lt;lvl>\\d)>&lt;(?P&lt;tag>[a-z]+\\S*?)>(?P&lt;content>\\S+?)&lt;/(?P=tag)>&lt;/h(?P=lvl)>\" 意图也很明确了，我们分别捕获了标题级别、非法嵌套标签、内部内容。 之后我们实现上面的替换逻辑： def replace_p(matched): content = matched.group(\"content\") level = matched.group(\"lvl\") return f\"&lt;h&#123;level&#125;>&#123;content&#125;&lt;/h&#123;level&#125;>\" 最终能够返回一个剥离了内部嵌套的正常的标题标签。 最终实现的规范化函数为： def normalize(div_tag: str): def replace_p(matched): content = matched.group(\"content\") level = matched.group(\"lvl\") return f\"&lt;h&#123;level&#125;>&#123;content&#125;&lt;/h&#123;level&#125;>\" new_str = re.sub(r\"&lt;h(?P&lt;lvl>\\d)>&lt;(?P&lt;tag>[a-z]+\\S*?)>(?P&lt;content>\\S+?)&lt;/(?P=tag)>&lt;/h(?P=lvl)>\", replace_p, div_tag) return new_str","categories":[{"name":"杂谈回","slug":"杂谈回","permalink":"https://www.leolang.top/categories/%E6%9D%82%E8%B0%88%E5%9B%9E/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Beautiful Soup","slug":"Beautiful-Soup","permalink":"https://www.leolang.top/tags/Beautiful-Soup/"},{"name":"HTML","slug":"HTML","permalink":"https://www.leolang.top/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"https://www.leolang.top/tags/DOM/"},{"name":"Front-end","slug":"Front-end","permalink":"https://www.leolang.top/tags/Front-end/"}]},{"title":"Jacobi 方法","slug":"Jacobi旋转法","date":"2022-04-08T16:00:00.000Z","updated":"2022-04-12T12:42:31.206Z","comments":true,"path":"2022/04/09/Jacobi旋转法/","link":"","permalink":"https://www.leolang.top/2022/04/09/Jacobi%E6%97%8B%E8%BD%AC%E6%B3%95/","excerpt":"前言 本文将介绍有关于《计算方法》课程中有关实对称矩阵求特征值的 Jacobi 方法的内容。","text":"前言 本文将介绍有关于《计算方法》课程中有关实对称矩阵求特征值的 Jacobi 方法的内容。 Jacobi 旋转法 注：本文符号基本沿用《Matrix Computations》中 8.5.1节 的符号，证明或推导过程如有疏漏或不严谨之处欢迎指出。 Jacobi 方法是一种用来求实对称矩阵全特征值和特征向量的方法。 做法是进行一系列正交相似变换不断通过 \\(A\\leftarrow Q^{\\mathrm T}AQ\\) 更新矩阵 \\(A\\) ，使得每一个新产生的 \\(A\\) 虽然是满的但都比前一个更加 “对角化” 。最终，非对角的元素都足够小到可以被认为是 \\(0\\) 。 在对 Jacobi 方法内在的思想进行观察后，我们提出一个并行的 Jacobi 过程。 1 Jacobi 思想 Jacobi 的方法背后的思想是逐步的减小非对角元素的值。 我们定义算子 \\(\\mathrm{off}\\) 为计算矩阵非对角元素平方和的平方根，即若有矩阵 \\(A\\) ，\\(\\mathrm{off}\\ A\\) 定义为 \\[ \\mathrm{off}\\ A=\\sqrt{\\sum_{i=1}^n \\sum_{j=1 \\atop j\\neq i}^na_{ij}^2} \\] 即矩阵非对角元素的 Frobenius 范数。 补充：Frobenius 范数 Frobenius 范数，简称 \\(F-\\) 范数，记作 \\(\\Vert \\cdot \\Vert_F\\) ，定义为矩阵所有元素平方和的平方根，即若有矩阵 \\(A=[a_{ij}]_{m\\times n}\\) ，其 \\(F-\\) 范数定义为 \\[ \\Vert A \\Vert_F=\\sqrt{tr(A^{\\mathrm T}A)}=\\sqrt{\\sum_{i=1}^m\\sum_{j=1}^na_{ij}^2} \\] 做 Jacobi 旋转的工具是一个有如下形式的矩阵： \\[ J(p, q, \\theta)=\\begin{bmatrix} 1 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; c &amp; \\cdots &amp; s &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; -s &amp; \\cdots &amp; c &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix} \\] 其中 \\(J_{pp}=J_{qq}=c:=\\cos\\theta\\) ，\\(J_{pq}=-J_{qp}=s:=\\sin\\theta\\) 。这一矩阵被叫做平面旋转变换矩阵。 Jacobi 旋转和 Givens 旋转使用的矩阵没有区别，我们这里为纪念发明者而改变名字。 Jacobi 求特征值过程的基本步骤为： 选择一个下标对 \\((p,q)\\) 满足 \\(1\\le p &lt; q \\le n\\) 计算余弦-正弦对 \\((c,s)\\) 使得 \\[ \\begin{bmatrix} b_{pp} &amp; b_{pq}\\\\ b_{qp} &amp; b_{qq}\\\\ \\end{bmatrix} = \\begin{bmatrix} c &amp; s\\\\ -s &amp; c\\\\ \\end{bmatrix}^\\mathrm{T} \\begin{bmatrix} a_{pp} &amp; a_{pq}\\\\ a_{qp} &amp; a_{qq}\\\\ \\end{bmatrix} \\begin{bmatrix} c &amp; s\\\\ -s &amp; c\\\\ \\end{bmatrix} \\] 这一矩阵是对角矩阵，即 \\(b_{pq}=b_{qp}=0\\) 。 用 \\(B=J^\\mathrm{T}AJ\\) 重写矩阵 \\(A\\) ，其中 \\(J=J(p,q,\\theta)\\) 。 关注 \\(B=J^\\mathrm{T}AJ\\) 这一过程，我们讨论 \\(A\\to B\\) 矩阵元素的变化的变化情况。注意到矩阵 \\(B\\) 和矩阵 \\(A\\) 的不同仅在于行、列 \\(p,q\\) 。 下面做出解释。假设 \\(A\\in\\mathbb R^{n\\times n}\\) ，于是 \\(B=J^\\mathrm{T}AJ\\) 这一正交变换可拆分为两步： \\[ \\begin{align} U &amp;= J^\\mathrm{T}A\\\\ B&amp;=UJ \\end{align} \\] 于是 \\[ U=J^\\mathrm{T}A =\\begin{bmatrix} 1 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; c &amp; \\cdots &amp; -s &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; s &amp; \\cdots &amp; c &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix} \\begin{bmatrix} a_{11} &amp; \\cdots &amp; a_{1p} &amp; \\cdots &amp; a_{1q} &amp; \\cdots &amp; a_{1n} \\\\ \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ a_{p1} &amp; \\cdots &amp; a_{pp} &amp; \\cdots &amp; a_{pq} &amp; \\cdots &amp; a_{pn} \\\\ \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots \\\\ a_{q1} &amp; \\cdots &amp; a_{qp} &amp; \\cdots &amp; a_{qq} &amp; \\cdots &amp; a_{qn} \\\\ \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n1} &amp; \\cdots &amp; a_{np} &amp; \\cdots &amp; a_{nq} &amp; \\cdots &amp; a_{nn} \\end{bmatrix} \\] 对于矩阵元素 \\(u_{ij}\\) ， \\[ u_{ij}= \\begin{cases} a_{ij} &amp;i\\neq p,q\\\\ a_{pj}\\cdot c- a_{qj} \\cdot s&amp; i=p\\\\ a_{pj}\\cdot s+a_{qj}\\cdot c&amp; i=q \\end{cases} \\] 可以看到，第一步左乘 \\(J^\\mathrm{T}\\) 的变换相当于只对矩阵 \\(A\\) 的第 \\(p,q\\) 行产生了影响。继续看第二步变换 \\[ B=UJ = \\begin{bmatrix} u_{11} &amp; \\cdots &amp; u_{1p} &amp; \\cdots &amp; u_{1q} &amp; \\cdots &amp; u_{1n} \\\\ \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ u_{p1} &amp; \\cdots &amp; u_{pp} &amp; \\cdots &amp; u_{pq} &amp; \\cdots &amp; u_{pn} \\\\ \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots \\\\ u_{q1} &amp; \\cdots &amp; u_{qp} &amp; \\cdots &amp; u_{qq} &amp; \\cdots &amp; u_{qn} \\\\ \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ u_{n1} &amp; \\cdots &amp; u_{np} &amp; \\cdots &amp; u_{nq} &amp; \\cdots &amp; u_{nn} \\end{bmatrix} \\begin{bmatrix} 1 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; c &amp; \\cdots &amp; s &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; -s &amp; \\cdots &amp; c &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; &amp; \\vdots &amp; &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix} \\] 对于矩阵元素 \\(b_{ij}\\) ， \\[ b_{ij}= \\begin{cases} u_{ij} &amp;j\\neq p,q\\\\ u_{ip}\\cdot c-u_{iq}\\cdot s &amp; j=p\\\\ u_{ip}\\cdot s+u_{iq}\\cdot c &amp; j=q \\end{cases} \\] 可以看到，第二步右乘 \\(J\\) 的变换相当于只对矩阵 \\(U\\) 的第 \\(p,q\\) 列产生了影响。综上所述，影响只产生于行、列 \\(p,q\\) ，所以矩阵 \\(B\\) 和矩阵 \\(A\\) 的不同仅在于行、列 \\(p,q\\) 。 我们下面尝试分析 \\(B=[b_{ij}]\\) 的元素间的关系。可以验证 \\(J\\) 是正交矩阵，即 \\(J^{-1}=J^{\\mathrm{T}}\\) 。那么，通过正交变换得到的矩阵 \\(B\\) 一定是对称矩阵。由于上面分析过的元素关系，我们现在只关注行、列 \\(p,q\\) 。由于矩阵对称，就有行 \\(p\\) 和列 \\(p\\) 是完全一致的，\\(q\\) 同理，他们的值其实在矩阵 \\(U\\) 中就被确定下来。我们暂且不关注 \\(b_{pp},b_{pq},b_{qp},b_{qq}\\) 的值，因为他们被改变了两次，在 \\(U\\) 与在 \\(B\\) 中的值并不相同。除去它们，\\(B\\) 第 \\(p,q\\) 行及列的值为 \\[ \\begin{align} b_{pk}=b_{kp}&amp;=a_{pk}\\cdot c- a_{qk} \\cdot s\\\\&amp;=a_{pk}\\cos\\theta- a_{qk}\\sin\\theta\\\\[5px] b_{qk}=b_{kq}&amp;=a_{pk}\\cdot s+a_{qk}\\cdot c\\\\&amp;=a_{pk}\\sin\\theta+a_{qk}\\cos\\theta \\end{align} \\quad (k\\neq p,q) \\] 我们接下来关注 \\(b_{pp},b_{pq},b_{qp},b_{qq}\\) 四个元素的值。他们由于两次都被改变所以需要单独讨论。由上方 Jacobi 过程的第二步中的矩阵可以较为简单的得到四个元素的值，除去含有正弦余弦的变换矩阵，另两矩阵实际是矩阵 \\(A\\) 和 \\(B\\) 的二阶主子式，由 \\[ \\begin{bmatrix} b_{pp} &amp; b_{pq}\\\\ b_{qp} &amp; b_{qq}\\\\ \\end{bmatrix} = \\begin{bmatrix} c &amp; s\\\\ -s &amp; c\\\\ \\end{bmatrix}^\\mathrm{T} \\begin{bmatrix} a_{pp} &amp; a_{pq}\\\\ a_{qp} &amp; a_{qq}\\\\ \\end{bmatrix} \\begin{bmatrix} c &amp; s\\\\ -s &amp; c\\\\ \\end{bmatrix} \\] 并且由 \\(A\\) 是实对称矩阵，应有 \\(a_{pq}=a_{qp}\\) 。最终求得 \\[ \\begin{align} b_{pp}&amp;=a_{pp}\\cdot c^2+a_{qq}\\cdot s^2-2a_{pq}\\cdot cs\\\\&amp;=a_{pp}\\cos^2\\theta+a_{qq}\\sin^2\\theta-a_{pq}\\sin2\\theta\\\\[5px] b_{qq}&amp;=a_{pp}\\cdot s^2+a_{qq}\\cdot c^2+2a_{pq}\\cdot cs\\\\&amp;=a_{pp}\\sin^2\\theta+a_{qq}\\cos^2\\theta+a_{pq}\\sin2\\theta\\\\[5px] b_{pq}&amp;=b_{qp}=a_{pq}(c^2-s^2)+(a_{pp}-a_{qq})cs\\\\ &amp;=a_{pq}\\cos2\\theta+\\frac 1 2(a_{pp}-a_{qq})\\sin2\\theta \\end{align} \\] 有了以上值之后，不难推得平方和不变的关系成立，即 \\(p,q\\) 行及列平方和相等 \\[ \\begin{gather} a_{pk}^2+a_{qk}^2=c_{pk}^2+c_{qk}^2\\\\ a_{kp}^2+a_{kq}^2=c_{kp}^2+c_{kq}^2\\\\ \\end{gather}\\quad(k\\neq p,q) \\] 并且 \\((p,p),\\ (p,q),\\ (q,p),\\ (q,p)\\) 四个位置平方和不变 \\[ a_{pp}^2+a_{qq}^2+2a_{pq}^2=b_{pp}^2+b_{qq}^2+2b_{pq}^2 \\] 由于 \\(B\\) 对称，有 \\(b_{pq}=0\\) ，则 \\[ a_{pp}^2+a_{qq}^2+2a_{pq}^2=b_{pp}^2+b_{qq}^2 \\] 由于我们前面提到了 \\(F-\\) 范数，我们也可以换一种角度去看待这个问题。 我们首先证明正交变换具有保范性，即对矩阵进行正交变换后范数不变。我们这里只证明 \\(F-\\) 范数。 证明：假设矩阵 \\(A\\in\\mathbb R^{n\\times n}\\) 。对矩阵 \\(A\\) 做奇异值分解，设结果为 \\(A=U\\Lambda V^\\mathrm{T}\\) ，其中 \\(U,V\\) 为正交矩阵。设有一正交矩阵 \\(P\\) ，用以左乘 \\(A\\) 有 \\(PA=PU\\Lambda V^\\mathrm{T}\\) 。可以看到 \\(PU\\) 仍是一正交矩阵，因为 \\[ (PU)^\\mathrm{T}(PU)=U^\\mathrm{T}P^\\mathrm{T}PU=U^\\mathrm{T}(P^\\mathrm{T}P)U=U^\\mathrm{T}U=I=(PU)(PU)^\\mathrm{T} \\] 那么 \\(PU\\Lambda V^\\mathrm{T}\\) 也是矩阵 \\(A\\) 的奇异值分解，并且特征值矩阵 \\(\\Lambda\\) 不变，即特征值不变。 参考定义，矩阵 \\(A\\) 的 \\(F-\\) 范数为 \\[ \\Vert A \\Vert_F=\\sqrt{tr(A^{\\mathrm T}A)}=\\sqrt{\\sum_{i=1}^n\\lambda_i}\\quad \\text{where }\\Lambda=[\\lambda_i] \\] 显然，矩阵 \\(A\\) 的 \\(F-\\) 范数不变。 首先是 \\[ \\begin{bmatrix} b_{pp} &amp; b_{pq}\\\\ b_{qp} &amp; b_{qq}\\\\ \\end{bmatrix} = \\begin{bmatrix} c &amp; s\\\\ -s &amp; c\\\\ \\end{bmatrix}^\\mathrm{T} \\begin{bmatrix} a_{pp} &amp; a_{pq}\\\\ a_{qp} &amp; a_{qq}\\\\ \\end{bmatrix} \\begin{bmatrix} c &amp; s\\\\ -s &amp; c\\\\ \\end{bmatrix} \\] 这一过程。根据上面的性质，可以得到 \\[ a_{pp}^2+a_{qq}^2+2a_{pq}^2=a_{pp}^2+a_{qq}^2+2b_{pq}^2=b_{pp}^2+b_{qq}^2 \\] 并且对于矩阵 \\(A,B\\) 也有 \\[ \\Vert A \\Vert_F=\\Vert B \\Vert_F \\] 有了上面的讨论，我们计算矩阵 \\(B\\) 的非对角元素，有 \\[ \\begin{align} \\mathrm{off}^2\\ B &amp;=\\Vert B\\Vert_F^2-\\sum_{i=1}^nb_{ii}=\\Vert A\\Vert_F^2-\\sum_{i=1}^na_{ii}^2+(a_{pp}^2+a_{qq}^2-b_{pp}^2-b_{qq}^2)\\\\ &amp;=\\mathrm{off}^2\\ A-2a_{pq}^2 \\end{align} \\] 在此意义下，可以看到 \\(\\mathrm{off}\\ B&lt;\\mathrm{off}\\ A\\) ，矩阵 \\(A\\) 通过每一步 Jacobi 旋转法能够更加贴近对角形式。 在讨论如何选取下标对 \\((p,q)\\) 前，先来讨论 \\((p,q)\\) 子问题的实际计算过程。 2 \\(2\\times 2\\) 的对称 Schur 分解 为了让矩阵 \\(\\begin{bmatrix} b_{pp} &amp; b_{pq}\\\\ b_{qp} &amp; b_{qq}\\\\ \\end{bmatrix}\\) 对角化意味着 \\[ 0=b_{pq}=a_{pq}(c^2-s^2)+(a_{pp}-a_{qq})cs \\] 如果 \\(a_{pq}=0\\) ，那我们就令 \\(c=1\\) 并且 \\(s=0\\) 就好了。否则，定义 \\[ \\tau=\\frac{a_{qq}-a_{pp}}{2a_{pq}}\\quad\\text{ and }\\quad t=s/c \\] 得到一元二次方程 \\[ t^2+2\\tau t-1=0 \\] 其中，\\(t=\\tan\\theta=-\\tau\\pm\\sqrt{\\tau^2+1}\\) 是方程的解。 结果发现取两根中较小的是必要的： \\[ t_\\min= \\begin{cases} 1/(\\tau+\\sqrt{1+\\tau^2}) &amp; \\tau\\ge 0\\\\ 1/(\\tau-\\sqrt{1+\\tau^2}) &amp; \\tau&lt; 0\\\\ \\end{cases} \\] 这确保了旋转角 \\(\\theta\\) 满足 \\(|\\theta|\\le\\pi/4\\) （因为 \\(|t|\\le 1\\) 成立）并且能够最小化 \\(c\\) : \\[ c=1/\\sqrt{1+t_\\min^2},\\quad\\quad s=t_\\min c \\] 通过上式也能分别求出 \\(c,s\\) 的值。 这反过来又最小化了 \\(A\\) 和更新 \\(B\\) 之间的差异，通过差的范数表现： \\[ \\Vert B-A\\Vert_F^2=4(1-c)\\sum_{i-1\\atop i\\neq p,q}^n(a_{ip}^2+a_{iq}^2)+2a_{pq}^2/c^2 \\] 3 经典 Jacobi 算法（Jacobi 旋转法） 如前面第一部分提到过的，当解决 \\((p,q)\\) 子问题后，只有 \\(p,q\\) 行及列会被改变。一旦通过第二部分中确定了 \\(2\\times 2\\) 的旋转矩阵，即可通过 \\(A\\leftarrow J(p,q,\\theta)^\\mathrm{T}A\\ J(p,q,\\theta)\\) 去修正 \\(A\\) 。 那么现在的问题是怎么选取下标 \\(p\\) 和 \\(q\\) 。从最大化 \\(\\mathrm{off}\\ A\\) 的减少的角度去考虑，我们有理由选择 \\((p,q)\\) 使得 \\(a_{pq}^2\\) 是最大的，也可以说是使得 \\(|a_{pq}|\\) 是最大的。这是经典 Jacobi 算法的基础。 于是经典 Jacobi 算法的具体步骤为： 给出一个对称矩阵 \\(A\\in\\mathbb R^{n\\times n}\\) ，算法通过使用矩阵 \\(V^\\mathrm{T}AV\\) 覆盖矩阵 \\(A\\) ，其中 \\(V\\) 正交。 选择 \\((p,q)\\) 使得 \\(|a_{pq}|=\\max_{i\\neq j}|a_{ij}|\\) 通过 \\(2\\times 2\\) 的对称 Schur 分解算法（即第二部分中提到的过程）确定 \\([c,s]\\) ，即确定 \\(\\theta\\) 取值 由 \\(p,q,\\theta\\) 产生矩阵 \\(J(p,q,\\theta)\\) ，重写矩阵 \\(A\\) 为 \\[ A=J(p,q,\\theta)^\\mathrm{T}A\\ J(p,q,\\theta) \\] 更新矩阵 \\(V\\) 为 \\[ V=VJ(p,q,\\theta) \\] 因为 \\(|a_{pq}|\\) 是矩阵 \\(A\\) 非对角元素中最大的，那么有 \\[ \\mathrm{off}^2\\ A\\le N(a_{pq}^2+a_{qp}^2) \\] 其中， \\[ N=\\frac{n(n-1)} 2 \\] 简短解释一下上面的不等关系。由于有 \\(\\forall a_{ij},\\ i\\neq j,\\ a_{pq}\\ge a_{ij}\\) ，则 \\(a_{pq}^2\\ge a_{ij}^2\\) 。矩阵中除去主对角线元素，上下三角中各分别有 \\(\\displaystyle N=\\frac{n(n-1)} 2\\) 的元素。将所有不等式相加，即得到上方不等关系。 由不等关系得 \\[ 2a_{pq}^2\\ge \\frac 1 N\\cdot \\mathrm{off}^2\\ A \\] 由 \\[ \\mathrm{off}^2\\ B=\\mathrm{off}^2\\ A-2a_{pq}^2 \\] 推得 \\[ \\mathrm{off}^2\\ B\\le(1-\\frac 1 N)\\cdot \\mathrm{off}^2\\ A \\] 由以上推导，若 \\(A^{(k)}\\) 表示矩阵 \\(A\\) 经历 \\(k\\) 次 Jacobi 迭代后的结果，那么 \\[ \\mathrm{off}^2\\ A^{(k)}\\le(1-\\frac 1 N)^k\\cdot \\mathrm{off}^2\\ A^{(0)} \\] 这表示经典 Jacobi 算法是线性收敛的。 然而，实际上这一算法的收敛速度比线性好的多。Schonhage (1964) 和 van Kempen (1996) 证明了当 \\(k\\) 足够大时，有一常量 \\(c\\) 使得 \\[ \\mathrm{off}\\ A^{(k+N)}\\le c\\cdot\\mathrm{off}^2\\ A^{(k)} \\] 也就是平方收敛。 Reference 教材参考： Matrix Computations 8.5 Jacobi Methods, by Gene H. Golub, Charles F. Van Loan 计算方法 4.3 雅可比旋转法, by 时小虎 et al. Jacobi 方法参考： 经典Jacobi方法用于求解矩阵特征值 - 知乎 (zhihu.com) 范数有关内容参考： (16条消息) 正交矩阵的保范性:正交变换不改变向量的长度(范数)_触不可及&lt;&gt;的博客-CSDN博客_正交变换不改变向量的长度 如何证明矩阵2范数和F范数的正交不变性，谢谢_百度知道 (baidu.com) 参考资料、博客可能无法一一列出，这里一一感谢。","categories":[{"name":"学习杂文","slug":"学习杂文","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/"},{"name":"计算方法","slug":"学习杂文/计算方法","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"}],"tags":[{"name":"Matrix Computation","slug":"Matrix-Computation","permalink":"https://www.leolang.top/tags/Matrix-Computation/"},{"name":"Matrix Theory","slug":"Matrix-Theory","permalink":"https://www.leolang.top/tags/Matrix-Theory/"},{"name":"Numeric Calculation","slug":"Numeric-Calculation","permalink":"https://www.leolang.top/tags/Numeric-Calculation/"}]},{"title":"LeetCode 310","slug":"LeetCode 310 最小高度树","date":"2022-04-05T16:00:00.000Z","updated":"2022-04-07T01:42:00.711Z","comments":true,"path":"2022/04/06/LeetCode 310 最小高度树/","link":"","permalink":"https://www.leolang.top/2022/04/06/LeetCode%20310%20%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/","excerpt":"LeetCode 310 最小高度树","text":"LeetCode 310 最小高度树 Problem Link 310. 最小高度树 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。 给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。 可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。 请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。 树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。 示例 1： img 输入：n &#x3D; 4, edges &#x3D; [[1,0],[1,2],[1,3]] 输出：[1] 解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。 示例 2： img 输入：n &#x3D; 6, edges &#x3D; [[3,0],[3,1],[3,2],[3,4],[5,4]] 输出：[3,4] 提示： 1 &lt;= n &lt;= 2 * 104 edges.length == n - 1 0 &lt;= ai, bi &lt; n ai != bi 所有 (ai, bi) 互不相同 给定的输入 保证 是一棵树，并且 不会有重复的边 Solution LeetCode 最近总是出现写着 Mid 但一点都不 Mid 的题，这道题完全可以作为一个 Hard 出现了。写这篇题解的目的一是自己记录一下本题的推导过程，觉得还是很有意思的；二是 LeetCode 官方题解的推导过程中间出现了一些错误和不够严谨准确的地方，想要更正一下，并且自己也有一些和官方题解推导不一样的地方。下面进入正题。 本题很明显的是一道图论题。拿过来题，看完题之后我们应该能够想到最暴力的写法。 Methods a. 暴力解法 既然题目想要 “所有的 最小高度树 ”，那么我们可以枚举以每个节点作为根构成的树，然后通过某种方式求出这个树的高度，最终取所有树的高度的最小值就是我们要找的最小高度了。最后在记录树的高度的数组中找到等于最小值的高度的树，记录其根节点并返回就可以了。 确实很暴力，很直接，但也很复杂，估算一下时间复杂度大概在 \\(O(n^2)\\) 到 \\(O(n^3)\\) 左右。事实是按照这种方法写完之后会超时。 那么我们就得想一种复杂度不是很高的算法了。说实话不看题解以我的水平很难想得到这么妙的解法。 Methods b. 官方解法 首先给出接下来要使用的符号。 记树上总节点数为 \\(n\\) 。 记树上任意节点 \\(i\\) 到节点 \\(j\\) 的距离为 \\(D_{ij}\\) ，所有距离构成集合 \\(D=\\{D_{ij}\\}\\) ，其中 \\(i\\neq j\\) ，且 \\(i,j\\in[1,n],\\ i,j\\in\\mathbb{Z}\\) 。假设树上最长距离为点对 \\((x, y)\\) 间的距离，即 \\(\\max D=D_{xy}\\) 。为下文简便，这里简记最大距离为 \\(D_m\\) 。 记以每个节点为根节点的树的最小高度为 \\(h\\) 。 接下来就是一个我认为几乎不可能想到的定理。 Theorem 树上以任意节点构成的树的最小高度 \\(h\\) 一定为 \\(\\displaystyle\\lceil \\frac {D_m} 2 \\rceil\\) ，且最小高度的树的根节点一定在 \\(x\\) 到 \\(y\\) 的路径上。 下面给出定理的证明。 Proof 首先证明树的最小高度问题，即 \\(h=\\displaystyle\\lceil \\frac {D_m} 2 \\rceil\\) 成立。 使用反证法证明上述命题。假设树上存在一节点 \\(z\\) ，以节点 \\(z\\) 为根的树的高度 \\(h&#39;&lt;h\\) 。 由于不知道节点 \\(z\\) 在树上对于从 \\(x\\) 到 \\(y\\) 的路径的关系（是否在路径上），于是分两种情况讨论。 节点 \\(z\\) 在路径上 显然，点 \\(x,\\ y\\) 应均为当以 \\(z\\) 为根节点观察时的叶节点，否则一定存在一条路径长于当前最长路径。假设 \\(x\\) 为非叶节点，一定有 \\(x\\) 的子树的一叶节点 \\(x&#39;\\) 能够延长原路径，且一定能够从 \\(x&#39;\\) 经 \\(x\\) 到达 \\(y\\) 。 那么，从 \\(x\\) 到 \\(y\\) 的路径就可拆分为 \\(x\\to\\cdots\\to z\\) 和 \\(z\\to\\cdots\\to y\\) 。根据树的高度的定义，一定有 \\(D_{xz},D_{zy}\\le h&#39; &lt;h\\) 成立。由于 \\(h&#39;,h\\in\\mathbb Z\\) ，则一定有 \\(h&#39;\\le h-1\\) 成立。 我们计算 \\(D_{xy}\\) 得 \\[ \\begin{align} D_{xy} &amp;=D_{xz}+D_{zy}\\\\ &amp;\\le2h&#39;\\le2(h-1)=2\\times\\lceil\\frac{D_m} 2\\rceil-2\\\\ &amp;&lt;D_{xy} \\end{align} \\] 这与 \\(D_{xy}=D_{xy}\\) 矛盾。 节点 \\(z\\) 不在路径上 如果 \\(z\\) 不在这条路径上，那么转换为以 \\(z\\) 为根的视角观察，有路径 \\(z\\to\\cdots\\to x\\) 、路径 \\(z\\to\\cdots\\to y\\) ，并且点 \\(x,y\\) 一定有一共同祖先，记为节点 \\(a\\) ，这一节点也是上述两条路径的唯一公共点。 那么现在，以上两条路径可以进一步拆分为以下形式： \\[ \\begin{align} &amp;\\text{Path from }z\\text{ to } x\\quad z\\to\\cdots\\to a\\to\\cdots\\to x \\iff z\\to\\cdots\\to a\\quad +\\quad a\\to\\cdots\\to x\\\\ &amp;\\text{Path from }z\\text{ to } y\\quad z\\to\\cdots\\to a\\to\\cdots\\to y \\iff z\\to\\cdots\\to a\\quad +\\quad a\\to\\cdots\\to y\\\\ \\end{align} \\] 于是有 \\[ \\begin{align} D_{zx}=D_{za}+D_{ax}\\\\ D_{zy}=D_{za}+D_{ay}\\\\ \\end{align} \\] 由树的高度的定义，有 \\[ \\begin{align} D_{zx}=D_{za}+D_{ax}\\le h&#39;\\\\ D_{zy}=D_{za}+D_{ay}\\le h&#39;\\\\ \\end{align} \\] 仍然以 \\(z\\) 为根的视角观察树，一定有 \\(D_{za}\\ge 1\\) 成立，因为 \\(a\\) 一定是 \\(z\\) 的子节点。那么，将 \\(D_{za}\\ge 1\\) 代入上面的不等式，可以推得 \\[ \\begin{align} D_{ax}\\le h&#39;-1\\\\ D_{ay}\\le h&#39;-1 \\end{align} \\] 我们发现，由于引入了一路径公共点 \\(a\\) ，点对 \\((x,y)\\) 间的路径就可以拆分为 \\[ \\text{Path from }x\\text{ to } y\\quad x\\to\\cdots\\to a\\to\\cdots\\to y \\iff x\\to\\cdots\\to a\\quad +\\quad a\\to\\cdots\\to y \\] 于是有 \\(D_{xy}=D_{xa}+D_{ay}\\) 成立。由于树是无向图，应有 \\(D_{ij}\\iff D_{ji}\\) （注意这里使用的是等价，表示两者意义相同）。那么根据上面推导的不等式，我们可以计算 \\(D_{xy}\\) 得 \\[ \\begin{align} D_{xy} &amp;=D_{ax}+D_{ay}\\\\ &amp;\\le 2h&#39;-2\\\\ &amp;&lt;2h-2=2\\times\\lceil\\frac{D_m} 2\\rceil-2\\\\ &amp;&lt;D_{xy} \\end{align} \\] 与第一种情况一样的，得到矛盾。 于是假设不成立，命题 \\(h=\\displaystyle\\lceil \\frac {D_m} 2 \\rceil\\) 证毕。 以上，我们证明了定理的前半部分，即树的最小高度 \\(h=\\displaystyle\\lceil \\frac {D_m} 2 \\rceil\\) 成立。说实话我没有想到这个值的一个很确切的来由。如果根据这个值反过来想的话，应该是把最长的一条路从一个位于正中间的点将树拎起来，这样就出现了一个高度比较平均的结构。但我也没有想清楚为什么这是最小的一个高度值。 接下来证明定理的后半部分，最小高度的树的根节点一定在 \\(x\\) 到 \\(y\\) 的路径上。 同样的，使用反证法进行证明。假设存在一点 \\(z\\) ，其能够取得最小高度 \\(h\\) ，但 \\(z\\) 并不在从 \\(x\\) 到 \\(y\\) 的路径上。 与刚刚上半部分证明的第二种情况的证明思路类似，我们一定能够找到唯一的路径公共点 \\(a\\) ，并且能够拆分路径。我们此时已知 \\(z\\) 是一个能够取得最小高度 \\(h\\) 的节点，于是一定有如下不等式成立： \\[ \\begin{align} D_{zx}=D_{za}+D_{ax}\\le h\\\\ D_{zy}=D_{za}+D_{ay}\\le h\\\\ \\end{align} \\] 同样的，由于 \\(z\\) 不在路径上，并且有一路径交叉点 \\(a\\) ，以 \\(z\\) 为根的视角观察树，一定有 \\(D_{za}\\ge 1\\) 成立。那么推得 \\[ \\begin{align} D_{ax}\\le h-1\\\\ D_{ay}\\le h-1 \\end{align} \\] 我们仍然计算 \\(D_{xy}\\) 得 \\[ \\begin{align} D_{xy} &amp;=D_{ax}+D_{ay}\\\\ &amp;\\le 2h-2=2\\times\\lceil\\frac{D_m} 2\\rceil-2\\\\ &amp;&lt;D_{xy} \\end{align} \\] 得到矛盾。 于是假设矛盾，命题证毕。 综上所述，定理证毕。 根据以上定理，我们不难得到以下推论。 Corollary 假设最长路径上的 \\(m\\) 个节点依次为 \\[ p_1\\to p_2\\to\\cdots\\to p_m \\] 显然最长路径长度为 \\(m-1\\) 。 如果 \\(m\\) 为偶数，此时最小高度树的根节点为 \\(p_{m/2}\\) 或 \\(p_{\\frac m 2 + 1}\\) ，最小高度为 \\(h=\\displaystyle \\frac m 2\\) ； 如果 \\(m\\) 为奇数，次数最小高度树的根节点为 \\(p_{\\frac {m+1} 2}\\) ，最小高度为 \\(h=\\displaystyle \\frac{m - 1} 2\\) 。 那么，我们只需先在树中求出路径最长的两个叶节点，之后求出其路径，最后取其正中间的一个或两个节点记为最小高度树的根节点。下面讨论如何求出路径最长的两个叶节点。 对于树中任意节点 \\(p\\) ，可通过 BFS 或 DFS 求得与 \\(p\\) 距离最远的那个节点。 那么可利用如下算法得到树中距离最远的两个节点： 从任意节点 \\(p\\) 出发，求得距离 \\(p\\) （以 \\(p\\) 为起点的）最远的路径终点 \\(x\\) 从节点 \\(x\\) 出发，找到以 \\(x\\) 为起点的最长路径的终点 \\(y\\) 通过该算法即可找到图中的最长路径，为从 \\(x\\) 到 \\(y\\) 的路径，这一路径也叫做树的直径。 我们首先以比较通俗的方式粗略理解一下这个算法。假设我们就从能取得最小高度的节点作为根节点出发。由根节点向一个方向进行遍历找到距离它最远的叶节点。之后再从这一叶节点出发，找到的距离这个叶节点的最远的另一个叶节点。这一过程相当于是从根节点又反向的延长了原来找到的路径，从而找到了在当前树中的最长路径。 这一问题其实出自著名难啃大黑书《算法导论》图论算法的一道图遍历算法的课后题。这里把这道题贴一下。 Exercises 22.2-7 *, Page 539 in Second Edition, or Exercises 22.2-8 *, in Third Edition. The diameter of a tree \\(T=(V,E)\\) is given by \\[ \\large\\max_{u,v\\in V}\\delta(u,v) \\] that is, the diameter is the largest of all shortest-path distances in the tree. Give an efficient algorithm to compute the diameter of a tree, and analyze the running time of your algorithm. 首先给出《算法导论》中 \\(\\delta\\) 的定义：定义 \\(\\delta(u, v)\\) 为从 \\(u\\) 到 \\(v\\) 的所有路径中最短的边数。 问题定义了树的直径。树的直径定义为树中所有最短路径距离 \\(\\delta\\) 的最大值。问题要求我们给出一个有效的算法去计算树的直径。 下面给出这一算法正确性的严谨证明，来自 MIT 开设的课程 Introduction to Algorithms 中给出的作业解答。原文件链接在最后一部分中给出。 首先给出算法描述便于以下证明过程使用： 对于图中任取一节点使用 BFS 算法，记最后被遍历到的节点为 \\(u\\) 。从 \\(u\\) 使用 BFS 算法，记此时最后被遍历到的点是 \\(v\\) 。那么 \\(\\delta(u,v)\\) 就是树的直径。 Proof 取树上节点 \\(a,b\\) ，使得 \\(\\delta(a, b)\\) 是树的直径，并且从 \\(a\\) 到 \\(b\\) 有一条独特的路径作为树的直径。令节点 \\(t\\) 为算法第一步中 BFS 所遍历到的第一个节点（实际 \\(t\\) 可以指与初始节点直接邻接的任一点）。 记路径 \\(p_1\\) 是从 \\(s\\) 到 \\(u\\) 的路径，\\(p_2\\) 是从 \\(a\\) 到 \\(b\\) 的路径。 如果 \\(p_1\\) 和 \\(p_2\\) 没有公共的边，那么从 \\(t\\) 到 \\(u\\) 的路径必定包含 \\(s\\) ，那么有 \\[ \\delta(t,u)\\ge \\delta(s,u) \\] 这里解释一下为什么有路径和点的包含关系。我们画一个图会更好理解。\\(p_1\\) 和 \\(p_2\\) 如果没有公共边，证明两条直径 \\(\\delta(u,v)\\) 的路径和 \\(\\delta(a, b)\\) 的路径在图中是 “分立” 的，即这两条路径只可能 \\(0\\) 或 \\(1\\) 个公共点。由于图里的边是可以随意翻转的，和边的位置无关，那形象一点描述就是这个图足够的 “伸展” 。那么由于 \\(t\\) 的定义，一条从 \\(t\\) 到 \\(u\\) 的路径是一定可以包含 \\(s\\) 的。事实上严谨的说这里 \\(t\\) 应该是取和 \\(s\\) 向 \\(u\\) 大致方向相反的方向的一个点时才成立。 由于 \\(u\\) 是最后才被遍历到的点，那么可以推得一定有距离关系 \\(\\delta(s,u)\\ge\\delta(s,a)\\) 成立。那么得到 \\[ \\delta(t,u)\\ge\\delta(s,a) \\] 再一次由从 \\(t\\) 到 \\(u\\) 的路径必定包含 \\(s\\) ，可得 \\(\\delta(s,a)\\ge\\delta(t,a)\\) ，这里应取 \\(t\\) 是和 \\(s\\) 向 \\(u\\) 大致方向相同的方向的一个点。那么得到 \\[ \\delta(t,u)\\ge\\delta(t,a) \\] 接下来，由于从 \\(s\\) 其一定通过 BFS 能找到 \\(b\\) ，那么上式便可以推广到节点 \\(b\\) ，便有 \\[ \\delta(b,u)\\ge\\delta(b,a) \\] 由于直径 \\(\\delta(a,b)\\) 是最长的路径，那么有 \\(\\delta(a,b)\\ge\\delta(u,b)\\) 。那么得到 \\(\\delta(a,b)=\\delta(u,b)\\) 。 上述推导过程归纳为 \\[ \\begin{align} \\delta(t,u)\\ge\\delta(s,u) &amp;\\iff\\delta(t,u)\\ge\\delta(s,a)\\\\ &amp;\\iff\\delta(t,u)\\ge\\delta(t,a)\\\\ &amp;\\iff\\delta(b,u)\\ge\\delta(b,a)\\\\ \\end{align} \\] 之后 \\[ \\left. \\begin{gather} \\delta(a,b)\\le\\delta(u,b)\\\\[3px] \\delta(a,b)\\ge\\delta(u,b) \\end{gather} \\right\\}\\Rightarrow \\delta(a,b)=\\delta(u,b) \\] 如果 \\(p_1\\) 和 \\(p_2\\) 有公共边，那么显然 \\(t\\) 一定在 \\(p_1\\) 上。因为 \\(u\\) 是最后被 BFS 找到的节点，那么一定有 \\(\\delta(t,u)\\ge \\delta(t,a)\\) 。因为 \\(p_2\\) 是直径的路径，是最长的路径，那么就有 \\(\\delta(t,a)\\ge\\delta(t,u)\\) 成立。因此有 \\[ \\left. \\begin{gather} \\delta(t,u)\\le\\delta(t,a)\\\\[3px] \\delta(t,u)\\ge\\delta(t,a) \\end{gather} \\right\\}\\Rightarrow \\delta(t,u)=\\delta(t,a) \\] 和前一种情况一样，我们也能推得 \\(\\delta(u,b)=\\delta(a,b)\\) 。 于是根据以上的证明，我们得到 \\(\\delta(a,b)=\\delta(u,b)\\) 。由于 \\(\\delta(a,b),\\delta(u,v)\\) 都是最长的距离，就有一下不等式成立： \\[ \\begin{align} \\delta(a,b)\\ge\\delta(u,v)\\\\ \\delta(u,v)\\ge\\delta(u,b) \\end{align} \\] 那么综合以上式子，我们有以下推理： \\[ \\left.\\begin{gather} \\delta(a,b)=\\delta(u,b)\\\\ \\delta(a,b)\\ge\\delta(u,v)\\\\ \\delta(u,v)\\ge\\delta(u,b) \\end{gather}\\right\\}\\Rightarrow \\delta(a,b)=\\delta(u,b)=\\delta(u,v) \\] 则 \\(\\delta(u,v)\\) 就是树的直径。 算法正确性证毕。 根据以上所有内容，我们可以得到以下算法实现。当然，获得距离最远的点也可以通过 DFS 得到，下面代码部分只给出了 BFS 的版本。另外，此题也可使用拓扑排序或换根树形 DP 求解，感兴趣的读者可以自行研究，LeetCode 上都有相关题解。 Submit Code lang = C++ class Solution &#123; public: vector&lt;int> findMinHeightTrees(int n, vector&lt;vector&lt;int>>&amp; edges) &#123; if (n == 1) return &#123;0&#125;; vector&lt;vector&lt;int>> g(n); for (auto &amp;edge : edges) &#123; int u = edge[0], v = edge[1]; g[u].emplace_back(v); g[v].emplace_back(u); &#125; vector&lt;int> pa(n, -1); int x = bfs(0, pa, g); int y = bfs(x, pa, g); pa[x] = -1; vector&lt;int> path; while (y != -1) &#123; path.emplace_back(y); y = pa[y]; &#125; int m = path.size(); if (m % 2) return &#123;path[m / 2]&#125;; else return &#123;path[m / 2], path[m / 2 - 1]&#125;; &#125; int bfs(int u, vector&lt;int> &amp;pa, vector&lt;vector&lt;int>> &amp;g) &#123; queue&lt;int> q; int n = g.size(); vector&lt;bool> vis(n); q.emplace(u); vis[u] = true; int ans = -1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); ans = cur; for (auto &amp;v : g[cur]) &#123; if (!vis[v]) &#123; vis[v] = true; q.emplace(v); pa[v] = cur; &#125; &#125; &#125; return ans; &#125; &#125;; lang = Python3 class Solution: def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]: if n == 1: return [0] g = [[] for _ in range(n)] for x, y in edges: g[x].append(y) g[y].append(x) pa = [-1] * n def bfs(u): q = deque([u]) vis = [False] * n vis[u] = True ans = -1 while q: cur = q.popleft() ans = cur for v in g[cur]: if not vis[v]: vis[v] = True pa[v] = cur q.append(v) return ans x = bfs(0) y = bfs(x) path = [] pa[x] = -1 while y != -1: path.append(y) y = pa[y] m = len(path) if m % 2: return [path[m // 2]] else: return [path[m // 2], path[m // 2 - 1]] lang = Java class Solution &#123; public List&lt;Integer> findMinHeightTrees(int n, int[][] edges) &#123; List&lt;Integer> ans = new ArrayList&lt;>(); if (n == 0) &#123; ans.add(0); return ans; &#125; List&lt;Integer>[] g = new List[n]; for (int i = 0; i &lt; n; i++) &#123; g[i] = new ArrayList&lt;>(); &#125; for (int[] edge : edges) &#123; int x = edge[0], y = edge[1]; g[x].add(y); g[y].add(x); &#125; int[] pa = new int[n]; Arrays.fill(pa, -1); int x = bfs(0, pa, g); int y = bfs(x, pa, g); pa[x] = -1; List&lt;Integer> path = new ArrayList&lt;>(); while (y != -1) &#123; path.add(y); y = pa[y]; &#125; int m = path.size(); ans.add(path.get(m / 2)); if (m % 2 == 0) &#123; ans.add(path.get(m / 2 - 1)); &#125; return ans; &#125; private int bfs(int u, int[] pa, List&lt;Integer>[] g) &#123; Queue&lt;Integer> q = new ArrayDeque&lt;>(); int n = g.length; boolean[] vis = new boolean[n]; vis[u] = true; q.offer(u); int ans = -1; while (!q.isEmpty()) &#123; int cur = q.poll(); ans = cur; for (int v : g[cur]) &#123; if (!vis[v]) &#123; vis[v] = true; q.offer(v); pa[v] = cur; &#125; &#125; &#125; return ans; &#125; &#125; Code Explaination None Reference LeetCode 官方题解 最小高度树 - 最小高度树 - 力扣（LeetCode） (leetcode-cn.com) Introduction to algorithms (Second Edition) , Thomas H. Cormen, Charles E. Leiserson, et al.（《算法导论》英文版，第二版） MIT Handout 32: Problem Set 9 Solutions, Nov.21, 2001 ps9sol.pdf (mit.edu)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"https://www.leolang.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://www.leolang.top/tags/BFS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://www.leolang.top/tags/Graph-Algorithms/"}]},{"title":"Django 教程（三）","slug":"Django教程（三）","date":"2022-03-31T16:00:00.000Z","updated":"2022-04-01T13:35:27.739Z","comments":true,"path":"2022/04/01/Django教程（三）/","link":"","permalink":"https://www.leolang.top/2022/04/01/Django%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"前言 本文将介绍 Django 与数据库做交互的组成部分之 —— Django 模型。","text":"前言 本文将介绍 Django 与数据库做交互的组成部分之 —— Django 模型。 Django 教程（三） Django 模型 所谓 Django 模型，是 Django 框架用于与数据库进行交互的部分。 Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。 Django 为这些数据库提供了统一的调用API。 我们可以根据自己业务需求选择不同的数据库。 MySQL 是 Web 应用中最常用的数据库。本章节我们将以 Mysql 作为实例进行介绍。 首先，你的环境中应有 Python 的 MySQL 驱动，如果没有安装的话可以通过如下方式安装： （以第一讲中创建的 conda 环境 django 为例） $ conda activate django # 激活 conda 环境 $ conda install pymysql # 下载 MySQL 驱动 1 Django ORM Django 模型使用了自带的 ORM。所谓 ORM ，即对象关系映射（Object Relational Mapping, ORM for short）。ORM 用于实现面向对象编程语言中不同系统数据之间的转换。 什么是 ORM？ 对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。如今已有很多免费和付费的ORM产品，而有些程序员更倾向于创建自己的ORM工具。 摘自【百度百科】。传送门：对象关系映射_百度百科 (baidu.com) 对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的资料之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。 简单的说：ORM相当于中继资料。 摘自【维基百科】。传送门：对象关系映射_维基百科 【知乎】结合 Django 对 ORM 的解释。传送门：科普文-什么是ORM? - 知乎 (zhihu.com) ORM 在业务逻辑层和数据库层间起到了桥梁的作用。 ORM 是通过使用描述对象和数据库之间的映射的元数据，将程序中的对象自动持久化到数据库中。 ORM 解析过程: 1、ORM 会将 Python 代码转成为 SQL 语句。 2、SQL 语句通过 pymysql 传送到数据库服务端。 3、在数据库中执行 SQL 语句并将结果返回。 ORM 对应关系表： 2 Django to MySQL 2.1 创建数据库 连接数据库 应注意的是，ORM 只能操作数据表级别，无法操作数据库级别。 首先，通过 Terminal 创建一个这个项目专用的数据库。登录 MySQL。 $ mysql -u root -p # login MySQL ... # password 在 MySQL 命令行中创建数据库 &gt; create database djangoTest default charset&#x3D;utf8; 在之前的 settings.py 文件中找到 DATABASE 配置项，将信息修改为： DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': 'djangoTest', # 数据库名称 'HOST': '127.0.0.1', # 数据库地址，本机 ip 地址 127.0.0.1 'PORT': 3306, # 端口 'USER': 'root', # 数据库用户名 'PASSWORD': *******, # 数据库密码，可自行修改 &#125; &#125; 之后，告知 Django 使用 pymysql 连接刚刚创建好的 MySQL 数据库。修改和 settings.py 同级的包初始化目录 __init__.py 如下： import pymysql pymysql.install_as_MySQLdb() 2.2 定义模型 首先应创建一个 APP。Django 规定，如果要使用模型，必须要先创建一个 APP。使用如下命令在 Terminal 中创建一个 TestModel 的 APP：（当前在项目主目录下） $ django-admin startapp TestModel 于是，便得到了一个名为 TestModel 的 Python 包。创建后的目录结构如下： HelloWorld |-- HelloWorld |-- manage.py ... |-- TestModel | |-- __init__.py | |-- admin.py | |-- models.py | |-- tests.py | `-- views.py 之后，我们修改 TestModel/models.py 文件，目的是通过 ORM 的方式创建数据库表。 from django.db import models # 如果使用 Pycharm，本语句应该已经生成 # create your model here class Test(models.Model): name = models.CharField(max_length=20) 以上，我们创建了一个数据库表，类名并不完全对应数据库表名，我们后文还会再提，这里先搁置。这个类继承了 models.Model ，定义了类里面的类成员 name （注意是类成员而不是定义在 def __init__(self, *args, **kwargs) 中的成员变量），代表了我们在数据库中创建了一个字段 name 。赋值号后面的函数限制了这一字段的数据类型，这里面的 CharField() 函数相当于数据库中的 varchar 类型，还有很多的 “xxxField” ，他们都用来限制某一字段的数据类型，详细的可以参考以下官方文档：Model field reference | Django documentation | Django (djangoproject.com) 当中的介绍。之后，函数的参数 max_length 顾名思义，是变量长度的限定。 如果你觉得上面的的文字介绍过于的繁杂，那么下面用一个 Django 和 SQL 的对比来看一下更加直观的对应关系。 以下例子摘自官方文档。传送门 Models | Django documentation | Django (djangoproject.com) 我们创建一个模型，定义了一个人，这个人有姓和名。 首先是 Django 语法： from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) 我们创建了一个 Person 模型，这个模型有两个字段，分别是 first_name 和 last_name 。每个字段都指定为一个类属性，并且每个属性都映射到一个数据库列。 接下来将上面的 Django 语句（其实就是 Python 语句）用 SQL 语言的方式进行翻译： create table myapp_person ( id serial not null primary key, first_name varchar(30) not null, last_name varchar(30) not null ); 可以看到，我们在 Python 类中声明的两个字段都对应到了数据库表的一个列上，另外，Django 还会默认为每一张数据库表生成一个 id 作为自动主键字段（Automatic primary key fields）。 之后要告知 Django 这一 APP 的存在，修改 settings.py 文件中的 INSTALLED_APPS ，将我们刚才创建的这一个 APP 添加进去： INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'TestModel', # 添加此项 ) 当我们更新了一个新的 APP 到工程中是，我们要执行几个命令来告知 Django 我们的模型产生了变更，即在数据库中按照我们使用 ORM 所定义的格式去创建一些数据表。 官方的说明是： When you add new apps to INSTALLED_APPS, be sure to run manage.py migrate, optionally making migrations for them first with manage.py makemigrations. 在 Terminal 中运行如下命令：（以下命令应在当前工程目录下运行） $ python3 manage.py migrate 或 $ python3 manage.py makemigrations TestModel $ python3 manage.py migrate TestModel 第一种方式是全局性更新，第二种方式是只针对我们刚刚添加的这一个模型进行更新。所谓更新，其实这里就是指创建表结构。两种方式使用一种即可，都可以做到对模型进行更新。运行过该命令之后，不同环境下 Django 可能会有不同的提示。我们可以去数据库中使用 SQL 语言或可视化工具进行查看，如果创建成功，当前数据库中应该有一个 TestModel_test 的数据表。 关于 django-admin migrate 命令的官方文档 django-admin and manage.py | Django documentation | Django (djangoproject.com) 2.3 数据库操作 接下来在 HelloWorld 包目录下添加 testdb.py 文件（文件名任意），该文件定义了对于数据库的一系列操作。之后修改 urls.py ，目的是我们要创建一个新的次级页面用于显示提示信息，类似于之前教程中使用了 django.shorcuts.render() 的函数 hello() 最终产生的在页面 http://localhost:8000/hello 上的效果。 urls.py 代码更改如下： from django.urls import path from . import views, testdb # 把 testdb 也导进来 urlpatterns = [ path('hello/', views.hello), path('testdb/', testdb.testdb), # 这里与上一行的语义一致，同样对应了文件中的一个函数 ] 接下来，我们通过 testdb.py 定义数据库的增删改查操作。 2.3.1 添加数据 添加数据的方法是： 创建一个我们当时在用于生成数据库表结构的模型文件中声明过的那个类的实例，简单地说，就是实例化一个当前数据表对应模型类的实例对象。 对上一步中生成的对象调用 save() 方法。 例如，我们要在我们刚刚创建的数据库中添加一条记录，其属性值为 demo1 。 from django.http import HttpResponse from TestModel.models import Test # 导入对应的类 def testdb(request): test1 = Test(name='demo1') test1.save() return HttpResponse(\"&lt;p>Success!&lt;/p>\") 这一句转化成 SQL 语言相当于： insert into TestModel_test values ('demo1'); 这时候访问 http://localhost:8000/testdb 就可以看到数据添加成功的提示了，同时，查询数据库，可以看到数据库中多了一条 name 为 demo1 的记录。 2.3.2 获取数据 Django 提供了多种方式来获取数据库当中的内容。 官方文档传送门：Making queries | Django documentation | Django (djangoproject.com) 根据官方文档： To retrieve objects from your database, construct a QuerySet via a Manager on your model class. A QuerySet represents a collection of objects from your database. It can have zero, one or many filters. Filters narrow down the query results based on the given parameters. In SQL terms, a QuerySet equates to a statement, and a filter is a limiting clause such as or SELECT WHERE LIMIT You get a QuerySet by using your model’s Manager. Each model has at least one Manager, and it’s called objects by default. 每个数据表都提供了一个 Manager 用于从数据库中检索对象，默认叫做 objects 。可以对于这个管理器添加 filter，对应到 SQL 当众，一个 Manager 可以理解成一个数据表的对象的集合，之后添加的过滤器可以理解为是限制子句。 应注意的是，一个模型的 Manager 只能通过模型类访问，而不是从模型实例进行访问，证明我们是针对表的查询而不是针对 “记录” 的查询。 >>> Blog.objects # 一个模型类 &lt;django.db.models.manager.Manager object at ...> >>> b = Blog(...) # 一个模型对象 >>> b.objects Traceback: ... AttributeError: \"Manager isn't accessible via Blog instances.\" Django 定义了很多的过滤器，对于与 SQL 语言的不同限制子句。下表列出了较为常用的几种过滤器，模型的 Manager 简写为 o ，并省略参数，只提及方法名。 Filter Funtion SQL o.all() 检索所有对象 select * from o.filter() 返回一个新的 QuerySet 包含与给定参数匹配的对象 where o.exclude() 返回一个新的 QuerySet 包含与给定参数不匹配的对象 where not o.get() 返回与给定查找参数匹配的对象，保证唯一的查找 None o.order_by() 默认情况下，由 返回的结果按模型的 选项给出的排序元组排序 order by 官方提供的的全部 QuerySet API： QuerySet API reference | Django documentation | Django (djangoproject.com) 更详细的信息可以查阅官方文档。 2.3.3 更新数据 修改数据可以使用 save() 或 update() ，和数据库一致，都是先从数据库中进行查询，之后再进行更新。相当于 SQL 的 update 。 from django.http import HttpResponse from TestModel.models import Test def testdb(request): # 修改其中一个id=1的name字段，再save，相当于SQL中的UPDATE test1 = Test.objects.get(id=1) test1.name = 'Google' test1.save() # 另外一种方式 #Test.objects.filter(id=1).update(name='Google') # 修改所有的列 # Test.objects.all().update(name='Google') return HttpResponse(\"&lt;p>修改成功&lt;/p>\") 2.3.4 删除数据 删除数据只需对某一个模型对象调用其 delete() 方法即可。 from django.http import HttpResponse from TestModel.models import Test def testdb(request): # 删除id=1的数据 test1 = Test.objects.get(id=1) test1.delete() # 另外一种方式 # Test.objects.filter(id=1).delete() # 删除所有数据 # Test.objects.all().delete() return HttpResponse(\"&lt;p>删除成功&lt;/p>\")","categories":[{"name":"学习杂文","slug":"学习杂文","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/"},{"name":"Django","slug":"学习杂文/Django","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://www.leolang.top/tags/Django/"},{"name":"Front End","slug":"Front-End","permalink":"https://www.leolang.top/tags/Front-End/"}]},{"title":"Django 教程（二）","slug":"Django教程（二）","date":"2022-03-30T16:00:00.000Z","updated":"2022-03-31T13:55:57.791Z","comments":true,"path":"2022/03/31/Django教程（二）/","link":"","permalink":"https://www.leolang.top/2022/03/31/Django%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"前言 本文将介绍 Django 的组成部分之一，Django 模板。","text":"前言 本文将介绍 Django 的组成部分之一，Django 模板。 Django 教程（二） Django 模板 1 打印 Hello World! 创建你的一个项目后，文档结构应为（假设创建项目为 HelloWorld）： . |-- HelloWorld | |-- __init__.py | |-- asgi.py | |-- settings.py | |-- urls.py | &#96;-- wsgi.py &#96;-- manage.py 接下来介绍 Django 模板。Django 模板是一个文本，用于分离文档的表现形式和内容。 于是我们建立模板目录。在项目目录下建立 templates 目录。接下来向 Django 说明模板文件的路径。可以看到在项目文件夹中有一个名为 settings.py 的文件，修改其中 TEMPLATES 中的 DIRS 为 [os.path.join(BASE_DIR, 'templates')] 。 ... TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], # 修改位置 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;, ] ... 这时对于模板的目录就创建完成了，Django 现在知道了我们的模板文件的路径。 那么之后，这里我们目的是要实现一个显示 Hello World! 的页面，接下来实现。 首先创建一个模板： 创建一个 HTML 页面。在刚才创建的 templates 目录下创建一个 HTML 文档，假设我们创建的为 hello.html 。文件内容如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Hello World&lt;/title> &lt;/head> &lt;body> &lt;h1> &#123;&#123; hello &#125;&#125; &lt;/h1> &lt;/body> &lt;/html> Django 中规定，在模板中使用变量格式为双括号夹变量名，即 &#123;&#123; variable &#125;&#125; 那么可以看到，我们在模板中引入了一个 hello 变量。 之后修改 views.py 文件，增加一个新的对象，用于向模板提交数据： from django.shortcuts import render def hello(request): context = &#123;&#125; context['hello'] = 'Helllo World!' return render(request, 'hello.html', context) 这里简短解释一下这段代码的含义。对于函数 render() 官方文档的解释如下： Return a HttpResponse whose content is filled with the result of calling django.template.loader.render_to_string() with the passed arguments. 即返回一个 HttpResponse，它的内容是使用传入的参数调用 django.template.loader.render_to_string() 的结果。这里可以粗略理解为在这个函数中，我们人为创建了一些数据对象，而我们期望在模板中使用这些数据对象，将其展示在页面上。通过 render() 函数将其与我们创建的某个模板（HTML文件，即页面）联系到一起。模板本身是一个未完成的、不完整的 HTML 页面，通过这个函数将我们定义的数据对象提交给这个模板，就能够自动的将使用到变量的地方自动替换成其值。 同时，我们更改网站页面的层级结构，增加一个页面 hello。方法是修改 urls.py 为 from django.urls import path from . import views urlpatterns = [ path('hello', views.hello), ] 这段代码告知 Django 我们要生成一个次级页面，为 localhost:8000/hello 。 那么现在，视图与模板就绑定到了一起了，我们通过 render 函数将字典 context 中 hello 键值传给了模板中的对应变量 hello。这时，运行项目，访问 http://localhost:8000/hello 便可以看到页面。页面上显示了一个一级标题 Hello World! 。 2 Django 模板标签 2.1 引入变量 通过上面的例子，可以看到 Django 模板引入变量的格式是： views.py 中： &#123;\"var_in_html\": \"var_in_views\"&#125; 而在模板 xxx.html 中： &#123;&#123; var_in_html &#125;&#125; 对于不同数据类型而言： 一般变量 正常引用，如上文所示。 列表 可以通过下标索引穿透到具体元素，格式为 List.index。假设通过函数引入列表变量 def hello(request): views_list = ['a', 'b', 'c'] return render(request, 'hello.html', &#123;'views_list': views_list&#125;) 模板中以如下格式可引入变量： &lt;p> &lt;!-- import views_list, print \"['a','b','c']\" --> &#123;&#123; views_list &#125;&#125; &lt;/p> &lt;p> &lt;!-- import views_list[0], i.e., 'a' --> &#123;&#123; views_list.0 &#125;&#125; &lt;/p> 字典 可以通过键名的方式引入对应的值，格式为 Dict.key 。假设通过函数引入字典变量 def hello(request): views_dict = &#123;\"key\": \"value\"&#125; return render(request, 'hello.html', &#123;'views_dict': views_dict&#125;) 模板中以如下格式可引入变量： &lt;p> &lt;!-- import views_dict, print \"&#123;'key': 'value'&#125;\" --> &#123;&#123; views_dict &#125;&#125; &lt;/p> &lt;p> &lt;!-- import views_list['key'], i.e., 'value' --> &#123;&#123; views_list.key &#125;&#125; &lt;/p> 2.2 过滤器 过滤器官方说明： The Django template language | Django documentation | Django (djangoproject.com) 在模板中，引入变量时可以添加过滤器。过滤器可以在该变量被使用前修改它。可以将过滤器理解为一个函数，显示前会调用这个过滤器作用于这个变量。 使用过滤器的语法是： &#123;&#123; variable | filter:\"parameters\" &#125;&#125; 需要特别注意的是，这里的 | 字符左右可以有空格，而对于过滤器的可选参数必须用双引号引起，并且冒号 : 后不允许出现空格（会报错）。 如果是接触过 UNIX bash 语法的同学会注意到，其实这里使用到了一个管道字符，将变量作为输出通过管道传给过滤器，最终输出被过滤器作用后的输出结果。那么自然，过滤器可以套结，就像 UNIX 中管道可以套接一样： &#123;&#123; variable | filter1 | filter2 | ... &#125;&#125; 常见的过滤器有以下几种 Filter Function lower 将字符串转换为小写 upper 将字符串转换为大写 first 取第一个元素 date 根据给定格式对一个日期变量进行格式化 truncatewords/truncatechars 显示变量的前 \\(x\\) 个词或字符 default 如果传入变量的布尔值为 false ，则使用指定的默认值 length 返回字符串、列表和集合的长度，字典键值对的数量 filesizeformat 以易读的方式显示文件的大小，即 K, M, G 等 safe 将字符串标记为安全，不需要转义 3 流程控制 Django 模板中的流程控制语句也是与引入变量相同的格式。一般格式为： &#123;% expression %&#125; ... &#123;% end expression %&#125; 内部表达式的写法基本与 Python 语法相似，一些细节略有不同。下面分点逐个进行阐述。 3.1 if/else 标签 基本 if/else 条件句标签格式如下： &#123;% if condition %&#125; ... &#123;% endif %&#125; 含有 else ： &#123;% if condition %&#125; ... &#123;% else %&#125; ... &#123;% endif %&#125; 含有 else if ： &#123;% if condition1 %&#125; ... &#123;% elif condition2 %&#125; ... &#123;% elif ... %&#125; ... &#123;% else %&#125; ... &#123;% endif %&#125; 和 Python 完全相同的，条件标签支持与、或、非对条件进行修饰，即 and, or, not 。例如： &#123;% if num > 90 and num &lt;= 100 %&#125; 优秀 &#123;% elif num > 60 and num &lt;= 90 %&#125; 合格 &#123;% else %&#125; 一边玩去～ &#123;% endif %&#125; 需要注意的是，这里是不支持 Python 中的类似于 if 90 &lt; num &lt;= 100: ... 的并列不等式写法的。 3.2 for 标签 &#123;% for %&#125;` 允许我们在一个序列上迭代。 与 Python 的 for 语句的情形类似，循环语法是 `for X in Y` ，Y 是要迭代的序列而 X 是在每一个特定的循环中使用的变量名称。 每一次循环中，模板系统会渲染在 ``&#123;% for %&#125;`` 和 `&#123;% endfor %&#125;之间的所有内容。 for 循环句标签格式如下： &#123;% for X in Y %&#125; ... &#123;% endfor %&#125; 反向迭代的语法是在标签最后加一个 reversed 使得被迭代对象（一般是列表）被反向迭代，如： &#123;% for X in Y reversed %&#125; ... &#123;% endfor %&#125; 对于字典，可以调用字典的 .items 方法，可以对其解包而分别获得键和值。 &#123;% for i, j in views_dict.items %&#125; &#123;&#123; i &#125;&#125;---&#123;&#123; j &#125;&#125; &#123;% endfor %&#125; 在 &#123;% for %&#125; 标签里可以通过 &#123;&#123; forloop.function &#125;&#125; 变量获取循环序号： Function Description forloop.counter 顺序获取循环序号，从 1 开始计算 forloop.counter0 顺序获取循环序号，从 0 开始计算 forloop.revcounter 倒序获取循环序号，结尾序号为 1 forloop.revcounter0 倒序获取循环序号，结尾序号为 0 forloop.first ( with “if” ) 第一条数据返回 True，其他数据返回 False forloop.last ( with “if” ) 最后一条数据返回 True，其他数据返回 False empty 标签 循环中可使用 &#123;% empty %&#125; 从句，在循环为空的时候执行，即在退出循环时执行的语句： &#123;% for i in listvar %&#125; &#123;&#123; forloop.counter0 &#125;&#125; &#123;% empty %&#125; Empty~~ &#123;% endfor %&#125; 3.3 ifequal / ifnotequal 标签 &#123;% ifequal %&#125; 和 &#123;% ifnotequal %&#125; 标签用于比较两个值相等或不相等。与 &#123;% if %&#125; 类似，也可以支持 &#123;% else %&#125; 标签。 下面的例子比较两个模板变量 user 和 currentuser： &#123;% ifequal user currentuser %&#125; &lt;h1>Welcome&lt;/h1> &#123;% endifequal %&#125; 3.4 注释标签 Django 使用 # 进行注释。 &#123;# 一条注释 #&#125; 3.5 include 标签 &#123;% include %&#125; 标签允许在模板中包含其他模板的内容。 下面这个例子都包含了 nav.html 模板： &#123;% include \"nav.html\" %&#125; 3.6 csrf_token csrf_token 用于form表单中，作用是跨站请求伪造保护。 如果不用 &#123;% csrf_token %&#125; 标签，在用 form 表单时，要再次跳转页面会报403权限错误。 用了 &#123;% csrf_token %&#125; 标签，在 form 表单提交数据时，才会成功。 解析： 首先，向服务器发送请求，获取登录页面，此时中间件 csrf 会自动生成一个隐藏 input 标签，该标签里的 value 属性的值是一个随机的字符串，用户获取到登录页面的同时也获取到了这个隐藏的 input 标签。 然后，等用户需要用到 form 表单提交数据的时候，会携带这个 input 标签一起提交给中间件 csrf，原因是 form 表单提交数据时，会包括所有的 input 标签，中间件 csrf 接收到数据时，会判断，这个随机字符串是不是第一次它发给用户的那个，如果是，则数据提交成功，如果不是，则返回 403 权限错误。 4 自定义标签和过滤器 在应用目录下创建 templatetags 目录（与模板目录 templates 同级，且只能是这个目录名） 创建结束后的层级结构如下： HelloWorld/ |-- HelloWorld | |-- __init__.py | |-- __init__.pyc | |-- settings.py ... |-- manage.py `-- templatetags `-- templates 在 templatetags 目录下创建任意 Python 文件，如 my_tags.py ，其代码如下： from django import template register = template.Library() # register 的名字是固定的，不可改变 修改 settings.py 文件的 TEMPLATES 选项配置，添加 libraries 配置： ... TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR, \"/templates\",], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], \"libraries\":&#123; # 添加这边三行配置 'my_tags':'templatetags.my_tags' # 添加这边三行配置 &#125; # 添加这边三行配置 &#125;, &#125;, ] ... 之后便可以使用装饰器 @register.filter 自定义过滤器，@register.simple_tag 自定义标签。 在自定义过滤器和标签之前，要在 HTML 文件的 &lt;body&gt; 标签最上方导入该 Python 文件。格式为： &#123;% load my_tags %&#125; 4.1 自定义过滤器 过滤器的参数最多只能有两个，一个对应管道符号前的变量，另一个对应过滤器的可变参数。 @register.filter def my_filter(a, b): return a * b 使用自定义过滤器： &#123;&#123; 11 | my_filter:20 &#125;&#125; 4.2 自定义标签 @register.simple_tag def my_tag(a, b, c): return a * b * c 使用自定义标签 &#123;% my_tag 11 22 33 %&#125; 4.3 语义化标签 在该 Python 文件中导入 mark_safe . from django.utils.safestring import mark_safe 定义标签时，用上 mark_safe 方法，令标签语义化，相当于 jQuery 中的 html()方法。 和前端 HTML 文件中的过滤器 safe 效果一样。 @register.simple_tag def my_html(v1, v2): temp_html = \"&lt;input type='text' id='%s' class='%s' />\" %(v1, v2) return mark_safe(temp_html) 在 HTML 中使用该自定义标签，在页面中动态创建标签。 &#123;% my_html \"zzz\" \"xxx\" %&#125;","categories":[{"name":"学习杂文","slug":"学习杂文","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/"},{"name":"Django","slug":"学习杂文/Django","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://www.leolang.top/tags/Django/"},{"name":"Front End","slug":"Front-End","permalink":"https://www.leolang.top/tags/Front-End/"}]},{"title":"Django 教程（一）","slug":"Django教程（一）","date":"2022-03-19T16:00:00.000Z","updated":"2022-04-01T13:37:08.822Z","comments":true,"path":"2022/03/20/Django教程（一）/","link":"","permalink":"https://www.leolang.top/2022/03/20/Django%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"前言 从本文起将介绍有关 Python Web 开发框架 Django 的相关内容。本文介绍 Django 的整体架构和环境搭建。","text":"前言 从本文起将介绍有关 Python Web 开发框架 Django 的相关内容。本文介绍 Django 的整体架构和环境搭建。 Django 教程（一）初识 Django 0 Reference 0.1 Reference 本教程参考： 菜鸟教程 Django —— 传送门：Django 教程 | 菜鸟教程 (runoob.com) Django 官方文档 —— 传送门：Django documentation | Django documentation | Django (djangoproject.com) 1 Introduction and Installation 1.1 Introducion Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。 使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。 Python 加 Django 是快速开发、设计、部署网站的最佳组合。 1.1.1 MVC Model MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC 以一种插件式的、松耦合的方式连接在一起。 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 视图（V）- 图形界面，负责与用户的交互(页面)。 控制器（C）- 负责转发请求，对请求进行处理。 1.1.2 MTC Model Django 的 MTV 模式本质上和 MVC 是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django 的 MTV 分别是指： M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 T 表示模板 (Template)：负责如何把页面(html)展示给用户。 V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model 和 Template。 除了以上三层之外，还需要一个 URL 分发器，它的作用是将一个个 URL 的页面请求分发给不同的 View 处理，View 再调用相应的 Model 和 Template。 img img 1.2 Installation Django 下载地址：https://www.djangoproject.com/download/ 由于作者使用的是 Mac OS X 系统，本教程提供 Mac 下下载 Django 的方法。 通过官网下载 官网传送门：Download Django | Django (djangoproject.com) 下载 .tar.gz 包，通过 Terminal tar 命令解压： $ tar zxvf Django-3.x.y.tar.gz 通过 Github 下载 直接通过 Mac 的 Git 工具拉下来即可： $ git clone https:&#x2F;&#x2F;github.com&#x2F;django&#x2F;django.git 通过 conda 下载 一般来说，使用 conda 如果不在 base 下操作，会创建一个新环境，例如创建环境为 django ： $ conda create -n django python&#x3D;3.9 之后下载 Django 包 $ conda install django","categories":[{"name":"学习杂文","slug":"学习杂文","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/"},{"name":"Django","slug":"学习杂文/Django","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://www.leolang.top/tags/Django/"},{"name":"Front End","slug":"Front-End","permalink":"https://www.leolang.top/tags/Front-End/"}]},{"title":"LeetCode 1380","slug":"LeetCode 1380 矩阵中的幸运数","date":"2022-02-14T16:00:00.000Z","updated":"2022-02-28T07:23:22.343Z","comments":true,"path":"2022/02/15/LeetCode 1380 矩阵中的幸运数/","link":"","permalink":"https://www.leolang.top/2022/02/15/LeetCode%201380%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/","excerpt":"LeetCode 1380 矩阵中的幸运数","text":"LeetCode 1380 矩阵中的幸运数 Problem Link 1380. 矩阵中的幸运数 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 示例 1： 输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]] 输出：[15] 解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 2： 输入：matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]] 输出：[12] 解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 3： 输入：matrix &#x3D; [[7,8],[1,2]] 输出：[7] 提示： m == mat.length n == mat[i].length 1 &lt;= n, m &lt;= 50 1 &lt;= matrix[i][j] &lt;= 10^5 矩阵中的所有元素都是不同的 Solution 常数只有 \\(50\\) ，直接模拟即可，最大复杂度只能到 \\(O(n^3)=50^3=1.25\\times 10^5\\) ，可以接受。 Submit Code lang = C++ class Solution &#123; public: vector&lt;int> luckyNumbers (vector&lt;vector&lt;int>>&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); vector&lt;int> res; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; bool isMax = true, isMin = true; int val = matrix[i][j]; for (int k = 0; k &lt; m; k++) &#123; if (matrix[k][j] > val) isMax = false; &#125; for (int k = 0; k &lt; n; k++) &#123; if (matrix[i][k] &lt; val) isMin = false; &#125; if (isMax &amp;&amp; isMin) res.push_back(val); &#125; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def luckyNumbers (self, matrix: List[List[int]]) -> List[int]: m, n = len(matrix), len(matrix[0]) res = [] for i in range(m): for j in range(n): val = matrix[i][j] isMax, isMin = True, True for k in range(m): if matrix[k][j] > val: isMin = False for k in range(n): if matrix[i][k] &lt; val: isMax = False if isMax and isMin: res.append(val) return res lang = Java class Solution &#123; public List&lt;Integer> luckyNumbers (int[][] matrix) &#123; int m = matrix.length, n = matrix[0].length; List&lt;Integer> res = new ArrayList&lt;>(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int val = matrix[i][j]; boolean isMax = true, isMin = true; for (int k = 0; k &lt; m; k++) &#123; if (matrix[k][j] > val) &#123; isMax = false; &#125; &#125; for (int k = 0; k &lt; n; k++) &#123; if (matrix[i][k] &lt; val) &#123; isMin = false; &#125; &#125; if (isMin &amp;&amp; isMax) &#123; res.add(val); &#125; &#125; &#125; return res; &#125; &#125; Code Explanation None Reference None","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"Hash","slug":"Hash","permalink":"https://www.leolang.top/tags/Hash/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1601","slug":"LeetCode 1601 最多可达成的换楼请求数目","date":"2022-02-14T16:00:00.000Z","updated":"2022-04-06T08:08:32.244Z","comments":true,"path":"2022/02/15/LeetCode 1601 最多可达成的换楼请求数目/","link":"","permalink":"https://www.leolang.top/2022/02/15/LeetCode%201601%20%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE/","excerpt":"LeetCode 1601 最多可达成的换楼请求数目","text":"LeetCode 1601 最多可达成的换楼请求数目 Problem Link 1601. 最多可达成的换楼请求数目 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。 给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。 一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。 请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。 示例 1： img 输入：n &#x3D; 5, requests &#x3D; [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]] 输出：5 解释：请求列表如下： 从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。 从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。 从楼 2 离开的员工为 z ，且他想要搬到楼 0 。 从楼 3 离开的员工为 c ，且他想要搬到楼 4 。 没有员工从楼 4 离开。 我们可以让 x 和 b 交换他们的楼，以满足他们的请求。 我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。 所以最多可以满足 5 个请求。 示例 2： img 输入：n &#x3D; 3, requests &#x3D; [[0,0],[1,2],[2,1]] 输出：3 解释：请求列表如下： 从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。 从楼 1 离开的员工为 y ，且他想要搬到楼 2 。 从楼 2 离开的员工为 z ，且他想要搬到楼 1 。 我们可以满足所有的请求。 示例 3： 输入：n &#x3D; 4, requests &#x3D; [[0,3],[3,1],[1,2],[2,0]] 输出：4 提示： 1 &lt;= n &lt;= 20 1 &lt;= requests.length &lt;= 16 requests[i].length == 2 0 &lt;= fromi, toi &lt; n Solution 首先，是朴素的暴力枚举做法。 本题实质上是一个搜索问题，对于每一个请求，都有满足和不满足两种可能，那么这样也就形成了两种决策分支。搜索树的每一个节点表示的状态为每一个请求的选取状态，最终形成一个包含所有决策可能的决策树。 那么首先就可以想到深度优先搜索（DFS）。我们假定根节点为任何决策都不予满足，即没有发生换楼的初始状态。对于每一个请求，我们可以选取或不选取，若不选取，则直接进入该节点的子节点，即对下一个位置的请求作出是否满足的决策；若选取，则需要进行相应状态的更新。这也是 DFS 的基本思路。 那么下面分析需要哪些量进行维护而实现最终题目要求。题目要求每一栋楼的净变化为 \\(0\\) ，那么我们应该为每一栋楼维护一个变化值 \\(\\Delta\\) ，如果最终 \\(\\Delta=0\\) ，证明这栋楼变化量为 \\(0\\) 。如果最终的结果所有楼的 \\(\\Delta=0\\) ，那么证明符合要求，就可以更新答案。那么如何统计没有变化的楼的数量呢？当楼的数量变多时，显然每次都遍历一边整个 \\(\\Delta\\) 数组是不可能的，那么优化的方法就是动态维护一个记录 \\(\\Delta=0\\) 数量的变量，如果最后这个变量和楼的数量相等，那么证明该种决策方式成立。 最后，对于答案，只需要维护成立的决策方式中被满足的请求数量最大的即可。 接下来讨论如何优化上述算法。一般来说，对于枚举算法的优化是二进制压缩，即通过一掩码 \\(mask\\) 表示当前状态，如果当前位为 \\(1\\) ，表示满足当前情况。那么，本题就通过二进制压缩枚举情况，枚举 \\([0,2^m-1]\\) 区间内的所有整数作为每一种情况，对于每一种情况的处理思路等同于上面的处理思路。如果二进制枚举的情况从小到大数字中 \\(1\\) 的数目比当前答案大，并且当前情况符合题意，那么便更新答案。最终即可得到答案。 Submit Code Methods a lang = C++ class Solution &#123; private: vector&lt;int> delta; int n, zeros, cnt, ans; public: int maximumRequests(int n, vector&lt;vector&lt;int>>&amp; requests) &#123; this->n = n; delta.resize(n); zeros = n; cnt = ans = 0; dfs(requests, 0); return ans; &#125; void dfs(vector&lt;vector&lt;int>>&amp; requests, int pos) &#123; if (pos == requests.size()) &#123; if (zeros == n) &#123; ans = max(ans, cnt); &#125; return; &#125; dfs(requests, pos + 1); int backup = zeros; int a = requests[pos][0], b = requests[pos][1]; zeros -= delta[a] == 0; zeros -= delta[b] == 0; delta[a]--, delta[b]++, cnt++; zeros += delta[a] == 0; zeros += delta[b] == 0; dfs(requests, pos + 1); delta[a]++, delta[b]--, cnt--; zeros = backup; &#125; &#125;; lang = Python3 class Solution: def maximumRequests(self, n: int, requests: List[List[int]]) -> int: cnt, ans = 0, 0 delta = [0] * n zeros = n def dfs(pos): nonlocal cnt, ans, zeros if pos == len(requests): if zeros == n: ans = max(ans, cnt) return dfs(pos + 1) a, b = requests[pos] now = zeros zeros -= delta[a] == 0 zeros -= delta[b] == 0 delta[a] -= 1 delta[b] += 1 zeros += delta[a] == 0 zeros += delta[b] == 0 cnt += 1 dfs(pos + 1) cnt -= 1 delta[a] += 1 delta[b] -= 1 zeros = now dfs(0) return ans lang = Java class Solution &#123; private int cnt, ans, zeros; private int[] delta; private int n; public int maximumRequests(int n, int[][] requests) &#123; this.n = n; cnt = ans = 0; zeros = n; delta = new int[n]; dfs(requests, 0); return ans; &#125; public void dfs(int[][] requests, int pos) &#123; if (pos == requests.length) &#123; if (zeros == n) &#123; ans = Math.max(ans, cnt); &#125; return; &#125; dfs(requests, pos + 1); int backup = zeros; int a = requests[pos][0], b = requests[pos][1]; zeros -= delta[a] == 0 ? 1 : 0; zeros -= delta[b] == 0 ? 1 : 0; delta[a]--; delta[b]++; zeros += delta[a] == 0 ? 1 : 0; zeros += delta[b] == 0 ? 1 : 0; cnt++; dfs(requests, pos + 1); delta[a]++; delta[b]--; cnt--; zeros = backup; &#125; &#125; Methods b lang = C++ class Solution &#123; public: int maximumRequests(int n, vector&lt;vector&lt;int>>&amp; requests) &#123; int m = requests.size(); int ans = 0; vector&lt;int> delta(n); for (int mask = 0; mask &lt; (1 &lt;&lt; m); mask++) &#123; int cnt = __builtin_popcount(mask); if (cnt &lt;= ans) continue; fill(delta.begin(), delta.end(), 0); for (int i = 0; i &lt; m; i++) &#123; if (mask &amp; (1 &lt;&lt; i)) &#123; int a = requests[i][0], b = requests[i][1]; delta[a]--, delta[b]++; &#125; &#125; if (all_of(delta.begin(), delta.end(), [](int x) &#123; return x == 0; &#125;)) &#123; ans = cnt; &#125; &#125; return ans; &#125; &#125;; lang = Python3 class Solution: def maximumRequests(self, n: int, requests: List[List[int]]) -> int: m = len(requests) ans = 0 for mask in range(1 &lt;&lt; m): cnt = mask.bit_count() if cnt &lt;= ans: continue delta = [0] * n for i in range(m): if mask &amp; (1 &lt;&lt; i): delta[requests[i][0]] -= 1 delta[requests[i][1]] += 1 if all(x == 0 for x in delta): ans = cnt return ans lang = Java class Solution &#123; public int maximumRequests(int n, int[][] requests) &#123; int ans = 0; int m = requests.length; int[] delta = new int[n]; for (int mask = 0; mask &lt; (1 &lt;&lt; m); mask++) &#123; int cnt = Integer.bitCount(mask); if (cnt &lt;= ans) &#123; continue; &#125; Arrays.fill(delta, 0); for (int i = 0; i &lt; m; i++) &#123; if ((mask &amp; (1 &lt;&lt; i)) != 0) &#123; delta[requests[i][0]]--; delta[requests[i][1]]++; &#125; &#125; if (allZero(delta)) &#123; ans = cnt; &#125; &#125; return ans; &#125; private boolean allZero(int[] arr) &#123; for (int x : arr) &#123; if (x != 0) &#123; return false; &#125; &#125; return true; &#125; &#125; Code Explanation 对于统计数字二进制表示中 \\(1\\) 的个数的 API： C++ 采用 GCC 内建函数 __builtin_popcount() int x; cnt = __builtin_popcount(x); Python 采用 int 对象方法 int.bit_count() int x; cnt = x.bit_count(); Java 采用包裹类型 Integer 的方法 Integer.bitCount() int x; cnt &#x3D; Integer.bitCount(x); Reference LeetCode 官方题解 最多可达成的换楼请求数目 - 最多可达成的换楼请求数目 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"https://www.leolang.top/tags/DFS/"}]},{"title":"LeetCode 540","slug":"LeetCode 540 有序数组中的单一元素","date":"2022-02-13T16:00:00.000Z","updated":"2022-02-15T03:42:52.000Z","comments":true,"path":"2022/02/14/LeetCode 540 有序数组中的单一元素/","link":"","permalink":"https://www.leolang.top/2022/02/14/LeetCode%20540%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/","excerpt":"LeetCode 540 有序数组中的单一元素","text":"LeetCode 540 有序数组中的单一元素 Problem Link 540. 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。 请你找出并返回只出现一次的那个数。 你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。 示例 1: 输入: nums &#x3D; [1,1,2,3,3,4,4,8,8] 输出: 2 示例 2: 输入: nums &#x3D; [3,3,7,7,10,11,11] 输出: 10 提示: 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 105 Solution &amp; Submit Code 本题应有四种解法。 以下统一记序列为 \\(A\\) ，单一元素的下标为 \\(x\\) ，下标和元素表达含义相同，不予区分。 首先是最简单的两种较为暴力的做法。 Methods a. 异或法 首先需要弄清楚异或运算的定义： \\[ a\\oplus b= \\begin{cases} 1 &amp; a \\neq b\\\\ 0 &amp; a = b\\\\ \\end{cases} \\] 异或法处理序列中有单一元素，其他元素成对，且不要求序列有序的一种方法。由于成对元素的异或会产生 \\(0\\) ，那么遍历序列进行按位异或运算后，最终剩余的结果就是单一的那个元素。即对于序列 \\(A\\) ，其中单一元素为 \\(x\\) ，有 \\[ \\bigoplus_{i=1}^n A_i=x \\] Submit lang = C++ class Solution &#123; public: int singleNonDuplicate(vector&lt;int>&amp; nums) &#123; int res = 0; for (auto &amp;num : nums) &#123; res ^= num; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def singleNonDuplicate(self, nums: List[int]) -> int: res = 0; for num in nums: res ^= num return res lang = Java class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int res = 0; for (int num : nums) &#123; res ^= num; &#125; return res; &#125; &#125; Methods b. 有序数组等值连续 由于序列是有序数组，且除了单一元素外，每个元素都是成对的，那么相等的元素一定占据连续的两个位置。那么一个较为暴力的思路就出现了。从前向后以步进长为 \\(2\\) 进行遍历，对于被访问的元素 \\(A_i\\) ，如果 \\(i\\neq x\\) ，必有 \\(A_i=A_{i+1}\\) 成立，出现 \\(A_i\\neq A_{i+1}\\) 的 \\(A_i\\) 即为答案。 Submit lang = C++ class Solution &#123; public: int singleNonDuplicate(vector&lt;int>&amp; nums) &#123; if (nums.size() == 1) return nums[0]; for (int i = 0; i &lt; (int) nums.size() - 1; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.size() - 1]; &#125; &#125;; lang = Python3 class Solution: def singleNonDuplicate(self, nums: List[int]) -> int: if len(nums) == 1: return nums[0] for i in range(0, len(nums) - 1, 2): if nums[i] != nums[i + 1]: return nums[i] return nums[len(nums) - 1] lang = Java class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; if (nums.length == 1) return nums[0]; for (int i = 0; i &lt; nums.length - 1; i += 2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.length - 1]; &#125; &#125; 接下来是两种稍微复杂一点的二分的方法。 二分传送门 AcWing 基础算法（二） | W1ndness的技术栈 (leolang.top) 首先必须要说清楚为什么能用二分。 数组是有序的，这为二分提供了首要的条件。那么接下来我们要寻找二分的性质。由于只有一个元素的数量为 \\(1\\) ，其余元素数量都为 \\(2\\) ，那么数组的长度一定为奇数，并且 \\(x\\) 的左右都有偶数个元素。上个方法中提到了，数组中相同的元素一定是相邻的。那么观察数组可以知道，对于 \\(x\\) 左边的某一个元素 \\(u\\) ，如果 \\(u\\) 是偶数，那么一定有 \\(A_u=A_{u+1}\\) 成立；同样的，对于 \\(x\\) 右边的某一个元素 \\(v\\) ，如果 \\(v\\) 是奇数，一定有 \\(A_v=A_{v+1}\\) 成立。对于以上两条性质对调奇偶性同理。那么显然，\\(x\\) 就是某一元素与其右（或左，对调奇偶性）一元素相等的下标分解，即相同元素起点的下标奇偶性的边界。那么，这一性质就可以用作二分的性质，去寻找 \\(x\\) 。 那么接下来就产生了对于该性质指导的两种实现方法，分别是对于这一性质的两种诠释。 Methods c. 全数组的二分查找 这种方法将搜索域定为整个数组。在数组中，对于中点 \\(mid\\) ，其与 \\(x\\) 的关系决定了在其位置上的性质： 若 \\(mid&lt;x\\) ，那么有 \\[ A_{mid}= \\begin{cases} A_{mid+1} &amp; mid \\in \\mathrm{even}\\ \\mathbb Z\\\\ A_{mid-1} &amp; mid\\in \\mathrm{odd}\\ \\mathbb Z\\\\ \\end{cases} \\] 若 \\(mid \\ge x\\) ，那么有 \\[ A_{mid}\\neq \\begin{cases} A_{mid+1} &amp; mid \\in \\mathrm{even}\\ \\mathbb Z\\\\ A_{mid-1} &amp; mid\\in \\mathrm{odd}\\ \\mathbb Z\\\\ \\end{cases} \\] 那么，这就找到了 check() 需要检查的性质，只要按照奇偶性比较相邻元素就可以判断当前 \\(mid\\) 所在位置，并更新区间而找到答案了。 这里有一个技巧，不难发现，对于某一下标 \\(i\\) ，都是对于其左 \\(i-1\\) 或其右 \\(i+1\\) ，而且也与奇偶性有关，由于异或性质 \\[ mid\\oplus1= \\begin{cases} mid+1 &amp; mid\\in\\mathrm{even}\\ \\mathbb Z\\\\ mid-1 &amp; mid\\in\\mathrm{odd}\\ \\mathbb Z\\\\ \\end{cases} \\] 那么就可以下标的分支将其统一成 \\(mid\\oplus1\\) ，即 \\(A_{mid}\\) 与 \\(A_{mid\\oplus1}\\) 的比较了。 Submit lang = C++ class Solution &#123; public: int singleNonDuplicate(vector&lt;int>&amp; nums) &#123; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r >> 1; if (nums[mid] == nums[mid ^ 1]) &#123; l = mid + 1; &#125; else r = mid; &#125; return nums[l]; &#125; &#125;; lang = Python3 class Solution: def singleNonDuplicate(self, nums: List[int]) -> int: l, r = 0, len(nums) - 1 while l &lt; r: mid = l + r >> 1 if nums[mid] == nums[mid ^ 1]: l = mid + 1 else: r = mid return nums[l] lang = Java class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int mid = l + r >> 1; if (nums[mid] == nums[mid ^ 1]) &#123; l = mid + 1; &#125; else r = mid; &#125; return nums[l]; &#125; &#125; Methods d. 偶数下标的二分查找 另一种二分性质的诠释是只对于偶数下标的，这种方法在二分性质之上又向下想了一步。 我们可以发现，由于 \\(x\\) 的左边的元素有偶数个，那么 \\(x\\) 一定是偶数，那么我们为什么不只在偶数下标范围内去查找 \\(x\\) ？接下来就要想对于偶数下标的所有元素， \\(mid\\) 和 $x $ 的位置关系到底表示了什么。对于整个数组而言，由于 \\(x\\) 分界了相同元素开始下标的奇偶性，那么，对于所有偶数下标元素，设其为 \\(t\\) ，有以下条件成立 \\[ \\begin{cases} A_t=A_{t+1} &amp; t&lt;x\\\\ A_t\\neq A_{t+1} &amp; t\\ge x\\\\ \\end{cases}\\quad(t\\in\\mathrm{even}\\ \\mathbb Z) \\] 那么这样就找到了位置关系的含义，也就有了更新区间的 check() 依据。 Submit lang = C++ class Solution &#123; public: int singleNonDuplicate(vector&lt;int>&amp; nums) &#123; int l = 0, r = nums.size() - 1; while (l &lt; r) &#123; int mid = l + r >> 1; mid -= mid &amp; 1; if (nums[mid] == nums[mid + 1]) &#123; l = mid + 2; &#125; else r = mid; &#125; return nums[l]; &#125; &#125;; lang = Python3 class Solution: def singleNonDuplicate(self, nums: List[int]) -> int: l, r = 0, len(nums) - 1 while l &lt; r: mid = l + r >> 1 mid -= mid &amp; 1 if nums[mid] == nums[mid + 1]: l = mid + 2 else: r = mid return nums[l] lang = Java class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int l = 0, r = nums.length - 1; while (l &lt; r) &#123; int mid = l + r >> 1; mid -= mid &amp; 1; if (nums[mid] == nums[mid + 1]) &#123; l = mid + 2; &#125; else r = mid; &#125; return nums[l]; &#125; &#125; Code Explanation None Reference LeetCode 官方题解 有序数组中的单一元素 - 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com) 宫水三叶题解 【宫水三叶】二段性分析运用题 - 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"Hash","slug":"Hash","permalink":"https://www.leolang.top/tags/Hash/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1189","slug":"LeetCode 1189 “气球” 的最大数量","date":"2022-02-12T16:00:00.000Z","updated":"2022-02-15T03:38:12.000Z","comments":true,"path":"2022/02/13/LeetCode 1189 “气球” 的最大数量/","link":"","permalink":"https://www.leolang.top/2022/02/13/LeetCode%201189%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/","excerpt":"LeetCode 1189 “气球” 的最大数量","text":"LeetCode 1189 “气球” 的最大数量 Problem Link 1189. “气球” 的最大数量 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 \"balloon\"（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 \"balloon\"。 示例 1： 输入：text &#x3D; &quot;nlaebolko&quot; 输出：1 示例 2： 输入：text &#x3D; &quot;loonbalxballpoon&quot; 输出：2 示例 3： 输入：text &#x3D; &quot;leetcode&quot; 输出：0 提示： 1 &lt;= text.length &lt;= 10^4 text 全部由小写英文字母组成 Solution 直接模拟。统计所有字符出现的频度，由于单词 \"balloon\" 中 l 和 o 都出现两次，要将其频度都除以二。那么最后能够构成单词的最大数量为 b, a, l, o, n 的频度最小值。 需要注意的是，使用的哈希表要只统计这五个字母的频度，否则实现语言不同，如果哈希表内不存在键，返回值和导致的后果都可能不同。 Submit Code lang = C++ class Solution &#123; public: int maxNumberOfBalloons(string text) &#123; unordered_map&lt;char, int> cnt; for (auto &amp;ch : text) cnt[ch]++; cnt['l'] /= 2; cnt['o'] /= 2; return std::min(&#123;cnt['b'], cnt['a'], cnt['l'], cnt['o'], cnt['n']&#125;); &#125; &#125;; Or write as: class Solution &#123; public: int maxNumberOfBalloons(string text) &#123; vector&lt;int> cnt(5); unordered_map&lt;char, int> ord&#123;&#123;'b', 0&#125;, &#123;'a', 1&#125;, &#123;'l', 2&#125;, &#123;'o', 3&#125;, &#123;'n', 4&#125;&#125;; for (auto &amp;ch : text) &#123; if (ord.count(ch)) &#123; cnt[ord[ch]]++; &#125; &#125; cnt[ord['l']] /= 2; cnt[ord['o']] /= 2; return *min_element(cnt.begin(), cnt.end()); &#125; &#125;; lang = Python3 class Solution: def maxNumberOfBalloons(self, text: str) -> int: cnt = Counter(ch for ch in text if ch in \"balon\") cnt['l'] //= 2 cnt['o'] //= 2 return min(cnt.values()) if len(cnt) == 5 else 0 lang = Java class Solution &#123; public int maxNumberOfBalloons(String text) &#123; int[] cnt = new int[5]; Map&lt;Character, Integer> ord = new HashMap&lt;>(); ord.put('b', 0); ord.put('a', 1); ord.put('l', 2); ord.put('o', 3); ord.put('n', 4); for (int i = 0; i &lt; text.length(); i++) &#123; if (ord.containsKey(text.charAt(i))) &#123; cnt[ord.get(text.charAt(i))]++; &#125; &#125; cnt[ord.get('l')] /= 2; cnt[ord.get('o')] /= 2; return Arrays.stream(cnt).min().getAsInt(); &#125; &#125; Code Explanation lang = Java Arrays.stream() Stream 流和 Lambda 表达式都是 Java8 的新特性。 14-Stream+Lambda_头秃人菜的博客-CSDN博客 Stream 是 Java8 中处理数组、集合的抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。 本题中通过 Arrays.stream(cnt).min().getAsInt(); 将数组转换为流，通过 Stream.min() 获取到流中的最小值，之后通过 Stream.getAsInt() 将流转换为整型。 Reference LeetCode 官方题解 “气球” 的最大数量 - “气球” 的最大数量 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"Hash","slug":"Hash","permalink":"https://www.leolang.top/tags/Hash/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1020","slug":"LeetCode 1020 飞地的数量","date":"2022-02-11T16:00:00.000Z","updated":"2022-02-13T12:16:26.000Z","comments":true,"path":"2022/02/12/LeetCode 1020 飞地的数量/","link":"","permalink":"https://www.leolang.top/2022/02/12/LeetCode%201020%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"LeetCode 1020 飞地的数量","text":"LeetCode 1020 飞地的数量 Problem Link 1020. 飞地的数量 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。 一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。 返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。 示例 1： img 输入：grid &#x3D; [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。 示例 2： img 输入：grid &#x3D; [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] 输出：0 解释：所有 1 都在边界上或可以到达边界。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 500 grid[i][j] 的值为 0 或 1 Solution 本题应有两种解法，一种是图论基本的想法：DFS 和 BFS，另一种参阅官方题解，应用并查集。 首先是 DFS 和 BFS 解法。 本题和 LeetCode 上几道经典的 DFS、BFS 题想法很相似。 传送门： 733. 图像渲染 - 力扣（LeetCode） (leetcode-cn.com) 695. 岛屿的最大面积 - 力扣（LeetCode） (leetcode-cn.com) 由题中 上、下、左、右 移动基本就能够想到应用 DFS 或 BFS 进行解题。那么思路就很清晰了。 遍历的基本思路是，从矩阵的边界各单元格遍历矩阵中所有和网格边界相连的陆地单元格，最后遍历整个矩阵，统计没有被访问的单元格，即为答案。由于边界不可能出现符合答案要求的单元格，那么最后的统计遍历可以不用遍历边界单元格，只遍历内层单元格即可。 之后是并查集解法。 并查集解法的思想是首先将每一个陆地单元格都看做一个单独的集合，之后，对矩阵进行遍历，将所有的相连的陆地连接成一个连通分量，即并入同一集合中。最后遍历整个矩阵，如果当前单元格不是和边界单元格处于同一连通分量中，那么这个单元格就是符合答案要求的单元格。 对于合并陆地单元格，一种实现方法是 DFS/BFS + 并查集 的做法，但是和上面第一种做法未免重复且更为复杂，实现思路其实就是将遍历过程中记录是否访问的数组改为了并查集进行记录，如果当前单元格已经属于了某一个集合就证明已经被访问过，便可以跳过当前单元格，这里就不再过多赘述了。可以参考【宫水三叶】的题解的第一种做法。 参考官方题解，只使用并查集的实现方法是，遍历矩阵所有单元格，对于每一个陆地单元格而言，记其坐标为 \\((x,y)\\) ，只需向右和向下判断是否是陆地单元格，即坐标 \\((x+1,y),(x,y+1)\\) ，并进行合并操作。容易证明通过这种方式能够完成整个矩阵的合并工作，因为我们一般从左上向右下遍历矩阵，那么一定能够通过这种方式不断地通过迭代，将所有的陆地合并到一起。 并查集传送门 AcWing 数据结构（五） | W1ndness的技术栈 (leolang.top) Submit Code Methods a. DFS lang = C++ class Solution &#123; private: int m, n; vector&lt;vector&lt;bool>> vis; vector&lt;vector&lt;int>> dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; public: int numEnclaves(vector&lt;vector&lt;int>>&amp; grid) &#123; this->m = grid.size(), this->n = grid[0].size(); this->vis = vector&lt;vector&lt;bool>>(m, vector&lt;bool>(n, false)); for (int i = 0; i &lt; n; i++) &#123; dfs(grid, 0, i); dfs(grid, m - 1, i); &#125; for (int i = 1; i &lt; m - 1; i++) &#123; dfs(grid, i, 0); dfs(grid, i, n - 1); &#125; int res = 0; for (int i = 1; i &lt; m - 1; i++) &#123; for (int j = 1; j &lt; n - 1; j++) &#123; if (grid[i][j] &amp;&amp; !vis[i][j]) res++; &#125; &#125; return res; &#125; void dfs(vector&lt;vector&lt;int>>&amp; grid, int x, int y) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) return; if (vis[x][y] || !grid[x][y]) return; vis[x][y] = true; for (auto &amp;dir : dirs) &#123; dfs(grid, x + dir[0], y + dir[1]); &#125; &#125; &#125;; lang = Python3 class Solution: def numEnclaves(self, grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) vis = [[False] * n for _ in range(m)] dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]] def dfs(x, y): if x &lt; 0 or x >= m or y &lt; 0 or y >= n: return if vis[x][y] or not grid[x][y]: return vis[x][y] = True for d in dirs: dfs(x + d[0], y + d[1]) for i in range(m): dfs(i, 0) dfs(i, n - 1) for j in range(1, n - 1): dfs(0, j) dfs(m - 1, j) return sum(grid[i][j] and not vis[i][j] for i in range(1, m - 1) for j in range(1, n - 1)) lang = Java class Solution &#123; private int m, n; private int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean[][] vis; private int[][] grid; public int numEnclaves(int[][] grid) &#123; this.grid = grid; this.m = grid.length; this.n = grid[0].length; this.vis = new boolean[m][n]; for (int i = 0; i &lt; m; i++) &#123; dfs(i, 0); dfs(i, n - 1); &#125; for (int i = 1; i &lt; n - 1; i++) &#123; dfs(0, i); dfs(m - 1, i); &#125; int res = 0; for (int i = 1; i &lt; m - 1; i++) &#123; for (int j = 1; j &lt; n - 1; j++) &#123; if (!vis[i][j] &amp;&amp; grid[i][j] == 1) &#123; res++; &#125; &#125; &#125; return res; &#125; private void dfs(int x, int y) &#123; if (x &lt; 0 || x >= m || y &lt; 0 || y >= n) &#123; return; &#125; if (vis[x][y] || grid[x][y] == 0) &#123; return; &#125; vis[x][y] = true; for (int[] dir : dirs) &#123; dfs(x + dir[0], y + dir[1]); &#125; &#125; &#125; Methods b. BFS lang = C++ class Solution &#123; private: int m, n; vector&lt;vector&lt;bool>> vis; vector&lt;vector&lt;int>> dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; public: int numEnclaves(vector&lt;vector&lt;int>>&amp; grid) &#123; this->m = grid.size(), this->n = grid[0].size(); this->vis = vector&lt;vector&lt;bool>>(m, vector&lt;bool>(n, false)); queue&lt;pair&lt;int, int>> q; for (int i = 0; i &lt; m; i++) &#123; if (grid[i][0]) &#123; vis[i][0] = true; q.emplace(i, 0); &#125; if (grid[i][n - 1]) &#123; vis[i][n - 1] = true; q.emplace(i, n - 1); &#125; &#125; for (int i = 1; i &lt; n - 1; i++) &#123; if (grid[0][i]) &#123; vis[0][i] = true; q.emplace(0, i); &#125; if (grid[m - 1][i]) &#123; vis[m - 1][i] = true; q.emplace(m - 1, i); &#125; &#125; while (!q.empty()) &#123; auto [row, col] = q.front(); q.pop(); for (auto &amp;dir : dirs) &#123; int x = row + dir[0], y = col + dir[1]; if (x >= 0 &amp;&amp; x &lt; m &amp;&amp; y >= 0 &amp;&amp; y &lt; n) &#123; if (!vis[x][y] &amp;&amp; grid[x][y]) &#123; vis[x][y] = true; q.emplace(x, y); &#125; &#125; &#125; &#125; int res = 0; for (int i = 1; i &lt; m - 1; i++) &#123; for (int j = 1; j &lt; n - 1; j++) &#123; if (!vis[i][j] &amp;&amp; grid[i][j]) res++; &#125; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def numEnclaves(self, grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) vis = [[False] * n for _ in range(m)] dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]] q = deque() for i in range(m): if grid[i][0]: vis[i][0] = True q.append((i, 0)) if grid[i][n - 1]: vis[i][n - 1] = True q.append((i, n - 1)) for j in range(1, n - 1): if grid[0][j]: vis[0][j] = True q.append((0, j)) if grid[m - 1][j]: vis[m - 1][j] = True q.append((m - 1, j)) while q: row, col = q.popleft() for d in dirs: x = row + d[0]; y = col + d[1] if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n: if grid[x][y] and not vis[x][y]: vis[x][y] = True q.append((x, y)) return sum(grid[i][j] and not vis[i][j] for i in range(1, m - 1) for j in range(1, n - 1)) lang = Java class Solution &#123; private int m, n; private int[][] dirs = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; private boolean[][] vis; public int numEnclaves(int[][] grid) &#123; this.m = grid.length; this.n = grid[0].length; this.vis = new boolean[m][n]; Queue&lt;int[]> q = new ArrayDeque&lt;>(); for (int i = 0; i &lt; m; i++) &#123; if (grid[i][0] == 1) &#123; vis[i][0] = true; q.offer(new int[]&#123;i, 0&#125;); &#125; if (grid[i][n - 1] == 1) &#123; vis[i][n - 1] = true; q.offer(new int[]&#123;i, n - 1&#125;); &#125; &#125; for (int i = 1; i &lt; n - 1; i++) &#123; if (grid[0][i] == 1) &#123; vis[0][i] = true; q.offer(new int[]&#123;0, i&#125;); &#125; if (grid[m - 1][i] == 1) &#123; vis[0][i] = true; q.offer(new int[]&#123;m - 1, i&#125;); &#125; &#125; while (!q.isEmpty()) &#123; int[] cur = q.poll(); int row = cur[0], col = cur[1]; for (int[] dir : dirs) &#123; int x = row + dir[0], y = col + dir[1]; if (x >= 0 &amp;&amp; x &lt; m &amp;&amp; y >= 0 &amp;&amp; y &lt; n) &#123; if (!vis[x][y] &amp;&amp; grid[x][y] == 1) &#123; vis[x][y] = true; q.offer(new int[]&#123;x, y&#125;); &#125; &#125; &#125; &#125; int res = 0; for (int i = 1; i &lt; m - 1; i++) &#123; for (int j = 1; j &lt; n - 1; j++) &#123; if (!vis[i][j] &amp;&amp; grid[i][j] == 1) &#123; res++; &#125; &#125; &#125; return res; &#125; &#125; Methods c. Union Find Set lang = C++ class UnionFind &#123; private: int m, n; vector&lt;int> p; vector&lt;bool> onEdge; public: UnionFind(vector&lt;vector&lt;int>>&amp; grid) &#123; this->m = grid.size(), this->n = grid[0].size(); this->p = vector&lt;int>(m * n); this->onEdge = vector&lt;bool>(m * n, false); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j]) &#123; int idx = i * n + j; p[idx] = idx; if (i + 1 == m || j + 1 == n || i == 0 || j == 0) &#123; onEdge[idx] = true; &#125; &#125; &#125; &#125; &#125; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; void uni(int a, int b) &#123; int ra = find(a), rb = find(b); p[ra] = rb; onEdge[rb] = onEdge[ra] | onEdge[rb]; &#125; bool isOnEdge(int idx) &#123; return onEdge[find(idx)]; &#125; &#125;; class Solution &#123; public: int numEnclaves(vector&lt;vector&lt;int>>&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); UnionFind uf(grid); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j]) &#123; int idx = i * n + j; if (i &lt; m - 1 &amp;&amp; grid[i + 1][j]) &#123; uf.uni(idx, idx + n); &#125; if (j &lt; n - 1 &amp;&amp; grid[i][j + 1]) &#123; uf.uni(idx, idx + 1); &#125; &#125; &#125; &#125; int res = 0; for (int i = 1; i &lt; m - 1; i++) &#123; for (int j = 1; j &lt; n - 1; j++) &#123; if (grid[i][j] &amp;&amp; !uf.isOnEdge(i * n + j)) &#123; res++; &#125; &#125; &#125; return res; &#125; &#125;; lang = Python3 class UnionFind: def __init__(self, grid): m, n = len(grid), len(grid[0]) self.p = [i for i in range(m * n)] self.onEdge = [False] * (m * n) for i in range(m): for j in range(n): if grid[i][j]: idx = i * n + j if i == 0 or i == m - 1 or j == 0 or j == n - 1: self.onEdge[idx] = True def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, a, b): ra = self.find(a); rb = self.find(b) self.p[ra] = rb self.onEdge[rb] |= self.onEdge[ra] def isOnEdge(self, idx): return self.onEdge[self.find(idx)] class Solution: def numEnclaves(self, grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) uf = UnionFind(grid) for i in range(m): for j in range(n): if grid[i][j]: idx = i * n + j if i &lt; m - 1 and grid[i + 1][j]: uf.union(idx, idx + n) if j &lt; n - 1 and grid[i][j + 1]: uf.union(idx, idx + 1) return sum(grid[i][j] and not uf.isOnEdge(i * n + j) for i in range(1, m - 1) for j in range(1, n - 1)) lang = Java class UnionFind &#123; private int m, n; private int[] p; private boolean[] onEdge; public UnionFind(int[][] grid) &#123; this.m = grid.length; this.n = grid[0].length; p = new int[m * n]; onEdge = new boolean[m * n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; int idx = i * n + j; p[idx] = idx; if (i == 0 || i == m - 1 || j == 0 || j == n - 1) &#123; onEdge[idx] = true; &#125; &#125; &#125; &#125; &#125; public int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; public void union(int a, int b) &#123; int ra = find(a), rb = find(b); p[ra] = rb; onEdge[rb] |= onEdge[ra]; &#125; public boolean isOnEdge(int idx) &#123; return onEdge[find(idx)]; &#125; &#125; class Solution &#123; public int numEnclaves(int[][] grid) &#123; int m = grid.length, n = grid[0].length; UnionFind uf = new UnionFind(grid); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (grid[i][j] == 1) &#123; int idx = i * n + j; if (i &lt; m - 1 &amp;&amp; grid[i + 1][j] == 1) &#123; uf.union(idx, idx + n); &#125; if (j &lt; n - 1 &amp;&amp; grid[i][j + 1] == 1) &#123; uf.union(idx, idx + 1); &#125; &#125; &#125; &#125; int res = 0; for (int i = 1; i &lt; m - 1; i++) &#123; for (int j = 1; j &lt; n - 1; j++) &#123; if (grid[i][j] == 1 &amp;&amp; !uf.isOnEdge(i * n + j)) &#123; res++; &#125; &#125; &#125; return res; &#125; &#125; Code Explanation lang = Java ArrayDeque 类 ArrayDeque 类本质是一个双端队列，类似于 C++ STL deque 和 Python collections.deque ArrayDeque类的使用详解_skh2015java的博客-CSDN博客 ArrayDeque 提供几对方法，用于实现队列操作和栈操作，本题中使用的方法为 ArrayDeque.offer() 与 ArrayDeque.poll() 。 Reference LeetCode 官方题解 飞地的数量 - 飞地的数量 - 力扣（LeetCode） (leetcode-cn.com) 宫水三叶题解 【宫水三叶】一题双解 :「并查集 + DFS」&amp;「多源 BFS」 - 飞地的数量 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1447","slug":"LeetCode 1447 最简分数","date":"2022-02-09T16:00:00.000Z","updated":"2022-02-13T12:17:00.000Z","comments":true,"path":"2022/02/10/LeetCode 1447 最简分数/","link":"","permalink":"https://www.leolang.top/2022/02/10/LeetCode%201447%20%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/","excerpt":"LeetCode 1447 最简分数","text":"LeetCode 1447 最简分数 Problem Link 1447. 最简分数 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 n 的 最简 分数 。分数可以以 任意 顺序返回。 示例 1： 输入：n &#x3D; 2 输出：[&quot;1&#x2F;2&quot;] 解释：&quot;1&#x2F;2&quot; 是唯一一个分母小于等于 2 的最简分数。 示例 2： 输入：n &#x3D; 3 输出：[&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;,&quot;2&#x2F;3&quot;] 示例 3： 输入：n &#x3D; 4 输出：[&quot;1&#x2F;2&quot;,&quot;1&#x2F;3&quot;,&quot;1&#x2F;4&quot;,&quot;2&#x2F;3&quot;,&quot;3&#x2F;4&quot;] 解释：&quot;2&#x2F;4&quot; 不是最简分数，因为它可以化简为 &quot;1&#x2F;2&quot; 。 示例 4： 输入：n &#x3D; 1 输出：[] 提示： 1 &lt;= n &lt;= 100 Solution 首先，需要弄清楚最简分数的定义。 最简分数定义如下： 设一分数形式为 \\(a/b\\) ，如果 \\(a,b\\) 两数互质，即满足两数的最大公倍数 \\((a,b)=1\\) ，那么该分数为最简分数。 那么，按照题意，我们要寻找的就是形式为 \\[ 0&lt;a/b&lt;1 \\] 的分数，并有约束 \\[ \\left\\{ \\begin{array}{l} b\\in[2,n]\\\\ a\\in[1,b]\\\\ a&lt;b\\\\ a,b\\in\\mathbb Z \\end{array}\\right. \\] 那么，使用两重循环以 \\(O(n^2)\\) 的复杂度即可完成。 最大公因数的求法 AcWing 数学知识（一） | W1ndness的技术栈 (leolang.top) Submit Code lang = C++ class Solution &#123; public: vector&lt;string> simplifiedFractions(int n) &#123; vector&lt;string> res; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; if (__gcd(i, j) == 1) &#123; res.emplace_back(to_string(j) + \"/\" + to_string(i)); &#125; &#125; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def simplifiedFractions(self, n: int) -> List[str]: res = [] for i in range(2, n + 1): for j in range(1, i): if math.gcd(i, j) == 1: res.append(f\"&#123;j&#125;/&#123;i&#125;\") return res Another way to write it is class Solution: def simplifiedFractions(self, n: int) -> List[str]: return [f\"&#123;i&#125;/&#123;j&#125;\" for j in range(2, n + 1) for i in range(1, j) if math.gcd(i, j) == 1] lang = Java class Solution &#123; public List&lt;String> simplifiedFractions(int n) &#123; List&lt;String> res = new ArrayList&lt;>(); for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; if (gcd(i, j) == 1) &#123; res.add(j + \"/\" + i); &#125; &#125; &#125; return res; &#125; private int gcd(int a, int b) &#123; return b != 0 ? gcd(b, a % b) : a; &#125; &#125; Code Explanation lang = C++ __gcd() 函数 std::gcd | C++ inbuilt function for finding GCD - GeeksforGeeks C++14 的语法： #include &lt;iostream> #include &lt;algorithm> // __gcd(m, n) in Library 'algorithm' using namespace std; int main() &#123; cout &lt;&lt; __gcd(6, 20) &lt;&lt; endl; &#125; C++17 的语法： #include &lt;iostream> #include &lt;numeric> // gcd(m, n) in Library 'numeric' using namespace std; int main() &#123; cout &lt;&lt; gcd(6, 20) &lt;&lt; endl; &#125; Reference LeetCode 官方题解 最简分数 - 最简分数 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1984","slug":"LeetCode 1984 学生分数的最小差值","date":"2022-02-08T16:00:00.000Z","updated":"2022-02-13T12:15:56.000Z","comments":true,"path":"2022/02/09/LeetCode 1984 学生分数的最小差值/","link":"","permalink":"https://www.leolang.top/2022/02/09/LeetCode%201984%20%E5%AD%A6%E7%94%9F%E5%88%86%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/","excerpt":"LeetCode 1984 学生分数的最小差值","text":"LeetCode 1984 学生分数的最小差值 Problem Link 1984. 学生分数的最小差值 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。 返回可能的 最小差值 。 示例 1： 输入：nums &#x3D; [90], k &#x3D; 1 输出：0 解释：选出 1 名学生的分数，仅有 1 种方法： - [90] 最高分和最低分之间的差值是 90 - 90 &#x3D; 0 可能的最小差值是 0 示例 2： 输入：nums &#x3D; [9,4,1,7], k &#x3D; 2 输出：2 解释：选出 2 名学生的分数，有 6 种方法： - [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 &#x3D; 5 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 &#x3D; 8 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 &#x3D; 2 - [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 &#x3D; 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 &#x3D; 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 &#x3D; 6 可能的最小差值是 2 提示： 1 &lt;= k &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 105 Solution 本题使用排序加滑动窗口的方式进行解题。 滑动窗口传送门 AcWing 数据结构（二） | W1ndness的技术栈 (leolang.top) 首先，要使得最小化最高分和最低分的差值，可以证明，我们必须在排好序之后的序列中选取连续的一段 \\(k\\) 个数字。反之，假设 \\(k\\) 个数字并非连续的一段。如果跳过了中间的某数字，记当前状态下（跳过某数字）的最大值为 \\(u\\) ，最小值为 \\(v\\) ，那么替换该数字进入序列，调整为连续的一段数字后，被替换出 \\(k\\) 个数字的一定是 \\(u,v\\) 其中之一，那么必定有 \\(u&#39;&lt;u\\) 或 \\(v&#39;&gt;v\\) 的情况出现，其中 \\(u&#39;,v&#39;\\) 是新的最大值和最小值，那么一定有 \\(u-v&gt;u&#39;-v&#39;\\) 成立，即差值会变得更小，与假设矛盾。命题得证。 那么，在有序序列中进行固定数量的取值，就可以应用滑动窗口，固定窗口的大小为 \\(k\\) ，滑动窗口，最终取得最小的差值。本题结束。 Submit Code lang = C++ class Solution &#123; public: int minimumDifference(vector&lt;int>&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int res = INT_MAX; for (int i = 0; i + k - 1 &lt; (int) nums.size(); i++) &#123; res = min(res, nums[i + k - 1] - nums[i]); &#125; return res; &#125; &#125;; lang = Python3 class Solution: def minimumDifference(self, nums: List[int], k: int) -> int: nums.sort() return min(nums[i + k - 1] - nums[i] for i in range(len(nums) - k + 1)) lang = Java class Solution &#123; public int minimumDifference(int[] nums, int k) &#123; Arrays.sort(nums); int res = Integer.MAX_VALUE; for (int i = 0; i + k - 1 &lt; nums.length; i++) &#123; res = Math.min(res, nums[i + k - 1] - nums[i]); &#125; return res; &#125; &#125; Code Explanation None Reference LeetCode 官方题解 学生分数的最小差值 - 学生分数的最小差值 - 力扣（LeetCode） (leetcode-cn.com) 宫水三叶题解 【宫水三叶】排序 + 滑动窗口运用题 - 学生分数的最小差值 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 2006","slug":"LeetCode 2006 差的绝对值为 K 的数对数目","date":"2022-02-08T16:00:00.000Z","updated":"2022-02-09T12:55:04.000Z","comments":true,"path":"2022/02/09/LeetCode 2006 差的绝对值为 K 的数对数目/","link":"","permalink":"https://www.leolang.top/2022/02/09/LeetCode%202006%20%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%BA%20K%20%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE/","excerpt":"LeetCode 2006 差的绝对值为 K 的数对数目","text":"LeetCode 2006 差的绝对值为 K 的数对数目 Problem Link 2006. 差的绝对值为 K 的数对数目 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i &lt; j 且 |nums[i] - nums[j]| == k 。 |x| 的值定义为： 如果 x &gt;= 0 ，那么值为 x 。 如果 x &lt; 0 ，那么值为 -x 。 示例 1： 输入：nums &#x3D; [1,2,2,1], k &#x3D; 1 输出：4 解释：差的绝对值为 1 的数对为： - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] 示例 2： 输入：nums &#x3D; [1,3], k &#x3D; 3 输出：0 解释：没有任何数对差的绝对值为 3 。 示例 3： 输入：nums &#x3D; [3,2,1,5,4], k &#x3D; 2 输出：3 解释：差的绝对值为 2 的数对为： - [3,2,1,5,4] - [3,2,1,5,4] - [3,2,1,5,4] 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 99 Solution 本题共有两种方法： 朴素暴力解法，双循环 哈希表 + 一次遍历 暴力解法 由于常数为 \\(200\\) ，二重循环复杂度最大为 \\(O(n^2)\\) 但 \\(&lt;40000\\) ，可以承受。 哈希表一次遍历 对暴力解法进行改进，进行剪枝。那么，就应该统计各数字的数量，以避免重复计算。 对于整数 \\(x\\) ，记其到目前为止出现次数为 \\(T(x)\\) 。那么对于整数 \\(n\\) ，满足条件的数对数量为 \\(T(n-k)+T(n+k)\\) 。 需要注意的是，这里需要边统计次数边更新答案，而不是现统计次数，再更新答案。采用后者解答会导致在出现次数为 \\(1\\) 的整数上出现重解的情况。 对于前者做法的解释是： 在二重循环中，设我们寻找的一重循环位置为 \\(i\\) ，那么，为了避免重复，我们需要将二重循环设定为从其下一位开始，即设定 \\(j=i+1\\) 。同样的，我们在使用一重循环统计时，由于循环的是原数组，且一般为从前向后循环，那么我们在遍历过程中应该知道在该位置之前满足 \\(|nums[i]-nums[j]|=k\\) 的个数，即要知道遍历过的整数的出现次数。如果出现相同元素，也不影响统计。 Submit Code Methods a lang = C++ class Solution &#123; public: int countKDifference(vector&lt;int>&amp; nums, int k) &#123; int res = 0; for (int i = 0; i &lt; (int) nums.size(); i++) &#123; for (int j = i + 1; j &lt; (int) nums.size(); j++) &#123; int a = nums[i], b = nums[j]; if (abs(a - b) == k) res++; &#125; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def countKDifference(self, nums: List[int], k: int) -> int: res = 0 n = len(nums) for i in range(n): for j in range(i + 1, n): if abs(nums[i] - nums[j]) == k: res += 1 return res lang = Java class Solution &#123; public int countKDifference(int[] nums, int k) &#123; int n = nums.length; int res = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (Math.abs(nums[i] - nums[j]) == k) res++; &#125; &#125; return res; &#125; &#125; Methods b lang = C++ class Solution &#123; public: int countKDifference(vector&lt;int>&amp; nums, int k) &#123; unordered_map&lt;int, int> cnt; int res = 0; for (auto &amp;num : nums) &#123; res += cnt[num - k] + cnt[num + k]; cnt[num]++; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def countKDifference(self, nums: List[int], k: int) -> int: cnt = Counter() res = 0 for num in nums: res += cnt[num - k] + cnt[num + k] cnt[num] += 1 return res lang = Java class Solution &#123; public int countKDifference(int[] nums, int k) &#123; Map&lt;Integer, Integer> cnt = new HashMap&lt;>(); int res = 0; for (int num : nums) &#123; res += cnt.getOrDefault(num - k, 0) + cnt.getOrDefault(num + k, 0); cnt.put(num, cnt.getOrDefault(num, 0) + 1); &#125; return res; &#125; &#125; Code Explanation None Reference LeetCode 官方题解 差的绝对值为 K 的数对数目 差的绝对值为 K 的数对数目 - 差的绝对值为 K 的数对数目 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1001","slug":"LeetCode 1001 网格照明","date":"2022-02-07T16:00:00.000Z","updated":"2022-02-08T08:16:52.000Z","comments":true,"path":"2022/02/08/LeetCode 1001 网格照明/","link":"","permalink":"https://www.leolang.top/2022/02/08/LeetCode%201001%20%E7%BD%91%E6%A0%BC%E7%85%A7%E6%98%8E/","excerpt":"LeetCode 1001 网格照明","text":"LeetCode 1001 网格照明 Problem Link 1001. 网格照明 - 力扣（LeetCode） (leetcode-cn.com) Problem Description 在大小为 n x n 的网格 grid 上，每个单元格都有一盏灯，最初灯都处于 关闭 状态。 给你一个由灯的位置组成的二维数组 lamps ，其中 lamps[i] = [rowi, coli] 表示 打开 位于 grid[rowi][coli] 的灯。即便同一盏灯可能在 lamps 中多次列出，不会影响这盏灯处于 打开 状态。 当一盏灯处于打开状态，它将会照亮 自身所在单元格 以及同一 行 、同一 列 和两条 对角线 上的 所有其他单元格 。 另给你一个二维数组 queries ，其中 queries[j] = [rowj, colj] 。对于第 j 个查询，如果单元格 [rowj, colj] 是被照亮的，则查询结果为 1 ，否则为 0 。在第 j 次查询之后 [按照查询的顺序] ，关闭 位于单元格 grid[rowj][colj] 上及相邻 8 个方向上（与单元格 grid[rowi][coli] 共享角或边）的任何灯。 返回一个整数数组 ans 作为答案， ans[j] 应等于第 j 次查询 queries[j] 的结果，1 表示照亮，0 表示未照亮。 示例 1： img 输入：n &#x3D; 5, lamps &#x3D; [[0,0],[4,4]], queries &#x3D; [[1,1],[1,0]] 输出：[1,0] 解释：最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0 次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] &#x3D; 1 。然后，关闭红色方框中的所有灯。 (Fig 1.1) 第 1 次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] &#x3D; 0 。然后，关闭红色矩形中的所有灯。 (Fig 1.2) Fig1.1 \\(Fig\\ 1.1\\) Fig1.2 \\(Fig\\ 1.2\\) 示例 2： 输入：n &#x3D; 5, lamps &#x3D; [[0,0],[4,4]], queries &#x3D; [[1,1],[1,1]] 输出：[1,1] 示例 3： 输入：n &#x3D; 5, lamps &#x3D; [[0,0],[0,4]], queries &#x3D; [[0,4],[0,1],[1,4]] 输出：[1,1,0] 提示： 1 &lt;= n &lt;= 109 0 &lt;= lamps.length &lt;= 20000 0 &lt;= queries.length &lt;= 20000 lamps[i].length == 2 0 &lt;= rowi, coli &lt; n queries[j].length == 2 0 &lt;= rowj, colj &lt; n Solution 本题是一道困难题，但是实际上问题想清楚后比较简单。看完题目并且看到题目描述中的网格图，就容易想到一道类似的题目：“八皇后” 。 传送门： 题目链接 843. n-皇后问题 - AcWing题库 相关博客 AcWing 搜索与图论（一） | W1ndness的技术栈 (leolang.top) 接下来开始分析本题。 对于本题应区分题中的两个容易混淆的概念：单元格被照亮、单元格灯亮。查询时查询单元格是否被照亮，而不是当前单元格灯是否亮；而熄灯则是熄灭单元格内的灯。 解决本题分为两个部分：一是点亮 lamps 中的所有灯；二是查询单元格状态，并按要求熄灭灯。 首先想到的是最暴力的模拟，暴力模拟灯的开关和单元格被照亮的情况。当我们看到常数为 \\(n\\le10^9\\) 时，常数过大，模拟一定会 TLE ，于是暴力做法就被舍弃了。 那么，就应对暴力的模拟做法进行改进。我们首先考虑点亮的过程。 首先，思考对于每一行（列、两对角线，以下省略，以行为例）是否能被照亮取决于什么。发现，当前行能被照亮的条件是当前行内存在被点亮的灯。那么为了能够查询，参考八皇后问题的记录方式，我们便记录每一行上被点亮的灯的数目，记为 \\(r_i\\) ，如果 \\(r_i&gt;0\\) ，证明第 \\(i\\) 行存在点亮着的灯，那么该行就应该是被点亮的状态。由于前面提到，本题的常数达到 \\(10^9\\) ，所以想到离散化的方式记录行中点亮的灯的数量的信息，即用哈希表进行记录。 之后，对于每次给定的一盏灯，其对应的都有表格中的一个位置。记灯 \\(lamp_i\\) 的坐标为 \\((x_i,y_i)\\) 。容易得到，其行、列、对角线信息为 \\[ lamp_i\\rightarrow \\left\\{ \\begin{array}{l} \\text{Row}=x_i\\\\ \\text{Column}=y_i\\\\ \\text{Diagonal}=x_i-y_i\\\\ \\text{Anti-Diagonal}=x_i+y_i \\end{array} \\right. \\] (详细推导见八皇后题目分析 AcWing 搜索与图论（一） | W1ndness的技术栈 (leolang.top) ) 题目中提及同一盏灯可能在 lamps 中多次列出，所以需要使用集合进行去重处理。于是，对于每一盏不重复的灯 \\(lamp_i\\) ，更新行、列、对角线四个哈希表中的状态值。点亮过程完成。 之后开始考虑查询过程。 首先，对于单元格是否是被点亮的，我们在点亮过程中已经记录好了行、列、对角线的状态。对于任意单元格，若其坐标为 \\((r,c)\\) ，行 \\(r\\) 、 列 \\(c\\) 、对角线 \\(r-c\\) 、反对角线 \\(r+c\\) 中任意一条线上存在一盏被点亮的灯，该单元格即被点亮。 之后，进行熄灯过程。熄灯要对以查询单元格为中心，周围 \\(3\\times 3\\) 范围内进行熄灯。由于之前我们维护过一个记录着所有被点亮的灯的集合，那么，熄灯过程就应该是查询该位置的灯是否是点亮的状态，如果被点亮，那么应将该灯熄灭，同时在集合中删除该灯坐标，并且更新状态哈希表的状态值。 查询过程完成，最终返回查询结果作为答案。 Submit Code lang = C++ class Solution &#123; public: vector&lt;int> gridIllumination(int n, vector&lt;vector&lt;int>>&amp; lamps, vector&lt;vector&lt;int>>&amp; queries) &#123; auto hash_p = [](const pair&lt;int, int> &amp;p) -> size_t &#123; hash&lt;long long> hash_ll; return hash_ll(p.first + ((long long)p.second &lt;&lt; 32)); &#125;; unordered_set&lt;pair&lt;int, int>, decltype(hash_p)> points(0, hash_p); unordered_map&lt;int, int> row, col, diag, antidiag; for (auto &amp;lamp: lamps) &#123; int x = lamp[0], y = lamp[1]; auto point = make_pair(x, y); if (!points.count(point)) &#123; points.insert(point); row[x]++; col[y]++; diag[x - y]++; antidiag[x + y]++; &#125; &#125; vector&lt;int> res(queries.size()); for (int i = 0; i &lt; (int) queries.size(); i++) &#123; int x = queries[i][0], y = queries[i][1]; if (row[x] > 0 || col[y] > 0 || diag[x - y] > 0 || antidiag[x + y] > 0) res[i] = 1; for (int r = x - 1; r &lt; x + 2; r++) &#123; for (int c = y - 1; c &lt; y + 2; c++) &#123; if (r &lt; 0 || r > n || c &lt; 0 || c > n) continue; auto point = make_pair(r, c); if (points.count(point)) &#123; points.erase(point); row[r]--; if (!row[r]) row.erase(r); col[c]--; if (!col[c]) col.erase(c); diag[r - c]--; if (!diag[r - c]) diag.erase(r - c); antidiag[r + c]--; if (!antidiag[r + c]) antidiag.erase(r + c); &#125; &#125; &#125; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]: points = set() row, col, diag, antidiag = Counter(), Counter(), Counter(), Counter() for x, y in lamps: if (x, y) not in points: points.add((x, y)) row[x] += 1 col[y] += 1 diag[x - y] += 1 antidiag[x + y] += 1 res = [0] * len(queries) for i, (x, y) in enumerate(queries): if row[x] or col[y] or diag[x - y] or antidiag[x + y]: res[i] = 1 for r in range(x - 1, x + 2): for c in range(y - 1, y + 2): if r &lt; 0 or r >= n or c &lt; 0 or c >= n: continue if (r, c) in points: points.remove((r, c)) row[r] -= 1 col[c] -= 1 diag[r - c] -= 1 antidiag[r + c] -= 1 return res lang = Java class Solution &#123; public int[] gridIllumination(int n, int[][] lamps, int[][] queries) &#123; HashMap&lt;Integer, Integer> row = new HashMap&lt;Integer, Integer>(); HashMap&lt;Integer, Integer> col = new HashMap&lt;Integer, Integer>(); HashMap&lt;Integer, Integer> diag = new HashMap&lt;Integer, Integer>(); HashMap&lt;Integer, Integer> antidiag = new HashMap&lt;Integer, Integer>(); HashSet&lt;Long> points = new HashSet&lt;Long>(); for (int[] lamp : lamps) &#123; int x = lamp[0], y = lamp[1]; if (!points.add(hash(x, y))) &#123; continue; &#125; row.put(x, row.getOrDefault(x, 0) + 1); col.put(y, col.getOrDefault(y, 0) + 1); diag.put(x - y, diag.getOrDefault(x - y, 0) + 1); antidiag.put(x + y, antidiag.getOrDefault(x + y, 0) + 1); &#125; int[] res = new int[queries.length]; for (int i = 0; i &lt; queries.length; i++) &#123; int x = queries[i][0], y = queries[i][1]; if (row.getOrDefault(x, 0) > 0 || col.getOrDefault(y, 0) > 0 || diag.getOrDefault(x - y, 0) > 0 || antidiag.getOrDefault(x + y, 0) > 0 ) &#123; res[i] = 1; &#125; for (int r = x - 1; r &lt; x + 2; r++) &#123; for (int c = y - 1; c &lt; y + 2; c++) &#123; if (r &lt; 0 || r >= n || c &lt; 0 || c >= n) &#123; continue; &#125; if (points.remove(hash(r, c))) &#123; row.put(r, row.get(r) - 1); col.put(c, col.get(c) - 1); diag.put(r - c, diag.get(r - c) - 1); antidiag.put(r + c, antidiag.get(r + c) - 1); &#125; &#125; &#125; &#125; return res; &#125; private long hash(int x, int y) &#123; return (long) x + ((long) y &lt;&lt; 32); &#125; &#125; Code Explanation lang = C++ unordered_set 的使用 std::unordered_set - C++中文 - API参考文档 (apiref.com) C++ STL unordered_set容器完全攻略 (biancheng.net) unordered_set 实现了对于基本类型的重载，但对于自定义类型不能使用，因为没有实现相应的 hash 函数。如果想要使用，需要自己实现相应的 hash 函数，如一板块中 C++ 代码中写的 auto hash_p = [](const pair&lt;int, int> &amp;p) -> size_t &#123; hash&lt;long long> hash_ll; return hash_ll(p.first + ((long long)p.second &lt;&lt; 32)); &#125;; 并且初始化写做 unordered_set&lt;pair&lt;int, int>, decltype(hash_p)> points(0, hash_p); 表示以 pair 为基本元素的 unordered_set ，使用 decltype 为自动推断类型，构造函数参数意为 0 个元素的，以 hash_p 为 hash 函数的 unordered_set 。 注：若不自己实现 hash 函数就要求使用 set ，但会增加时间复杂度。 STL 的使用 AcWing C++ STL 使用技巧 | W1ndness的技术栈 (leolang.top) lang = Python3 collections.Counter 的使用 collections — Container datatypes — Counter — Python 3.10.2 documentation Counter 为一计数器，实质上为一个字典即哈希表，可以用于记录某元素出现次数。 lang = Java Java 中没有像 C++ 一样的简单的 pair 类型，所以这里就直接使用哈希表的原理，即给定一公式计算哈希值进行哈希，并将哈希值存在集合里。 哈希函数为 \\[ hash(x,y)=x+y\\times2^{32} \\] 即 private long hash(int x, int y) &#123; return (long) x + ((long) y &lt;&lt; 32); &#125; 同时应注意 Java 中如何对 HashMap 进行更新和取值。 Reference LeetCode 官方题解 网格照明 - 网格照明 - 力扣（LeetCode） (leetcode-cn.com) 宫水三叶题解 【宫水三叶】哈希表 + 线映射模拟题 - 网格照明 - 力扣（LeetCode） (leetcode-cn.com)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"Hash","slug":"Hash","permalink":"https://www.leolang.top/tags/Hash/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"LeetCode 1405","slug":"LeetCode 1405 最长快乐字符串","date":"2022-02-06T16:00:00.000Z","updated":"2022-02-08T08:13:42.000Z","comments":true,"path":"2022/02/07/LeetCode 1405 最长快乐字符串/","link":"","permalink":"https://www.leolang.top/2022/02/07/LeetCode%201405%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"LeetCode 1405 最长快乐字符串","text":"LeetCode 1405 最长快乐字符串 Problem Link 1405. 最长快乐字符串 - 力扣（LeetCode） (leetcode-cn.com) Problem description 如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。 给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s： s 是一个尽可能长的快乐字符串。 s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。 s中只含有 'a'、'b' 、'c' 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 \"\"。 示例 1： 输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 7 输出：&quot;ccaccbcc&quot; 解释：&quot;ccbccacc&quot; 也是一种正确答案。 示例 2： 输入：a &#x3D; 2, b &#x3D; 2, c &#x3D; 1 输出：&quot;aabbc&quot; 示例 3： 输入：a &#x3D; 7, b &#x3D; 1, c &#x3D; 0 输出：&quot;aabaa&quot; 解释：这是该测试用例的唯一正确答案。 提示： 0 &lt;= a, b, c &lt;= 100 a + b + c &gt; 0 Solution 本题的解法是贪心。 本题要求是找到最长的快乐字符串，题目对于 “快乐字符串” 的要求是：不能含有三个连续的、相同的字母。那么，为了使得字符串尽可能的长，那么就应该让最终剩余的字母出现相同的可能尽可能小，即剩余相同字母数量尽可能少，就应当尽可能优先用当前状态下数量最多的字母。依照此种方式进行构建后，最终如果仍有剩余，剩下的应当是同一种字母，并且是最初时数量最多的那种字母。 之后，这种方式必然会产生弊端，假设一种字母的数量足够大，就会出现连续加入三个相同字母的情况。那么，为了满足快乐字符串的要求，当连续的加入了两个相同的字母后，就不能再添加相同的第三个字母了，那么就要添加次多的那种字母。 最终，如果所有的尝试情况都没有办法符合题意，就应结束退出，此时的字符串即为寻找的最长快乐字符串。 可以看到，本题实际上有堆的思想在其中，事实上可以通过堆（优先队列）实现。但考虑到这里可能出现要插入次多的字符作为当前位置的答案的情况，这里使用 数组+排序 的方式去替代优先队列更为简便。优先队列涉及一系列的状态更新，但也可以实现本题要求。 Submit Code lang = C++ class Solution &#123; public: string longestDiverseString(int a, int b, int c) &#123; string res; typedef pair&lt;int, char> PIC; vector&lt;PIC> cnt = &#123;&#123;a, 'a'&#125;, &#123;b, 'b'&#125;, &#123;c, 'c'&#125;&#125;; while (true) &#123; sort(cnt.begin(), cnt.end(), [&amp;](const PIC &amp;a, const PIC &amp;b) &#123; return a.first > b.first; &#125;); bool updated = false; for (auto &amp;[freq, ch]: cnt) &#123; if (freq &lt;= 0) continue; int len = res.size(); if (len >= 2 &amp;&amp; res[len - 1] == ch &amp;&amp; res[len - 2] == ch) &#123; continue; &#125; res.push_back(ch); freq--; updated = true; break; &#125; if (!updated) break; &#125; return res; &#125; &#125;; lang = Python3 class Solution: def longestDiverseString(self, a: int, b: int, c: int) -> str: res = [] cnt = [[a, 'a'], [b, 'b'], [c, 'c']] while True: cnt.sort(key=lambda x: -x[0]) updated = False for i, (freq, ch) in enumerate(cnt): if freq &lt;= 0: continue n = len(res) if n >= 2 and res[n - 1] == ch and res[n - 2] == ch: continue res.append(ch) updated = True cnt[i][0] -= 1 break if not updated: break return ''.join(res) lang = Java class Solution &#123; class Pair &#123; int freq; char ch; public Pair(int freq, char ch) &#123; this.freq = freq; this.ch = ch; &#125; &#125; public String longestDiverseString(int a, int b, int c) &#123; Pair[] cnt = &#123;new Pair(a, 'a'), new Pair(b, 'b'), new Pair(c, 'c')&#125;; StringBuilder res = new StringBuilder(); while (true) &#123; Arrays.sort(cnt, (p1, p2) -> p2.freq - p1.freq); boolean updated = false; for (Pair pair: cnt) &#123; if (pair.freq &lt;= 0) continue; int len = res.length(); if (len >= 2 &amp;&amp; res.charAt(len - 2) == pair.ch &amp;&amp; res.charAt(len - 1) == pair.ch) &#123; continue; &#125; res.append(pair.ch); pair.freq--; updated = true; break; &#125; if (!updated) break; &#125; return res.toString(); &#125; &#125; Code Explanation lang = C++ C++11 lambda 表达式的使用： C++ 中的 Lambda 表达式 | Microsoft Docs 作为 sort 函数的排序依据，即第三个参数 以 vector 为例： vector&lt;pair&lt;int, int>> nums; sort(nums.begin(), nums.end(), [&amp;](const pair&lt;int, int> &amp;a, const pair&lt;int, int> &amp;b) &#123; return a.first > b.first; &#125;) 作为 for each 循环中提取 pair 类型的两变量的简便写法 vector&lt;pair&lt;int, int>> pairs; for (auto [a, b]: pairs) &#123; ... &#125; lang = Python3 enumerate() 的使用： Python enumerate() 函数 | 菜鸟教程 (runoob.com) 内置函数enumerate — Python 3.10.2 文档 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 lang = Java 用于字符串拼接的 StringBuffer 和 StringBuilder Java StringBuffer 和 StringBuilder 类 | 菜鸟教程 (runoob.com) 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 Arrays.sort() Java的Arrays.sort()良心总结_Veggie的博客-CSDN博客 对于数组的排序，类似于C++STL sort() Java8 lambda Java Lambda 表达式 | 菜鸟教程 (runoob.com) lambda 的另一种写法为 Arrays.sort(cnt, (p1, p2) -> &#123; return p1.freq - p2.freq; &#125;); 本题中也可用 Comparator.comparingInt() 提取元素，代码为 Arrays.sort(cnt, Comparator.comparingInt(p -> p.freq)); 也可实现匿名类，代码为 Arrays.sort(cnt, new Comparator&lt;Pair>() &#123; @Override public int compare(Pair p1, Pair p2) &#123; return p1.freq - p2.freq; &#125; &#125;); Reference LeetCode 官方题解 最长快乐字符串(最长快乐字符串 - 最长快乐字符串 - 力扣（LeetCode） (leetcode-cn.com))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"}]},{"title":"数学建模（一）线性规划","slug":"第1章 线性规划问题","date":"2022-01-09T16:00:00.000Z","updated":"2022-05-18T12:58:49.359Z","comments":true,"path":"2022/01/10/第1章 线性规划问题/","link":"","permalink":"https://www.leolang.top/2022/01/10/%E7%AC%AC1%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/","excerpt":"前言 从本文起，将介绍有关数学建模的有关内容。首先，本文将介绍线性规划的有关内容。","text":"前言 从本文起，将介绍有关数学建模的有关内容。首先，本文将介绍线性规划的有关内容。 第 1 章 线性规划 1.1 线性规划问题 1.1.1 线性规划的实例与定义 线性规划问题是在一组线性约束条件的限制下，求一线性目标函数最大或最小的问题。 在解决实际问题时，吧问题归结成一个线性规划数学模型是很重要的一步，往往也是很困难的一步，模型建立的是否恰当，直接影响到求解。而选择适当的决策变量，是建立有效模型的关键之一。 1.1.2 线性规划问题的解的概念 一般线性规划问题的数学标准型为： \\[ \\begin{align} &amp;\\max z=\\sum_{j=1}^nc_jx_j\\\\ &amp;\\mathrm{s.t.}\\ \\left\\{ \\begin{array}{ll} \\displaystyle\\sum_{j=1}^na_{ij}x_j=b_i &amp; i=1, 2, \\cdots, m\\\\ x_j\\ge0 &amp; j = 1, 2, \\cdots, n \\end{array} \\right.\\\\ \\end{align} \\] 其 MATLAB 标准形式描述为： \\[ \\begin{align} &amp;\\min_x \\boldsymbol f^T\\boldsymbol x\\\\ &amp;\\mathrm{s.t.}\\ \\left\\{ \\begin{array}{l} A\\cdot \\boldsymbol x\\le \\boldsymbol b\\\\ Aeq\\cdot x=beq\\\\ lb\\le x\\le ub \\end{array} \\right. \\end{align} \\] 其中，\\(\\boldsymbol f ,\\boldsymbol x,\\boldsymbol b,beq, lb, ub\\) 为 \\(n\\) 维列向量，\\(A\\) 和 \\(Aeq\\) 为适当维数的矩阵，\\(\\boldsymbol b\\) 和 \\(beq\\)​ 为适当维数的列向量。 \\(\\boldsymbol f\\) 称为价值向量，\\(\\boldsymbol b\\) 称为资源向量。 可行解：满足约束条件的解 \\(\\boldsymbol x=[x_1,\\cdots,x_n]^T\\) ，称为线性规划问题的可行解，而使目标函数达到最大值的可行解叫做最优解。 可行域：所有可行解构成的集合称为问题的可行域，记为 \\(R\\)​ 。 MATLAB 中求解线性规划的命令为： [x, fval] = linprog(f, A, b) [x, fval] = linprog(f, A, b, Aeq, beq) [x, fval] = linprog(f, A, b, Aeq, beq, lb, ub) % x返回的是决策向量的取值，fval返回的是目标函数的最优值，c为价值向量，A、b对应的是线性不等式约束，Aeq、beq对应的是线性等式约束，lb、ub分别对应的是决策向量的下界向量和上界向量 例：求解下列线性规划问题 \\[ \\begin{align} &amp;\\max z=2x_1+3x_2-5x_3\\\\ &amp;\\mathrm{s.t.}\\\\ &amp;\\begin{array}{ll} x_1+x_2+x_3=7\\\\ 2x_1-5x_2+x_3\\ge 10\\\\ x_1+3x_2+x_3\\le 12\\\\ x_1,x_2,x_3\\ge 0\\\\ \\end{array}\\\\ \\end{align} \\] 首先，应将其化为标准形式，对于求最大值在等式中加负号而求其最小值即可，而对于 \\(\\ge\\) 式的处理，同样的加负号使其逆转即可。则化为 MATLAB 标准型为： \\[ \\begin{align} &amp;\\min w=-2x_1-3x_2+5x_3\\\\ &amp;\\mathrm{s.t.} \\left\\{ \\begin{array}{l} \\begin{bmatrix} -2 &amp; 5 &amp; -1\\\\ 1 &amp; 3 &amp; 1\\\\ \\end{bmatrix} \\begin{bmatrix} x_1\\\\x_2\\\\x_3 \\end{bmatrix} \\le \\begin{bmatrix} -10\\\\12 \\end{bmatrix}\\\\ [1, 1, 1]\\cdot[x_1,x_2,x_3]^T=7\\\\ [x_1,x_2,x_3]^T\\ge[0, 0, 0]^T \\end{array} \\right. \\end{align} \\] 则求解的 MATLAB 程序如下： f = [-2; -3; 5]; a = [-2, 5, -1; 1, 3, 1]; b = [-10; 12]; aeq = [1, 1, 1]; beq = 7; [x, y] = linprog(f, a, b, aeq, beq, zeros(3, 1)); x, y = -y 1.1.3 可以转化为线性规划的问题 例：规划问题为 \\[ \\begin{align} &amp;\\min |x_1|+|x_2|+\\cdots+|x_n|\\\\ &amp;\\mathrm{s.t.}\\ Ax\\le b\\\\ \\end{align} \\] 其中 \\(x=[x_1,\\cdots,x_n]^T\\) ，\\(A\\) 和 \\(b\\) 为相应维数的矩阵和向量。 要把上面的问题变换成线性规划问题，只要注意到事实：对于任意的 \\(x_i\\)​ ，存在 \\(u_i,v_i\\ge 0\\)​ 满足 \\[ x_i=u_i-v_i,\\ |x_i|=u_i+v_i \\] 事实上，我们只要取 \\(\\large u_i=\\frac{x_i+|x_i|}2,\\ v_i=\\frac{|x_i|-x_i}2\\)​ 就可以满足上面的条件。 这样，记 \\(u=[u_1,\\cdots,u_n]^T,\\ v=[v_1,\\cdots,v_n]^T\\) ，从而我们可以把上面的问题变成 \\[ \\begin{align} &amp;\\min \\sum_{i=1}^n(u_i+v_i)\\\\ &amp;\\mathrm{s.t.}\\ \\left\\{ \\begin{array}{l} A(u-v)\\le b\\\\ u,v\\ge 0\\\\ \\end{array} \\right. \\end{align} \\] 其中，\\(u\\ge 0\\) 为向量 \\(u\\) 的每个分量大于等于 \\(0\\) 。 进一步把模型改写成 \\[ \\begin{align} \\min \\sum_{i=1}^n(u_i+v_i),\\\\ \\mathrm{s.t.}\\ \\left\\{ \\begin{array}{l} \\begin{bmatrix} A&amp;-A \\end{bmatrix} \\begin{bmatrix} u\\\\v \\end{bmatrix} \\le b\\\\ u,v\\ge 0\\\\ \\end{array} \\right. \\end{align} \\] 例：求解下列数学规划问题 \\[ \\begin{align} &amp;\\min z=|x_1|+2|x_2|+3|x_3|+4|x_4|,\\\\ &amp;\\mathrm{s.t.} \\left\\{ \\begin{array}{l} x_1-x_2-x_3+x_4\\le-2\\\\ x_1-x_2+x_3-3x_4\\le-1\\\\ x_1-x_2-2x_3+3x_4\\le -\\frac 1 2\\\\ \\end{array} \\right. \\end{align} \\] 做变量变换 \\(\\large u_i=\\frac{x_i+|x_i|}2,\\ v_i=\\frac{|x_i|-x_i}2,\\ i=1,2,3,4\\) ，并把新变量重新排序成一维向量 \\(y=\\begin{bmatrix}u\\\\v\u0010\\end{bmatrix}=[u_1,\\cdots,u_4,v_1,\\cdots,v_4]^T\\) ，则可把模型变换为线性规划模型 \\[ \\begin{align} &amp;\\min c^Ty,\\\\ &amp;\\mathrm{s.t.} \\left\\{ \\begin{array}{l} [A,-A] \\begin{bmatrix}u\\\\v\\end{bmatrix} \\le b\\\\ y\\ge0 \\end{array} \\right.\\\\ \\end{align} \\] \\(where\\) \\[ \\begin{gather} c=[1, 2, 3, 4, 1, 2, 3, 4]^T\\\\ b=[-2, -1, -\\frac1 2]^T\\\\ A= \\begin{bmatrix} 1 &amp; -1 &amp; -1 &amp; 1\\\\ 1 &amp; -1 &amp; 1 &amp; -3\\\\ 1 &amp; -1 &amp; -2 &amp; 3\\\\ \\end{bmatrix} \\end{gather} \\] 计算的 MATLAB 程序为： clc, clear c = 1:4; c = [c, c]'; a = [1 -1 -1 1; 1 -1 1 -3; 1 -1 -2 3]; a = [a -a]; b = [-2 -1 -1/2]'; [y, z] = linprog(c, a, b, [], [], zeros(8, 1)) x = y(1:4) - y(5:end) 1.2 投资的收益和风险 1.2.1 问题提出 市场上有 \\(n\\) 中资产 \\(s_i (i=1,2,\\cdots,n)\\) 可以选择，现用数额为 \\(M\\) 的相当大的资金做一个时期的投资。这 \\(n\\) 种资产在这一时期内购买 \\(s_i\\) 的平均收益率为 \\(r_i\\) ，风险损失率为 \\(q_i\\) ，投资越分散，总的风险越少，总体风险是可用投资 \\(s_i\\) 中最大的一个风险来度量。 购买 \\(s_i\\) 时要付交易费，费率为 \\(p_i\\) ，当购买额不超过给定值 \\(u_i\\) 时，交易费按购买 \\(u_i\\) 计算。另外，假定同期银行存款利率是 \\(r_0\\) ，既无交易费又无风险 \\((r_0=5\\%)\\) 。 已知 \\(n=4\\)​ 时的相关数据如表 1.1 。（见书） 1.2.2 符号规定和基本假设 符号规定 \\(s_i\\) 表示第 \\(i\\) 种投资项目，\\(i=0,1,\\cdots,n\\) ，其中 \\(s_0\\) 指存入银行； \\(r_i,p_i,q_i\\) 分别表示 \\(s_i\\) 的平均收益率，交易费率，风险损失率，\\(i=0,\\cdots,n\\) ，其中 \\(p_0=0,\\ q_0=0\\) ； \\(u_i\\) 表示 \\(s_i\\) 的交易定额，\\(i=1,\\cdots,n\\) ； \\(x_i\\) 表示投资项目 \\(s_i\\) 的资金，\\(i=0,1,\\cdots,n\\) ； \\(a\\) 表示投资风险度； \\(Q\\)​ 表示总体收益。 基本假设 投资数额 \\(M\\) 相当大，为了便于计算，假设 \\(M=1\\) ； 投资越分散，总的风险越小； 总体风险用投资项目 \\(s_i\\) 中最大的一个风险来度量； \\(n+1\\) 种资产 \\(s_i\\) 之间是相互独立的； 在资产的这一时期内，\\(r_i,p_i,q_i\\) 为定值，不受以外因素影响； 净收益和总体风险只受 \\(r_i,p_i,q_i\\) 影响，不受其他因素干扰。 1.2.3 模型的分析与建立 总体风险所投资的 \\(s_i\\) 中最大的一个风险来衡量，即 \\[ \\max\\ \\{q_ix_i\\ |\\ i=1,2,\\cdots,n\\} \\] 购买 \\(s_i(i=1,2,\\cdots,n)\\) 所付交易费是一个分段函数，即 \\[ \\text{交易费}= \\begin{cases} p_ix_i&amp;x_i&gt;u_i\\\\ p_iu_i&amp;x_i\\le u_i\\\\ \\end{cases} \\] 而题目所给的定值 \\(u_i\\) （单位：元）相对总投资 \\(M\\) 很少，\\(p_iu_i\\) 更小，这样购买 \\(s_i\\) 的净收益可以简化为 \\((r_i-p_i)x_i\\) 。 要使净收益尽可能大，总体风险尽可能小，这是一个多目标规划模型。 目标函数为 \\[ \\left\\{ \\begin{array}{l} \\displaystyle\\max \\sum_{i=0}^n(r_i-p_i)x_i\\\\ \\displaystyle\\min \\{\\max_{1\\le i \\le n}\\{q_ix_i\\}\\} \\end{array} \\right. \\] 约束条件为 \\[ \\left\\{ \\begin{array}{l} \\displaystyle\\sum_{i=0}^n(1+p_i)x_i=M\\\\ x_i\\ge 0,i=0,1,\\cdots,n\\\\ \\end{array} \\right. \\] 模型简化 在实际投资中，投资者承担风险的程度不一样，若给定风险一个界限 \\(a\\)​ ，使最大的一个风险率为 \\(a\\)​ ，即 \\(\\displaystyle\\frac{q_ix_i}M\\le a(i=1,2,\\cdots,n)\\)​ ，可找到相应的投资方案。这样把多目标规划变成一个目标的线性规划。 模型一 固定风险水平，优化收益 \\[ \\begin{align} &amp;\\max \\sum_{i=0}^n(r_i-p_i)x_i\\\\ &amp;\\mathrm{s.t.}\\ \\left\\{ \\begin{array}{l} \\displaystyle \\frac{q_ix_i}M\\le a\\\\ \\displaystyle\\sum_{i=0}^n(1+p_i)x_i=M,\\ x_i\\ge 0,\\ i=0,1,\\cdots,n \\end{array} \\right. \\end{align} \\] 若投资者希望总盈利至少达到水平 \\(k\\) 以上，在风险最小的情况下寻求相应的投资组合。 模型二 固定盈利水平，极小化风险 \\[ \\begin{align} &amp;\\displaystyle\\min \\{\\max_{1\\le i \\le n}\\{q_ix_i\\}\\}\\\\ &amp;\\mathrm{s.t.}\\ \\left\\{ \\begin{array}{l} \\displaystyle\\sum_{i=0}^n(r_i-p_i)x_i\\ge k\\\\ \\displaystyle\\sum_{i=0}^n(1+p_i)x_i=M\\\\ x_i\\ge 0,\\ i=0,1,\\cdots,n \\end{array} \\right. \\end{align} \\] 投资者在权衡资产风险和预期收益两方面时，希望选择一个令自己满意的投资组合。因此对风险、收益分别赋予权重 \\(s(0&lt;s\\ge 1)\\) 和 \\(1-s\\) ，\\(s\\) 称为投资偏好系数。 模型三 \\[ \\begin{align} &amp;\\displaystyle\\min s\\{\\max\\{q_ix_i\\}\\}-(1-s)\\sum_{i=0}^s(r_i-p_i)x_i\\\\ &amp;\\mathrm{s.t.} \\left\\{ \\begin{array}{l} \\displaystyle\\sum_{i=0}^n(1+p_i)x_i=M\\\\ x_i\\ge0,\\ i=0,1,2,\\cdots,n \\end{array} \\right. \\end{align} \\] 1.2.4 模型一的求解 模型一为 \\[ \\begin{align} &amp;\\min f=[-0.05, -0.27, -0.19, -0.185, -0.185]\\cdot[x_0,x_1,x_2,x_3,x_4]^T\\\\ &amp;\\mathrm{s.t.} \\left\\{ \\begin{array}{l} x_0+1.01x_1+1.02x_2+1.045x_3+1.065x_4=1\\\\ 0.025x_1\\le a\\\\ 0.015x_2\\le a\\\\ 0.055x_3\\le a\\\\ 0.026x_4\\le a\\\\ x_i\\ge 0,\\ i=0,1,\\cdots,4\\\\ \\end{array} \\right. \\end{align} \\] 由于 \\(a\\) 是任意给定的风险度，不同的投资者有不同过得风险度。下面从 \\(a=0\\) 开始，以步长 \\(\\Delta a=0.001\\) 进行循环搜索，编制程序如下： clc, clear a = 0; hold on while a &lt; 0.05 c = [-0.05, -0.27, -0.19, -0.185, -0.185]; A = [zeros(4, 1), diag([0.025, 0.015, 0.055, 0.026])]; b = a * ones(4, 1) Aeq = [1, 1.01, 1.02, 1.045, 1.065]; beq = 1; LB = zeros(5, 1); [x, Q] = linprog(c, A, b,Aeq, beq, LB); Q = -Q; plot(a, Q, '*k'); a = a + 0.001; end xlabel('a'), ylabel('Q') image-20220116222326730 1.2.5 结果分析 风险 \\(a\\) 与收益 \\(Q\\) 之间的关系如图所示。从图中可以看出： 风险大，收益也大 当投资越分散是，投资者承担的风险越小，这与题意一致。冒险的投资者会出现集中投资的情况，保守的投资者尽量分散投资 在 \\(a=0.006\\) 附近有一个转折点，在这一点左边，风险增加很少是，利润增长很快；在这一点右边，风险增加很大时，利润增长很缓慢。所以对于风险和收益没有特殊偏好的投资者来说，应该选择曲线的转折点作为最优投资组合，大约是 \\(a=0.6\\%,\\ Q=20\\%\\) ，所对应的投资方案为： 风险度 \\(a=0.006\\) ，收益 \\(Q=0.2019\\) ，\\(x_0=0,\\ x_1=0.24,\\ x_2=0.4,\\ x_3=0.1091,\\ x_4=0.2212\\) 。 参考 《数学建模算法与应用》by 司守奎、孙兆亮","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://www.leolang.top/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"学习笔记","slug":"数学建模/学习笔记","permalink":"https://www.leolang.top/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"Mathematical Modeling","slug":"Mathematical-Modeling","permalink":"https://www.leolang.top/tags/Mathematical-Modeling/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.leolang.top/tags/MATLAB/"},{"name":"Linear Progress","slug":"Linear-Progress","permalink":"https://www.leolang.top/tags/Linear-Progress/"}]},{"title":"Beautiful Soup 学习笔记（一）","slug":"Beautiful Soup 遍历文档树","date":"2021-11-28T16:00:00.000Z","updated":"2022-03-31T13:54:19.813Z","comments":true,"path":"2021/11/29/Beautiful Soup 遍历文档树/","link":"","permalink":"https://www.leolang.top/2021/11/29/Beautiful%20Soup%20%E9%81%8D%E5%8E%86%E6%96%87%E6%A1%A3%E6%A0%91/","excerpt":"前言 本文将介绍有关 Python 的 网页解析库 Beautiful Soup 对于 DOM 结构上的操作的有关内容。","text":"前言 本文将介绍有关 Python 的 网页解析库 Beautiful Soup 对于 DOM 结构上的操作的有关内容。 Beautiful Soup 与文档树 0 使用库和参考资料 Beautiful Soup v4.4.0 import bs4 Reference: Beautiful Soup 4.4.0 文档 — Beautiful Soup 4.2.0 中文 文档——遍历文档树 Beautiful Soup Documentation — Beautiful Soup 4.4.0 documentation——Navigating the tree W3school -- Javascript HTML DOM 本文修正了一些中文官方文档中翻译失当的地方。 1 关于 DOM 1.1 什么是 DOM 当网页被加载时，浏览器会创建页面的文档对象模型，即 DOM，DOM 是 Document Object Model 的缩写。 HTML DOM 模型被结构化为对象树： DOM HTML 树 通过这个对象模型，JavaScript 获得创建动态 HTML 的所有力量： JavaScript 能改变页面中的所有 HTML 元素 JavaScript 能改变页面中的所有 HTML 属性 JavaScript 能改变页面中的所有 CSS 样式 JavaScript 能删除已有的 HTML 元素和属性 JavaScript 能添加新的 HTML 元素和属性 JavaScript 能对页面中所有已有的 HTML 事件作出反应 JavaScript 能在页面中创建新的 HTML 事件 DOM 是一项 W3C (World Wide Web Consortium) 标准。 DOM 定义了访问文档的标准： “W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问、更新文档的内容、结构和样式。” W3C DOM 标准被分为 3 个不同的部分： Core DOM - 所有文档类型的标准模型 XML DOM - XML 文档的标准模型 HTML DOM - HTML 文档的标准模型 1.2 什么是 HTML DOM HTML DOM 是 HTML 的标准对象模型和编程接口。它定义了： 作为对象的 HTML 元素 所有 HTML 元素的属性 访问所有 HTML 元素的方法 所有 HTML 元素的事件 换言之：HTML DOM 是关于如何获取、更改、添加或删除 HTML 元素的标准。 1.3 DOM 文档 HTML DOM 文档对象是网页中所有其他对象的拥有者 HTML Document 对象 文档对象代表您的网页。 如果您希望访问 HTML 页面中的任何元素，那么您总是从访问 document 对象开始。 下面是一些如何使用 document 对象来访问和操作 HTML 的实例。 2 bs4 遍历文档树 有这样一段 HTML 代码： &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &lt;body&gt; &lt;p class&#x3D;&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;, &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt; and &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;; and they lived at the bottom of a well.&lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt; 将其输入 Python 中，同时使用 bs4 对其解析： html_doc = \"\"\" &lt;html>&lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head> &lt;body> &lt;p class=\"title\">&lt;b>The Dormouse's story&lt;/b>&lt;/p> &lt;p class=\"story\">Once upon a time there were three little sisters; and their names were &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie&lt;/a>, &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie&lt;/a> and &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie&lt;/a>; and they lived at the bottom of a well.&lt;/p> &lt;p class=\"story\">...&lt;/p> \"\"\" from bs4 import BeautifulSoup soup = BeautifulSoup(html_doc, 'html.parser') 通过这段例子来演示怎样从文档的一段内容找到另一段内容。 使用 prettify() 方法格式化后得到： &lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse&#39;s story &lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;p class&#x3D;&quot;title&quot;&gt; &lt;b&gt; The Dormouse&#39;s story &lt;&#x2F;b&gt; &lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt; Elsie &lt;&#x2F;a&gt; , &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt; Lacie &lt;&#x2F;a&gt; and &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt; Tillie &lt;&#x2F;a&gt; ; and they lived at the bottom of a well. &lt;&#x2F;p&gt; &lt;p class&#x3D;&quot;story&quot;&gt; ... &lt;&#x2F;p&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 2.1 子节点 一个 Tag 可能包含多个字符串或其它的 Tag ，这些都是这个 Tag 的子节点。Beautiful Soup 提供了许多操作和遍历子节点的属性。 注意: Beautiful Soup中字符串节点不支持这些属性，因为字符串没有子节点。 2.1.1 Tag 的名字 操作文档树最简单的方式就是告诉它你想获取的 tag 的 name 。如果想获取 &lt;head&gt; 标签，只要用 soup.head() ： soup.head # &lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head> soup.title # &lt;title>The Dormouse's story&lt;/title> 这是个获取 tag 的小窍门，可以在文档树的 tag 中多次调用这个方法.下面的代码可以获取 &lt;body&gt; 标签中的第一个 &lt;b&gt; 标签： soup.body.b # &lt;b>The Dormouse's story&lt;/b> 通过点取属性的方式只能获得当前名字的第一个tag： soup.a # &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie&lt;/a> 如果想要得到所有的 &lt;a&gt; 标签,或是通过名字得到比一个 tag 更多的内容的时候,就需要用到搜索文档树中描述的方法,比如：find_all() soup.find_all('a') # [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie&lt;/a>, # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie&lt;/a>, # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie&lt;/a>] 2.1.2 .contents 和 .children tag 的.contents 属性可以将 tag 的子结点以列表的方式输出： head_tag = soup.head head_tag # &lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head> head_tag.contents # [&lt;title>The Dormouse's story&lt;/title>] title_tag = head_tag.contents[0] title_tag # &lt;title>The Dormouse's story&lt;/title> title_tag.contents # [u'The Dormouse's story'] BeautifulSoup 对象本身一定会包含子节点，也就是说 &lt;html&gt; 标签也是 BeautifulSoup 对象的子节点： len(soup.contents) # 1 soup.contents[0].name # u'html' 字符串没有 .contents 属性，因为字符串没有子节点： text = title_tag.contents[0] text.contents # AttributeError: 'NavigableString' object has no attribute 'contents' 通过 tag 的 .children 生成器，可以对 tag 的子节点进行循环： for child in title_tag.children: print(child) # The Dormouse's story 2.1.3 .descendants .contents 和 .children 属性仅包含 tag 的直接子节点。例如，&lt;head&gt; 标签只有一个直接子节点 &lt;title&gt; head_tag.contents # [&lt;title>The Dormouse's story&lt;/title>] 但是 &lt;title&gt; 标签也包含一个子节点：字符串 “The Dormouse’s story”，这种情况下字符串 “The Dormouse’s story”也属于 &lt;head&gt; 标签的子孙节点。.descendants 属性可以对所有 tag 的子孙节点进行递归循环： 注：此处采用的是先序遍历（Preorder Traverse） for child in head_tag.descendants: print(child) # &lt;title>The Dormouse's story&lt;/title> # The Dormouse's story 上面的例子中，&lt;head&gt; 标签只有一个子节点，但是有2个子孙节点：&lt;head&gt; 节点和 &lt;head&gt; 的子节点， BeautifulSoup 有一个直接子节点( &lt;html&gt; 节点)，却有很多子孙节点： len(list(soup.children)) # 1 len(list(soup.descendants)) # 25 2.1.4 .string 如果 tag 只有一个 NavigableString 类型子节点，那么这个 tag 可以使用 .string 得到子节点： title_tag.string # u'The Dormouse's story' 如果一个 tag 仅有一个子节点，那么这个 tag 也可以使用 .string 方法，输出结果与当前唯一子节点的 .string 结果相同： head_tag.contents # [&lt;title>The Dormouse's story&lt;/title>] head_tag.string # u'The Dormouse's story' 如果 tag 包含了多个子节点，tag 就无法确定 .string 方法应该调用哪个子节点的内容，.string 的输出结果是 None ： print(soup.html.string) # None 2.1.5 .string 和 .stripped_strings 如果 tag 中 包含多个字符串，可以使用 .strings 来循环获取： for string in soup.strings: print(repr(string)) # u\"The Dormouse's story\" # u'\\n\\n' # u\"The Dormouse's story\" # u'\\n\\n' # u'Once upon a time there were three little sisters; and their names were\\n' # u'Elsie' # u',\\n' # u'Lacie' # u' and\\n' # u'Tillie' # u';\\nand they lived at the bottom of a well.' # u'\\n\\n' # u'...' # u'\\n' 输出的字符串中可能包含了很多空格或空行，使用 .stripped_strings 可以去除多余空白内容： for string in soup.stripped_strings: print(repr(string)) # u\"The Dormouse's story\" # u\"The Dormouse's story\" # u'Once upon a time there were three little sisters; and their names were' # u'Elsie' # u',' # u'Lacie' # u'and' # u'Tillie' # u';\\nand they lived at the bottom of a well.' # u'...' 全部是空格的行会被忽略掉，段首和段末的空白会被删除。 2.2 父节点 继续分析文档树，每个 tag 或字符串都有父节点：被包含在某个 tag 中 2.2.1 .parent 通过 .parent 属性来获取某个元素的父节点。在例子“爱丽丝”的文档中，&lt;head&gt; 标签是 &lt;title&gt; 标签的父节点： title_tag = soup.title title_tag # &lt;title>The Dormouse's story&lt;/title> title_tag.parent # &lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head> 文档 title 的字符串也有父节点：&lt;title&gt; 标签 title_tag.string.parent # &lt;title>The Dormouse's story&lt;/title> 文档的顶层节点比如 &lt;html&gt; 的父节点是 BeautifulSoup 对象： html_tag = soup.html type(html_tag.parent) # &lt;class 'bs4.BeautifulSoup'> BeautifulSoup 对象的 .parent 是 None ： print(soup.parent) # None 2.2.2 .parents 通过元素的 .parents 属性可以递归得到元素的所有父辈节点，下面的例子使用了 .parents 方法遍历了 &lt;a&gt; 标签到根节点的所有节点。 link = soup.a link # &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie&lt;/a> for parent in link.parents: if parent is None: print(parent) else: print(parent.name) # p # body # htm # [document] # None 2.3 兄弟节点 看一段简单的例子： sibling_soup = BeautifulSoup(\"&lt;a>&lt;b>text1&lt;/b>&lt;c>text2&lt;/c>&lt;/b>&lt;/a>\") print(sibling_soup.prettify()) # &lt;html> # &lt;body> # &lt;a> # &lt;b> # text1 # &lt;/b> # &lt;c> # text2 # &lt;/c> # &lt;/a> # &lt;/body> # &lt;/html> 因为 &lt;b&gt; 标签和 &lt;c&gt; 标签是同一层：他们是同一个元素的子节点，所以 &lt;b&gt; 和 &lt;c&gt; 可以被称为兄弟节点。一段文档以标准格式输出时，兄弟节点有相同的缩进级别。在代码中也可以使用这种关系。 2.3.1 .next_sibling 和 .previous_sibling 在文档树中，使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点： sibling_soup.b.next_sibling # &lt;c>text2&lt;/c> sibling_soup.c.previous_sibling # &lt;b>text1&lt;/b> &lt;b&gt; 标签有 .next_sibling 属性，但是没有 .previous_sibling 属性，因为 &lt;b&gt; 标签在同级节点中是第一个。同理，&lt;c&gt; 标签有 .previous_sibling 属性，却没有 .next_sibling 属性： print(sibling_soup.b.previous_sibling) # None print(sibling_soup.c.next_sibling) # None 例子中的字符串“text1”和“text2”不是兄弟节点,因为它们的父节点不同： sibling_soup.b.string # u'text1' print(sibling_soup.b.string.next_sibling) # None 实际文档中的 tag 的 .next_sibling 和 .previous_sibling 属性通常是字符串或空白。 看看“爱丽丝”文档： &lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\">Elsie&lt;/a> &lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie&lt;/a> &lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie&lt;/a> 如果以为第一个 &lt;a&gt; 标签的 .next_sibling 结果是第二个 &lt;a&gt; 标签，那就错了，真实结果是第一个 &lt;a&gt; 标签和第二个 &lt;a&gt; 标签之间的顿号和换行符： link = soup.a link # &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie&lt;/a> link.next_sibling # u',\\n' 第二个 &lt;a&gt; 标签是顿号的 .next_sibling 属性： link.next_sibling.next_sibling # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie&lt;/a> 2.3.2 .next_siblings 和 .previous_siblings 通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出： for sibling in soup.a.next_siblings: print(repr(sibling)) # u',\\n' # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie&lt;/a> # u' and\\n' # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie&lt;/a> # u'; and they lived at the bottom of a well.' # None for sibling in soup.find(id=\"link3\").previous_siblings: print(repr(sibling)) # ' and\\n' # &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\">Lacie&lt;/a> # u',\\n' # &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\">Elsie&lt;/a> # u'Once upon a time there were three little sisters; and their names were\\n' # None 2.4 回退和前进 看一下“爱丽丝” 文档： &lt;html>&lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head> &lt;p class=\"title\">&lt;b>The Dormouse's story&lt;/b>&lt;/p> HTML 解析器把这段字符串转换成一连串的事件：“打开 &lt;html&gt; 标签”，”打开一个 &lt;head&gt; 标签”，”打开一个 &lt;title&gt; 标签”，”添加一段字符串”，”关闭 &lt;title&gt; 标签”，”打开 &lt;p&gt; 标签”，等等。Beautiful Soup 提供了重现解析器初始化过程的方法。 .next_element 和 .previous_element .next_element 属性指向解析过程中下一个被解析的对象(字符串或tag)，结果可能与 .next_sibling 相同，但通常是不一样的。 这是“爱丽丝”文档中最后一个 &lt;a&gt; 标签,它的 .next_sibling 结果是一个字符串，当前的解析过程因为遇到了 &lt;a&gt; 标签而中断了： last_a_tag = soup.find(\"a\", id=\"link3\") last_a_tag # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie&lt;/a> last_a_tag.next_sibling # '; and they lived at the bottom of a well.' 但这个 &lt;a&gt; 标签的 .next_element 属性结果是在 &lt;a&gt; 标签被解析之后的解析内容，不是 &lt;a&gt; 标签后的句子部分，应该是字符串”Tillie”： last_a_tag.next_element # u'Tillie' 这是因为在原始文档中，字符串“Tillie” 在分号前出现，解析器先进入 &lt;a&gt; 标签，然后是字符串“Tillie”，然后关闭 &lt;/a&gt; 标签，然后是分号和剩余部分。分号与 &lt;a&gt; 标签在同一层级，但是字符串“Tillie”会被先解析。 .previous_element 属性刚好与 .next_element 相反,它指向当前被解析的对象的前一个解析对象： last_a_tag.previous_element # u' and\\n' last_a_tag.previous_element.next_element # &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\">Tillie&lt;/a> .next_elements 和 .previous_elements 通过 .next_elements 和 .previous_elements 的迭代器就可以向前或向后访问文档的解析内容， 就好像文档正在被解析一样： for element in last_a_tag.next_elements: print(repr(element)) # u'Tillie' # u';\\nand they lived at the bottom of a well.' # u'\\n\\n' # &lt;p class=\"story\">...&lt;/p> # u'...' # u'\\n' # None","categories":[{"name":"学习杂文","slug":"学习杂文","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/"},{"name":"Python Libraries","slug":"学习杂文/Python-Libraries","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/Python-Libraries/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Beautiful Soup","slug":"Beautiful-Soup","permalink":"https://www.leolang.top/tags/Beautiful-Soup/"},{"name":"HTML","slug":"HTML","permalink":"https://www.leolang.top/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"https://www.leolang.top/tags/DOM/"},{"name":"Front-end","slug":"Front-end","permalink":"https://www.leolang.top/tags/Front-end/"}]},{"title":"PaddlePaddle 图像分割（二）语义分割初探","slug":"PaddlePaddle 图像分割（二）语义分割初探","date":"2021-11-13T16:00:00.000Z","updated":"2022-06-15T02:03:08.031Z","comments":true,"path":"2021/11/14/PaddlePaddle 图像分割（二）语义分割初探/","link":"","permalink":"https://www.leolang.top/2021/11/14/PaddlePaddle%20%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E5%88%9D%E6%8E%A2/","excerpt":"前言 本文将初步介绍语义分割相关内容，并给出两个使用 PaddlePaddle 实现的分割网络实例。","text":"前言 本文将初步介绍语义分割相关内容，并给出两个使用 PaddlePaddle 实现的分割网络实例。 PaddlePaddle 图像分割（二）语义分割初探 0 Reference 飞桨 AI Studio 图像分割7日打卡训练营 课节2 图像分割综述 1 语义分割初探 1.1 图像分割类型 What are different kinds of image segmentation tasks? 根据不同的任务和数据类型： 图像分割（Image Segmentation） 图像分割就是把图像分成若干个特定的、具有独特性质的区域并提出感兴趣目标的技术和过程。它是由图像处理到图像分析的关键步骤。现有的图像分割方法主要分以下几类：基于阈值的分割方法、基于区域的分割方法、基于边缘的分割方法以及基于特定理论的分割方法等。从数学角度来看，图像分割是将数字图像划分成互不相交的区域的过程。图像分割的过程也是一个标记过程，即把属于同一区域的像素赋予相同的编号。 -- From Baidu 图像分割 In digital image processing and computer vision, image segmentation is the process of partitioning a digital image into multiple segments (sets of pixels, also known as image objects). The goal of segmentation is to simplify and/or change the representation of an image into something that is more meaningful and easier to analyze. Image segmentation is typically used to locate objects and boundaries (lines, curves, etc.) in images. More precisely, image segmentation is the process of assigning a label to every pixel in an image such that pixels with the same label share certain characteristics. The result of image segmentation is a set of segments that collectively cover the entire image, or a set of contours extracted from the image (see edge detection). Each of the pixels in a region are similar with respect to some characteristic or computed property , such as color, intensity, or texture. Adjacent regions are significantly different color respect to the same characteristic(s). When applied to a stack of images, typical in medical imaging, the resulting contours after image segmentation can be used to create 3D reconstructions with the help of interpolation algorithms like marching cubes. -- From Wikipedia Image segmentation 图像语义分割（Image Semantic Segmentation） Image segmentation is a computer vision task in which we label specific regions of an image according to what's being shown. More specifically, the goal of semantic image segmentation is to label each pixel of an image with a corresponding class of what is being represented. -- From Blog An overview of semantic image segmentation. 图像实例分割（Image Instance Segmentation） 图像全景分割（Image Panoptic Segmentation） 视频目标分割（Video Object Segmentation） 视频实例分割（Video Instance Segmentation） image segmentation classification Picture from Panoptic Segmentation, Alexander Kirillov et al. , arxiv 1801.00868 1.2 图像分割的应用场景 根据不同的任务和数据类型： 人像分割 自动驾驶 医学图像 工业质检、分拣机器人 2 深度学习分割算法 2.1 语义分割算法的基本概念 2.1.1 根本目的 语义分割算法的根本目的：像素级分类 prediction and truth Picture from The One Hundred Layers Tiramisu: Fully Convolutional DenseNets for Semantic Segmentation, Simon Jegou et al, arxiv 1611.09326 2.1.2 基本流程 语义分割算法的基本流程： 输入：图像（RGB） 算法：深度学习模型 输出：分类结果（与输入大小一致的单通道图） 训练过程： 输入：image + label 前向：out = model (image) 计算损失：loss = loss_func (out, label) 反向：loss.backward() 更新权重：optimizer.minimize (loss) 2.1.3 性能指标 分割网络的评价指标：mIoU 和 mAcc mIoU: mean Intersection-over-Union mAcc: mean Accurary mAcc：Prediction 和 Ground Truth 对应位置的 “分类” 准确率 \\[ Acc=\\frac{\\sum\\text{Correct Pixel}}{\\sum\\text{Pixel}} \\] \\[ mAcc=\\sum Acc\\Big/n \\] mIoU：分割每一类别的交并比（IoU） \\[ IoU=\\frac{\\text{Area of Overlap}}{\\text{Area of Union}} \\] \\[ mIoU=\\sum IoU\\Big/\\text{kinds} \\] 3 Demo 3.1 Demo 1 basic_model.py Based on PaddlePaddle 1.8.x, Python 3.7, CPU. import paddle import paddle.fluid as fluid from paddle.fluid.dygraph import to_variable, Pool2D, Conv2D import numpy as np np.set_printoptions(precision=2) class BasicModel(fluid.dygraph.Layer): def __init__(self, num_classes=59): super(BasicModel, self).__init__() self.pool = Pool2D(pool_size=2, pool_stride=2) self.conv = Conv2D(num_channels=3, num_filters=num_classes, filter_size=1) def forward(self, inputs): x = self.pool(inputs) x = fluid.layers.interpolate(x, out_shape=inputs.shape[2::]) x = self.conv(x) return x def main(): place = paddle.fluid.CPUPlace() with fluid.dygraph.guard(place): model = BasicModel(num_classes=59) model.eval() # model.train() input_data = np.random.rand(1, 3, 8, 8).astype(np.float32) print('Input data shape', input_data.shape) input_data = to_variable(input_data) output_data = model(input_data) output_data = output_data.numpy() print('Output data shape:', output_data.shape) if __name__ == '__main__': main() Result: Input data shape (1, 3, 8, 8) Output data shape: (1, 59, 8, 8) 3.2 Demo 2 basic_dataloader.py Based on PaddlePaddle 1.8.x, Python 3.7, CPU. import os import random import numpy as np import cv2 import paddle.fluid as fluid class Transform(): def __init__(self, size=256): self.size = size def __call__(self, input, label): input = cv2.resize(input, (self.size, self.size), interpolation=cv2.INTER_LINEAR) label = cv2.resize(label, (self.size, self.size), interpolation=cv2.INTER_NEAREST) return input, label class BasicDataLoader(): def __init__(self, image_folder, image_list_file, transform=None, shuffle=True): self.image_folder = image_folder self.image_list_file = image_list_file self.transform = transform self.shuffle = shuffle self.data_list = self.read_list() def read_list(self): data_list = [] with open(self.image_list_file) as infile: for line in infile: data_path = os.path.join(self.image_folder, line.split()[0]) label_path = os.path.join(self.image_folder, line.split()[1]) data_list.append((data_path, label_path)) return data_list def preprocess(self, data, label): h, w, c = data.shape h_gt, w_gt = label.shape assert h == h_gt, \"Error\" assert w == w_gt, \"Error\" if self.transform: data, label = self.transform(data, label) label = label[:, :, np.newaxis] return data, label def __len__(self): return len(self.data_list) def __call__(self): for data_path, label_path in self.data_list: data = cv2.imread(data_path, cv2.IMREAD_COLOR) data = cv2.cvtColor(data, cv2.COLOR_BGR2RGB) label = cv2.imread(label_path, cv2.IMREAD_GRAYSCALE) print(data.shape, label.shape) data, label = self.preprocess(data, label) yield data, label def main(): batch_size = 5 place = fluid.CPUPlace() with fluid.dygraph.guard(place): transform = Transform(256) # TODO: craete BasicDataloder instance # image_folder=\"./dummy_data\" # image_list_file=\"./dummy_data/list.txt\" basic_dataloader = BasicDataLoader( image_folder='./dummy_data', image_list_file='./dummy_data/list.txt', transform=transform, shuffle=True ) # TODO: craete fluid.io.DataLoader instance dataloader = fluid.io.DataLoader.from_generator(capacity=1, use_multiprocess=False) # TODO: set sample generator for fluid dataloader dataloader.set_sample_generator(basic_dataloader, batch_size=batch_size, places=place) num_epoch = 2 for epoch in range(1, num_epoch+1): print(f'Epoch [&#123;epoch&#125;/&#123;num_epoch&#125;]:') for idx, (data, label) in enumerate(dataloader): print(f'Iter &#123;idx&#125;, Data shape: &#123;data.shape&#125;, Label shape: &#123;label.shape&#125;') if __name__ == \"__main__\": main() Result: Epoch [1/2]: (375, 500, 3) (375, 500) (333, 500, 3) (333, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) Iter 0, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (500, 338, 3) (500, 338) Iter 1, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (375, 500, 3) (375, 500) (374, 500, 3) (374, 500) (375, 500, 3) (375, 500) (371, 500, 3) (371, 500) (188, 312, 3) (188, 312) Iter 2, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (333, 500, 3) (333, 500) (375, 500, 3) (375, 500) (500, 375, 3) (500, 375) (500, 493, 3) (500, 493) (500, 375, 3) (500, 375) Iter 3, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (500, 375, 3) (500, 375) (351, 500, 3) (351, 500) (375, 500, 3) (375, 500) (333, 500, 3) (333, 500) (500, 457, 3) (500, 457) Iter 4, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (370, 500, 3) (370, 500) (333, 500, 3) (333, 500) (500, 414, 3) (500, 414) Iter 5, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (400, 500, 3) (400, 500) (400, 500, 3) (400, 500) (499, 264, 3) (499, 264) (332, 500, 3) (332, 500) (333, 500, 3) (333, 500) Iter 6, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (377, 500, 3) (377, 500) (500, 375, 3) (500, 375) (466, 500, 3) (466, 500) (500, 375, 3) (500, 375) (400, 500, 3) (400, 500) Iter 7, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (357, 500, 3) (357, 500) (333, 500, 3) (333, 500) (375, 500, 3) (375, 500) (500, 457, 3) (500, 457) (500, 411, 3) (500, 411) Iter 8, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (500, 258, 3) (500, 258) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (333, 500, 3) (333, 500) (400, 500, 3) (400, 500) Iter 9, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] Epoch [2/2]: (375, 500, 3) (375, 500) (333, 500, 3) (333, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) Iter 0, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (500, 338, 3) (500, 338) Iter 1, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (375, 500, 3) (375, 500) (374, 500, 3) (374, 500) (375, 500, 3) (375, 500) (371, 500, 3) (371, 500) (188, 312, 3) (188, 312) Iter 2, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (333, 500, 3) (333, 500) (375, 500, 3) (375, 500) (500, 375, 3) (500, 375) (500, 493, 3) (500, 493) (500, 375, 3) (500, 375) Iter 3, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (500, 375, 3) (500, 375) (351, 500, 3) (351, 500) (375, 500, 3) (375, 500) (333, 500, 3) (333, 500) (500, 457, 3) (500, 457) Iter 4, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (370, 500, 3) (370, 500) (333, 500, 3) (333, 500) (500, 414, 3) (500, 414) Iter 5, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (400, 500, 3) (400, 500) (400, 500, 3) (400, 500) (499, 264, 3) (499, 264) (332, 500, 3) (332, 500) (333, 500, 3) (333, 500) Iter 6, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (377, 500, 3) (377, 500) (500, 375, 3) (500, 375) (466, 500, 3) (466, 500) (500, 375, 3) (500, 375) (400, 500, 3) (400, 500) Iter 7, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (357, 500, 3) (357, 500) (333, 500, 3) (333, 500) (375, 500, 3) (375, 500) (500, 457, 3) (500, 457) (500, 411, 3) (500, 411) Iter 8, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] (500, 258, 3) (500, 258) (375, 500, 3) (375, 500) (375, 500, 3) (375, 500) (333, 500, 3) (333, 500) (400, 500, 3) (400, 500) Iter 9, Data shape: [5, 256, 256, 3], Label shape: [5, 256, 256, 1] 4 API 链接 opencv： OpenCV: OpenCV Tutorials OpenCV: OpenCV-Python Tutorials","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.leolang.top/categories/Deep-Learning/"},{"name":"Image Segmentation","slug":"Deep-Learning/Image-Segmentation","permalink":"https://www.leolang.top/categories/Deep-Learning/Image-Segmentation/"},{"name":"PaddlePaddle","slug":"Deep-Learning/Image-Segmentation/PaddlePaddle","permalink":"https://www.leolang.top/categories/Deep-Learning/Image-Segmentation/PaddlePaddle/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.leolang.top/tags/Deep-Learning/"},{"name":"AI","slug":"AI","permalink":"https://www.leolang.top/tags/AI/"},{"name":"PaddlePaddle","slug":"PaddlePaddle","permalink":"https://www.leolang.top/tags/PaddlePaddle/"},{"name":"Image Segmentation","slug":"Image-Segmentation","permalink":"https://www.leolang.top/tags/Image-Segmentation/"}]},{"title":"PaddlePaddle 图像分割（一）基础内容","slug":"PaddlePaddle 图像分割（一）","date":"2021-11-09T16:00:00.000Z","updated":"2021-11-10T13:32:56.000Z","comments":true,"path":"2021/11/10/PaddlePaddle 图像分割（一）/","link":"","permalink":"https://www.leolang.top/2021/11/10/PaddlePaddle%20%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"前言 从本文开始，参照百度飞桨相关课程，将会介绍有关 PaddlePaddle 框架实现深度学习图像分割的相关内容。 本文将介绍有关 PaddlePaddle 框架的相关基础内容。","text":"前言 从本文开始，参照百度飞桨相关课程，将会介绍有关 PaddlePaddle 框架实现深度学习图像分割的相关内容。 本文将介绍有关 PaddlePaddle 框架的相关基础内容。 PaddlePaddle 图像分割（一）基础内容 0 Reference 飞桨——图像分割7日训练营 1 预备数学知识 Reference：《Deep Learning》By lan Goodfellow, et al. 注：此处并不全面，后续章节中还会做补充。 1.1 线性代数 1.1.1 标量、向量、矩阵、张量 注：此处涉及到的符号可能与后续的符号不同，请注意。 标量（scalar） 一个标量是一个单独的数。我们用斜体表示标量。标量通常被赋予小写的变量名称。在介绍标量时，我们会明确它们是哪种类型的数。比如，定义实数标量：令 \\(s\\in\\mathbb R\\) 表示一条线的斜率；定义自然数标量：令 \\(n\\in\\mathbb N\\) 表示元素的数目。 向量（vector） 向量是一列数。这些数是有序排列的。通过次序中的索引，我们可以确定每个单独的数。通常赋予向量粗体的小写变量名称，比如 \\(\\boldsymbol x\\) 。向量中的元素可以通过带脚标的斜体表示。向量 \\(\\boldsymbol x\\) 的元素是 \\(x_1,x_2,\\cdots\\) 。我们也会注明存储在向量中的元素是是什么类型的。如果每个元素都属于 \\(\\mathbb R\\) ，并且该向量有 \\(n\\) 个元素，那么该向量属于实数集 \\(\\mathbb R\\) 的 \\(n\\) 次笛卡尔乘积构成的集合，记为 \\(\\mathbb R^n\\) 。当需要明确表示向量中的元素时，我们会将元素排列成一个方括号包围的序列： \\[ \\boldsymbol x= \\begin{bmatrix} x_1\\\\x_2\\\\\\vdots\\\\x_n \\end{bmatrix} \\] 我们可以把向量看作空间中的点，每个元素是不同坐标轴上的坐标。 有时我们需要索引向量中的一些元素。这时，定义一个包含这些索引的集合，然后将该集合写在脚标处。比如，指定 \\(x_1,x_3,x_6\\) ，定义集合 \\(S=\\{1,3,6\\}\\) ，然后写作 \\(\\boldsymbol x_S\\) 。我们用符号 \\(-\\) 表示集合的补集中的索引，即 \\(-S=C\\backslash S,\\ C=\\{1,2,3,\\cdots,n\\}\\) 。如上例中 \\(\\boldsymbol x_{-S}\\) 表示除 \\(x_1,x_3,x_6\\) 的元素构成的向量。 矩阵（matrix） 矩阵是一个二维数组，每个元素都由两个索引确定。我们通常赋予矩阵粗体的大写变量名称，比如 \\(\\boldsymbol A\\) 。如果一个实数矩阵高度为 \\(m\\) ，宽度为 \\(n\\) ，那么我们说 \\(\\boldsymbol A\\in\\mathbb R^{m\\times n}\\) 。在表示矩阵中元素时，通常以不加粗的斜体形式使用其名称，索引用逗号间隔。比如，\\(A_{1,1}\\) 表示 \\(\\boldsymbol A\\) 左上的元素，\\(A_{m,n}\\) 表示 \\(\\boldsymbol A\\) 右下角的元素。用 \\(:\\) 表示省略某一索引，而表示一整行或一整列的元素。如 \\(\\boldsymbol A_{i,:}\\) 表示 \\(\\boldsymbol A\\) 的第 \\(i\\) 行（row）。同样的，\\(\\boldsymbol A_{:,j}\\) 表示 \\(\\boldsymbol A\\) 的第 \\(j\\) 列（column）。当需要明确矩阵中的元素时，我们将他们写在用方括号括起来的数组中： \\[ \\begin{bmatrix} A_{1,1} &amp; A_{1,2}\\\\ A_{2,1} &amp; A_{2,2}\\\\ \\end{bmatrix} \\] 有时我们需要矩阵值表达式的索引，而不是单个元素。在这种情况下，我们在表达式后面接下标，但不必将矩阵的变量名称小写化。比如，\\(f(\\boldsymbol A)_{i,j}\\) 表示函数 \\(f\\) 作用在 \\(\\boldsymbol A\\) 上输出的矩阵的第 \\(i\\) 行和第 \\(j\\) 列元素。 张量（tensor） 在某些情况下，我们会讨论坐标超过两维的数组。一般的，一个数组中的元素分布在若干维坐标的规则网络中，我们称之为张量。我们使用字体 \\(\\sf A\\) 来表示张量 “A” 。张量 \\(\\sf A\\) 中坐标为 \\((i,j,k)\\) 的元素记作 \\(\\rm {A}_\\it{i,j,k}\\) 。 2 PaddlePaddle 基础命令 在PaddlePaddle中，计算的对象是张量，我们可以先使用PaddlePaddle来计算一个 \\([[1, 1], [1, 1]] * [[1, 1], [1, 1]]\\) 。 2.1 计算常量的加法：\\(1+1\\) 首先，导入 PaddlePaddle 库。 import paddle.fluid as fluid 定义两个张量的常量 \\(x_1,x_2\\) ，并指定他们的形状是 \\(2\\times2\\) ，并赋值为 \\(1\\) 铺满整个张量，类型为 int64 。 x1 = fluid.layers.fill_constant(shape=[2, 2], value=1, dtype='int64') x2 = fluid.layers.fill_constant(shape=[2, 2], value=1, dtype='int64') 接着定义一个运算，该计算是将上面两个张量进行加法运算，并返回一个求和的算子。 y1 = fluid.layers.sum(x=[x1, x2]) PaddlePaddle提供的大量的操作，可以在 fluid.layers 里找到。官方API链接 然后创建一个解释器，这里可以指定使用CPU还是GPU。当使用 CPUPlace() 时使用的是CPU，如果是 CUDAPlace() 使用的是GPU。解析器是之后使用它来进行计算过的，比如在执行计算之前我们要先执行参数初始化的program也是要使用到解析器的，因为只有解析器才能执行program。 # Create a interpreter, using CPU place = fluid.CPUPlace() exe = fluid.executor.Executor(place) # Or using GPU, write as: place = fluid.CUDAPlace() ... # 参数初始化 exe.run(fluid.default_startup_program()) 最后，执行计算。参数 program 是主程序，不是上一步使用的初始化参数的程序。program 默认有两个，分别是 default_startup_program() 和 default_main_program() 。fetch_list 参数的值是在解析器 run 之后要输出的值，我们输出加法计算之后的结果值。最后得到的也是一个张量。 result = exe.run(program=default_main_program(), fetch_list=[y1]) print(result) 结果为： [array([[2, 2], [2, 2]], dtype=int64)] 2.2 计算变量的加法：\\(1+1\\) 上面计算的是常量张量的 \\(1+1\\) ，但常量并不能随意的修改值。下面要编写一个使用张量变量作为乘数的程序。 首先导入 PaddlePaddle 和 NumPy 。 import paddle.fluid as fluid import numpy as np 下面定义两个张量，但并不指定张量的形状和值，他们之后是动态赋值的。这里只是指定张量的类型和名字，这个名字是后续赋值的关键。 a = fluid.layers.create_tensor(dtype='int64', name='a') b = fluid.layers.create_tensor(dtype='int64', name='b') 使用同样的方式，定义两个张量的加法操作。 y = fluid.layers.sum(x=[a, b]) 同样的，创建一个使用CPU的解释器，并进行参数初始化。 place = fluid.CPUPlace() exe = fluid.executor.Executor(place) exe.run(default_startup_program()) 然后使用 NumPy 创建两个张量值，之后要计算的就是这两个张量的值。 a1 = np.array([3, 2]).astype('int64') b1 = np.array([1, 1]).astype('int64') 仍使用 exe.run() ，但这次多了一个参数 feed ，使用该参数对张量变量进行赋值。赋值的方式采用键值对方式，即字典。其中 key 是定义张量变量指定的名称，value 是要传递的值，即格式为： &#123;'name1': tensor1.value, 'name2': tensor2.value, ...&#125; 计算的程序如下： out_a, out_b, result = exe.run(program=default_main_program, feed=&#123;'a': a1, 'b': b1&#125;, fetch_list=[a, b, y]) print(out_a, \"+\", out_b, \"=\", result) 计算结果为： [3 2] + [1 1] = [4 3] 3 使用 PaddlePaddle 做线性回归 首先导入 PaddlePaddle 库和一些工具类库。 import paddle.fluid as fluid import paddle import numpy as np 定义一个简单的线性网络，这个网络非常简单，结构是：输出层 \\(\\to\\) 隐含层 \\(\\to\\) 输出层。这个网络共有两层，因为输入层不算网络的层数。更具体的就是一个大小 \\(100\\) ，激活函数是 \\(ReLU\\) 的全连接层和一个输出大小为 \\(1\\) 的输出层，就构建了一个非常简单的网络。这里使用输入 fluid.layers.data() 定义的输入层类似的 fluid.layers.create_tensor() ，也有 name 属性，之后也是根据这个属性来填充数据的。这里定义输入层的形状为 \\(13\\) ，这是因为波士顿房价数据集的每条数据有 \\(13\\) 个属性，我们之后自定义的数据集也是为了符合这一个维度。 # Define a simple linear network x = fluid.layers.data(name='x', shape=[13], dtype='float32') hidden = fluid.layers.fc(input='x', size=100, act='relu') net = fluid.layers.fc(input='hidden', size=1, act=None) 接着定义神经网络的损失函数，这里同样使用 fluid.layers.data() 这个接口，这个可以理解为数据对应的结果，上面是 name 为 x 的 fluid.layers.data() 为属性数据。这里使用了平方差损失函数 square_error_cost() 。PaddlePaddle 提供了非常多损失函数的接口，比如交叉熵损失函数 cross_entropy() 。因为本项目是一个线性回归任务，所以我们使用平方差损失函数。因为 fluid.layers.square_error_cost() 求的是一个 Batch 的损失值，所以我们还要对他求一个平均值。 Batch：在深度学习中指的是计算一次 cost 需要的输入数据个数 # Define a loss function y = fluid.layers.data(name='y', shape=[1], dtype='float32') cost = fluid.layers.square_error_cost(input=net, label=y) avg_cost = fluid.layers.mean(cost) 定义损失函数之后，可以在主程序 fluid.default_main_program() 中克隆一个程序作为预测程序，用于训练完成之后使用这个预测程序进行预测数据。这个定义的顺序不能错，因为我们定义的网络结构，损失函数等等都是更加顺序记录到 PaddlePaddle 的主程序中的。主程序中定义了神经网络模型，前向反向计算，以及优化算法对网络中可学习参数的更新，是我们整个程序的核心，这个是 PaddlePaddle 已经帮我们都实现了，我们只需注重网络的构建和训练即可。 # 复制一个主程序，方便之后使用 test_program = fluid.default_main_program().clone(for_test=True) 接着是定义训练使用的优化方法，这里使用的是随机梯度下降优化方法。PaddlePaddle 提供了大量的函数接口，除了本项目使用的随机梯度下降法（SGD），还有 Momentum、Adagrad 等等，可以根据项目的需要选择不同的优化方法。 # Define optimization method optimizer = fluid.optimizer.SGDOptimizer(learning_rate=0.1) opts = optimizer.minimize(avg_cost) 然后创建一个解析器，同样的也是使用 CPU 进行训练。创建解析器之后，使用解析器执行 fluid.default_startup_program() 初始化参数。 # Create a interpreter, using CPU place = fluid.CPUPlace() exe = fluid.Executor(place) # Do parameters initialization exe.run(fluid.default_startup_program()) 我们使用 NumPy 定义一组数据，这组数据的每一条数据有 \\(13\\) 个，这是因为我们在定义网络的输入层时，shape 是 \\(13\\) ，但是每条数据的后面 \\(12\\) 个数据是没意义的，因为笔者全部都是使用 \\(0\\) 来填充，纯粹是为了符合数据的格式而已。这组数据是符合 \\(\\boldsymbol y= 2\\boldsymbol x+1\\) ，但是程序是不知道的，我们之后使用这组数据进行训练，看看强大的神经网络是否能够训练出一个拟合这个函数的模型。最后定义了一个预测数据，是在训练完成，使用这个数据作为 \\(\\boldsymbol x\\) 输入，看是否能够预测于正确值相近结果。 # Define train data and test data x_data = np.array([[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [4.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]).astype('float32') y_data = np.array([[3.0], [5.0], [7.0], [9.0], [11.0]]).astype('float32') test_data = np.array([[6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]).astype('float32') 定义数据之后，就可以开始训练了。下面训练了 \\(10\\) 个 pass ，可根据实际情况设置更多的训练轮数，通常情况下训练的次数越多，模型收敛的越好。与上一部分中提到的一致，使用的 program 为 fluid.default_main_program() ，通过 feed 参数在训练时将数据传入以 fluid.layers.data() 定义的变量中，同样的是以键值对的形式传入。我们让训练中输出 avg_cost 的值。 # Train 10 passes for pass_id in range(10): train_cost = exe.run(program=fluid.default_main_program(), feed=&#123;'x': x_data, 'y': y_data&#125;, fetch_list=[avg_cost]) print(\"Pass: %d, Cost: %0.5f\" % (pass_id, train_cost)) Train result: Pass:0, Cost:58.30626 Pass:1, Cost:15.85328 Pass:2, Cost:2.01109 Pass:3, Cost:0.04987 Pass:4, Cost:0.03438 Pass:5, Cost:0.03362 Pass:6, Cost:0.03291 Pass:7, Cost:0.03221 Pass:8, Cost:0.03153 Pass:9, Cost:0.03086 训练完成之后，我们使用上面克隆主程序得到的预测程序了预测我们刚才定义的预测数据。预测数据同样作为 \\(\\boldsymbol x\\) 在 feed 输入，在预测时，理论上是不用输入 \\(\\boldsymbol y\\) 的，但是要符合输入格式，我们模拟一个 \\(\\boldsymbol y\\) 的数据值，这个值并不会影响我们的预测结果。fetch_list 的值，也就是我们执行预测之后要输出的结果，这是网络的最后一层，而不是平均损失函数（avg_cost），因为我们是想要预测程序输出预测结果。根据我们上面定义数据时，满足规律 \\(\\boldsymbol y=2\\boldsymbol x+1\\) ，所以当 \\(x\\) 为 \\(6\\) 时，\\(y\\) 应该是 \\(13\\) （此处的 \\(x,y\\) 代指向量中的第一项，即 \\(x_1,y_1\\) ），最后输出的结果也是应该接近 \\(13\\) 的。 # Start prediction result = exe.run(program=test_program, feed=&#123;'x': test_data, 'y': np.array([[0.0]]).astype('float32')&#125;, fetch_list=[net]) print(\"当x为6.0时，y为：%0.5f\" % result[0][0][0]) 结果为： 当x为6.0时，y为：13.26833 4 用 PaddlePaddle 做房价预测 4.1 准备数据 uci-housing 数据集 数据集共 \\(506\\) 行，每行 \\(14\\) 列。前 \\(13\\) 列用来描述房屋的各种信息，最后一列为该类房屋价格中位数。 PaddlePaddle 提供了读取 uci_housing 训练集和测试集的接口，分别为 paddle.dataset.uci_housing.train() 和paddle.dataset.uci_housing.test() 。 train_reader 和 test_reader paddle.reader.shuffle() 表示每次缓存 BUF_SIZE 个数据项，并进行打乱 paddle.batch() 表示每 BATCH_SIZE 组成一个 batch # import lib. import paddle.fluid as fluid import paddle import numpy as np import os BUF_SIZE = 500 BATCH_SIZE = 20 # 用于训练的数据提供器，每次从缓存中随机读取批次大小的数据 train_reader = paddle.batch( paddle.reader.shuffle(paddle.dataset.uci_housing.train(), buf_size=BUF_SIZE), batch_size=BATCH_SIZE) # 用于测试的数据提供器，每次从缓存中随机读取批次大小的数据 test_reader = paddle.batch( paddle.reader.shuffle(paddle.dataset.uci_housing.test(), buf_size=BUF_SIZE), batch_size=BATCH_SIZE) 打印查看 uci-housing 数据 # 用于打印，查看uci_housing数据 train_data = paddle.dataset.uci_housing.train(); sampledata = next(train_data()) print(sampledata) result： (array([-0.0405441 , 0.06636364, -0.32356227, -0.06916996, -0.03435197, 0.05563625, -0.03475696, 0.02682186, -0.37171335, -0.21419304, -0.33569506, 0.10143217, -0.21172912]), array([24.])) 4.2 网络配置 4.2.1 网络搭建 对于线性回归来讲，它就是一个从输入到输出的简单的全连接层。 对于波士顿房价的数据集，假设房价可以被属性间的线性组合所描述，即如下形式： \\[ \\Large z=a_1w_1+\\cdots+a_kw_k+\\cdots+a_nw_n+b \\] 搭建的网络如下图： img # 定义张量变量x，表示13维的特征值 x = fluid.layers.data(name='x', shape=[13], dtype='float32') # 定义张量y，表示目标值 y = fluid.layers.data(name='y', shape=[1], dtype='float32') # 定义一个简单的线性网络，连接输入和输出的全连接层 # :param input: 输入的tensor # :param size: 该层输出单元的数目 # :param act: 激活函数 y_predict = fluid.layers.fc(input=x, size=1, act=None) 4.2.2 定义损失函数 由于是线性关系的线性回归问题，所以使用均方差损失函数 square_error_cost(input, label) 。 定义损失函数如下： cost = fluid.layers.square_error_cost(input=y_predict, label=y) # 求一个batch的损失值 avg_cost = fluid.layers.mean(cost) # 对损失值求平均值 对于 square_error_cost(input, label) 的解释（摘自 square_error_cost-API文档-PaddlePaddle深度学习平台）: 源代码 链接：Paddle/loss.py at release/1.8 · PaddlePaddle/Paddle · GitHub def square_error_cost(input, label): \"\"\" This op accepts input predictions and target label and returns the squared error cost. For predictions label, and target label, the equation is: .. math:: Out = (input - label)^2 Parameters: input (Variable): Input tensor, the data type should be float32. label (Variable): Label tensor, the data type should be float32. Returns: The tensor variable storing the element-wise squared error \\ difference between input and label. Return type: Variable. Examples: .. code-block:: python # declarative mode import paddle.fluid as fluid import numpy as np input = fluid.data(name=\"input\", shape=[1]) label = fluid.data(name=\"label\", shape=[1]) output = fluid.layers.square_error_cost(input,label) place = fluid.CPUPlace() exe = fluid.Executor(place) exe.run(fluid.default_startup_program()) input_data = np.array([1.5]).astype(\"float32\") label_data = np.array([1.7]).astype(\"float32\") output_data = exe.run(fluid.default_main_program(), feed=&#123;\"input\":input_data, \"label\":label_data&#125;, fetch_list=[output], return_numpy=True) print(output_data) # [array([0.04000002], dtype=float32)] # imperative mode import paddle.fluid.dygraph as dg with dg.guard(place) as g: input = dg.to_variable(input_data) label = dg.to_variable(label_data) output = fluid.layers.square_error_cost(input, label) print(output.numpy()) # [0.04000002] \"\"\" check_variable_and_dtype(input, \"input\", ['float32', 'float64'], 'square_error_cost') check_variable_and_dtype(label, \"label\", ['float32', 'float64'], 'square_error_cost') helper = LayerHelper('square_error_cost', **locals()) minus_out = helper.create_variable_for_type_inference(dtype=input.dtype) helper.append_op( type='elementwise_sub', inputs=&#123;'X': [input], 'Y': [label]&#125;, outputs=&#123;'Out': [minus_out]&#125;) square_out = helper.create_variable_for_type_inference(dtype=input.dtype) helper.append_op( type='square', inputs=&#123;'X': [minus_out]&#125;, outputs=&#123;'Out': [square_out]&#125;) return square_out 该OP用于计算预测值和目标值的方差估计。 对于预测值 \\(input\\) 和目标值 \\(label\\) ，公式为： \\[ Out=(input-label)^2 \\] 参数 input (Variable) - 预测值，维度为 \\([N_1,N_2,\\cdots,N_k,D]\\) 的多维 Tensor，其中最后一维 \\(D\\) 是类别数目。数据类型为 float32 或 float64 。 label (Variable) - 目标值，维度为 \\([N_1,N_2,\\cdots,N_k,D]\\) 的多维 Tensor，其中最后一维 \\(D\\) 是类别数目。数据类型为 float32 或 float64 。 返回 预测值和目标值的方差。 返回类型 变量（Variable） 代码示例 import paddle.fluid as fluid y = fluid.layers.data(name='y', shape=[1], dtype='float32') y_predict = fluid.layers.data(name='y_predict', shape=[1], dtype='float32') cost = fluid.layers.square_error_cost(input=y_predict, label、=y) 4.2.3 定义优化函数 此处使用随机梯度下降法。 optimizer = fluid.optimizer.SGDOptimizer(learning_rate=0.001) opts = optimizer.minimize(avg_cost) test_program = fluid.default_main_program().clone(for_test=True) 在上述模型配置完毕后，得到两个 fluid.Program ：fluid.default_startup_program() 与 fluid.default_main_program() 。 参数初始化操作会被写入 fluid.default_startup_program() fluid.default_main_program() 用于获取默认或全局 main program （主程序）。该主程序用于训练和测试模型。 fluid.layers 中的所有 layer 函数可以向 default_main_program 中添加算子和变量。 default_main_program 是 fluid 的许多编程接口（API）的Program 参数的缺省值。例如，当用户 program 没有传入的时候，Executor.run() 会默认执行 default_main_program 。 4.3 模型训练与模型评估 4.3.1 创建 Executor 首先定义运算场所，fluid.CPUPlace() 和 fluid.CUDAPlace(0) 分别代表了使用 CPU 和使用 GPU。 Executor() 接收传入的 program ，通过调用 run() 方法运行传入的 program 。 use_cuda = False place = fluid.CUDAPlace(0) if use_cuda else fluid.CPUPlace() exe = fluid.Executor(place) # 创建一个Executor实例exe exe.run(fluid.default_startup_program()) # Executor的run()方法执行startup_program()，进行参数初始化 4.3.2 定义输入数据维度 DataFeeder() 负责将数据提供器（train_reader, test_reader）返回的数据转成一种特殊的数据结构，使其可以输入到 Executor 中。 feed_list 设置向模型输入的变量表或者变量表名。 # 定义输入数据维度 feeder = fluid.DataFeeder(place=place, feed_list=[x, y]) 4.3.3 定义绘制训练过程中损失值变化趋势的方法 import matplotlib.pyplot as plt %matplotlib inline iter = 0; iters = [] train_costs = [] def draw_train_process(iters, train_costs): title=\"training cost\" plt.title(title, fontsize=24) plt.xlabel(\"iter\", fontsize=14) plt.ylabel(\"cost\", fontsize=14) plt.plot(iters, train_costs, color='red', label='training cost') plt.grid() plt.show() 4.3.4 训练并保存模型 Executor 接收传入的 program ，并根据 feed map（输入映射表）和 fetch_list （结果获取表）向 program 中添加 feed operators（数据输入算子）和 fetch operators（结果获取算子）。 feed map为该 program 提供输入数据。fetch_list 提供 program 训练结束后用户预期的变量。 EPOCH_NUM = 50 model_save_dir = \"/home/aistudio/work/fit_a_line.inference.model\" for pass_id in range(EPOCH_NUM): # 训练EPOCH_NUM轮 # 开始训练并输出最后一个batch的损失值 train_cost = 0 for batch_id, data in enumerate(train_reader()): # 遍历train_reader迭代器 train_cost = exe.run(program=fluid.default_main_program(), # 运行主程序 feed=feeder.feed(data), fetch_list=[avg_cost]) if batch_id % 40 == 0: print(\"Pass:%d, Cost:%0.5f\" % (pass_id, train_cost[0][0])) # 打印最后一个batch的损失值 iter += BATCH_SIZE iters.append(iter) train_costs.append(train_cost[0][0]) # 开始测试并输出最后一个batch的损失值 test_cost = 0 for batch_id, data in enumerate(test_reader()): # 遍历test_reader迭代器 test_cost= exe.run(program=test_program, feed=feeder.feed(data), # 喂入一个batch的测试数据 fetch_list=[avg_cost]) # fetch均方误差 print('Test:%d, Cost:%0.5f' % (pass_id, test_cost[0][0])) # 打印最后一个batch的损失值 # 保存模型 # 如果保存路径不存在就创建 if not os.path.exists(model_save_dir): os.makedirs(model_save_dir) print ('save models to %s' % (model_save_dir)) # 保存训练参数到指定路径中，构建一个专门用预测的program fluid.io.save_inference_model(model_save_dir, # 保存推理model的路径 ['x'], # 推理（inference）需要 feed 的数据 [y_predict], # 保存推理（inference）结果的 Variables exe) # exe 保存 inference model draw_train_process(iters,train_costs) Result: img 4.4 模型预测 4.4.1 创建预测使用的 Executor infer_exe = fluid.Executor(place) inference_scope = fluid.core.Scope() # Scope指定作用域 4.4.2 可视化真实值与预测值方法定义 infer_results = [] groud_truths = [] # 绘制真实值和预测值对比图 def draw_infer_result(groud_truths, infer_results): title = 'Boston' plt.title(title, fontsize=24) x = np.arange(1,20) y = x plt.plot(x, y) plt.xlabel('ground truth', fontsize=14) plt.ylabel('infer result', fontsize=14) plt.scatter(groud_truths, infer_results, color='green', label='training cost') plt.grid() plt.show() 4.4.3 开始预测 通过 fluid.io.load_inference_model ，预测器会从 params_dirname 中读取已经训练好的模型，来对从未遇见过的数据进行预测。 with fluid.scope_guard(inference_scope): # 修改全局/默认作用域（scope）, 运行时中的所有变量都将分配给新的scope。 # 从指定目录中加载 推理model(inference model) [inference_program, # 推理的program feed_target_names, # 需要在推理program中提供数据的变量名称 fetch_targets] = fluid.io.load_inference_model( # fetch_targets: 推断结果 model_save_dir, # model_save_dir:模型训练路径 infer_exe) # infer_exe: 预测用executor # 获取预测数据 infer_reader = paddle.batch(paddle.dataset.uci_housing.test(), # 获取uci_housing的测试数据 batch_size=200) # 从测试数据中读取一个大小为200的batch数据 # 从test_reader中分割x test_data = next(infer_reader()) test_x = np.array([data[0] for data in test_data]).astype(\"float32\") test_y = np.array([data[1] for data in test_data]).astype(\"float32\") results = infer_exe.run(inference_program, # 预测模型 feed=&#123;feed_target_names[0]: np.array(test_x)&#125;, # 喂入要预测的x值 fetch_list=fetch_targets) # 得到推测结果 print(\"infer results: (House Price)\") for idx, val in enumerate(results[0]): print(\"%d: %.2f\" % (idx, val)) infer_results.append(val) print(\"ground truth:\") for idx, val in enumerate(test_y): print(\"%d: %.2f\" % (idx, val)) groud_truths.append(val) draw_infer_result(groud_truths,infer_results) Result: img","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.leolang.top/categories/Deep-Learning/"},{"name":"Image Segmentation","slug":"Deep-Learning/Image-Segmentation","permalink":"https://www.leolang.top/categories/Deep-Learning/Image-Segmentation/"},{"name":"PaddlePaddle","slug":"Deep-Learning/Image-Segmentation/PaddlePaddle","permalink":"https://www.leolang.top/categories/Deep-Learning/Image-Segmentation/PaddlePaddle/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.leolang.top/tags/Deep-Learning/"},{"name":"AI","slug":"AI","permalink":"https://www.leolang.top/tags/AI/"},{"name":"PaddlePaddle","slug":"PaddlePaddle","permalink":"https://www.leolang.top/tags/PaddlePaddle/"},{"name":"Image Segmentation","slug":"Image-Segmentation","permalink":"https://www.leolang.top/tags/Image-Segmentation/"}]},{"title":"板子合集","slug":"板子合集","date":"2021-09-16T16:00:00.000Z","updated":"2021-12-01T14:50:56.000Z","comments":true,"path":"2021/09/17/板子合集/","link":"","permalink":"https://www.leolang.top/2021/09/17/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/","excerpt":"前言 板子合集帖，持续更新……","text":"前言 板子合集帖，持续更新…… 板子合集 快速排序 void quick_sort(int q[], int l, int r) &#123; if (l >= r) return; int x = q[l + r >> 1]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] > x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j); quick_sort(q, j + 1, r); &#125; 归并排序 int temp[N]; void merge_sort(int q[], int l, int r) &#123; if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) temp[k++] = q[i++]; else temp[k++] = q[i++]; while (i &lt;= mid) temp[k++] = q[i++]; while (j &lt;= r) temp[k++] = q[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j]; &#125; 二分 int bsearch(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r >> 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l; &#125; int bsearch(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r + 1 >> 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l; &#125; 高精度 vector&lt;int> add(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123; if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(1); return C; &#125; bool cmp(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; if (A.size() != B.size()) return A.size() > B.size(); for (int i = A.size() - 1; i >= 0; i--) &#123; if (A[i] != B[i]) return A[i] > B[i]; &#125; return true; &#125; vector&lt;int> sub(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size(); i++) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125; if (cmp(A, B)) &#123; auto C = sub(A, B); /* output C */ &#125; else &#123; auto C = sub(B, A); printf(\"-\"); /* output C */ &#125; vector&lt;int> mul(vector&lt;int> A, const int b) &#123; if (b == 0) return &#123;0&#125;; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size() || t; i++) &#123; t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; return C; &#125; vector&lt;int> div(vector&lt;int>, const int b, int &amp;r) &#123; vector&lt;int> C； r = 0; for (int i = A.size() - 1; i >= 0; i--) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125; 前缀和与差分 s[0] = 0; for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); res = s[r] - s[l - 1]; for (int i = 1; i &lt;= n; i++) &#123; for (int = j = 1; j &lt;= m; j++) &#123; s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; &#125; &#125; int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; void insert(int l, int r, int c) &#123; b[l] += c; b[r + 1] -= c; &#125; for (int i = 1, i &lt;= n; i++) insert(i, i, a[i]); while (m--) &#123; int l, r, c; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; b[0] = 0; for (int i = 1; i &lt;= n; i++) b[i] += b[i - 1]; /* output array b[] */ void insert(int x1, int y1, int x2, int y2, int c) &#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; insert(i, j, i, j, a[i][j]); &#125; &#125; while (q--) &#123; int x1, y1, x2, y2, c; cin >> x1 >> y1 >> x2 >> y2 >> c; insert(x1, y1, x2, y2, c); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; &#125; &#125; /* output matrix b[][] */ 位运算 n >> k &amp; 1; // n的二进制表示的第k位 x &amp; -x; // lowbit 最后一位1及其之后的部分 离散化 vector&lt;int> alls; sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); int find(int x, vector&lt;int> &amp;alls) &#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; &#125; return r; // list map to 0, 1, ..., n-1 /** or write as return r + 1; // list map to 1, 2, ..., n */ &#125; KMP /** * Defination for KMP * int n, m; // length of String, n for P, m for S * char p[N], s[M]; // two String * int ne[N]; //array next */ // get array next for (int i = 2, j = 0; i &lt;= n; i++) &#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; &#125; // KMP matching for (int i = 1, j = 0; i &lt;= m; i++) &#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // back to the location where may match if (s[i] == p[j + 1]) j++; // if this location matches? if (j == n) &#123; // matching succeed printf(\"%d\", i - n); j = ne[j]; &#125; &#125; Trie int son[N][26]; // 存储每个节点的儿子，最大维度是26个字母就是26，维度可变，等于共有多少种字符可能 int cnt[N]; // 存储以当前节点为结尾的单词有多少个 int idx; //存储当前节点是谁（编号） void insert(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++; &#125; int query(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p]; &#125; 并查集 int p[N]; // store the father of each node for (int i = 1; i &lt;= n; i++) p[i] = i; // set each node a leaf node int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; p[find(a)] = find(b); find(a) == find(b) ? Heap int h[N]; //heap int cnt = n; for (int i = n / 2; i; i--) down(i); int x; // recieve the value to insert h[++cnt] = x; up(cnt); void down(int u) &#123; int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; swap(h[u], h[t]); down(t); &#125; &#125; void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] > h[u]) &#123; swap(h[u / 2], h[u]); u /= 2; &#125; &#125; void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] > h[u]) &#123; swap(h[u / 2], h[u]); u /= 2; &#125; &#125; 字符串哈希方式 typedef unsigned long long ULL; const int P = 131; char str[N]; ULL h[N], p[N]; // h stores hash values, p stores the pow of P p[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125; ULL get(int l, int r) &#123; return h[r] - h[l - 1] * p[r - l + 1]; &#125; bool judge(int l1, int r1, int l2, int r2) &#123; if (get(l1, r1) == get(l2, r2)) return true; else return false; &#125; 最短路 int n, m; int g[N][N]; int dist[N]; bool st[N]; int dijkstra() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for (int i = 0; i &lt; n; i++) &#123; // 遍历所有点 int t = -1; for (int j = 1; j &lt;= n; j++) &#123; // 循环所有的点找到未确定最短路的、最小dist值的点 if (!st[j]) &amp;&amp; (t == -1 || dist[t] > dist[j]) t = j; &#125; st[t] = true; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); // 更新dist值 &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; &#125; int main() &#123; /* read in */ memset(g, 0x3f, sizeof(g)); while (m--) &#123; /* read in */ g[a][b] = min(g[a][b], c); // 可能存在重边和自环 &#125; int res = dijkstra(); return 0; &#125; typedef pair&lt;int, int> PII; // pair: distance, number int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; int dijkstra() &#123; // heap-dijkstra memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII>, greater&lt;PII>> heap; // 小根堆 heap.push(&#123;0, 1&#125;); while (heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; // redundancy 冗余 else st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > distance + w[i]) &#123; dist[to] = distance + w[i]; heap.push(&#123;dist[to], to&#125;); &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edge info */ int res = dijkstra(); return 0; &#125; int n, m, k; int dist[N], backup[N]; // backup是dist的备份 struct Edge &#123; int a, b, w; &#125; edges[M]; int bellman_ford() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0'; for (int i = 0; i &lt; k; i++) &#123; memcpy(backup, dist, sizeof dist); for (int j = 0; j &lt; m; j++) &#123; int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); &#125; &#125; if (dist[n] > 0x3f3f3f3f / 2) return -1; // 可能两个点都无法到达，但是两个点之间存在一条负权边，那么出点会将入点的无穷更新成一个小于正无穷的数，这时就可能出现问题，这个点的dist不等于无穷，那么其实如果写成 dist == INF 就不成立了。 return dist[n]; &#125; int main() &#123; /* read in */ int res = bellman_ford(); /* something else */ &#125; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; // if the vertex is in queue void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; int spfa() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int> q; q.push(1); st[1] = true; while (q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > dist[t] + w[i]) &#123; dist[to] = dist[t] + w[i]; if (!st[to]) &#123; q.push(to); st[to] = true; &#125; &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edge info */ int res = spfa(); /* something else */ return 0; &#125; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N], cnt[N]; bool st[N]; // if the vertex is in queue void add(int a, int b, int w) &#123; e[idx] = b, w[idx] = w; ne[idx] = h[a], h[a] = idx++; &#125; int spfa() &#123; queue&lt;int> q; for (int i = 1; i &lt;= n; i++) &#123; st[i] = true; q.push(i); &#125; while (q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > dist[t] + w[i]) &#123; dist[to] = dist[t] + w[i]; cnt[to] = cnt[t] + 1; if (cnt[j] >= n) return true; if (!st[to]) &#123; q.push(to); st[to] = true; &#125; &#125; &#125; &#125; return false; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edge info */ bool ifCircle = spfa(); /* something else */ return 0; &#125; int d[N][N]; // adjacent matrix for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125; &#125; 最小生成树 const int N = ..., INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() &#123; memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[t] > dist[j])) t = j; &#125; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); st[t] = true; &#125; return res; &#125; int main() &#123; /* read in */ memset(g, 0x3f, sizeof g); /* read in edges */ int res = prim(); /* something else */ &#125; int n, m; int p[N]; struct Edge &#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125; &#125; edges[N]; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int kruskal() &#123; sort(edges, edges + m); for (int i = 1; i &lt;= n; i++) p[i] = i; int res = 0, cnt = 1; for (int i = 0; i &lt; m; i++) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) &#123; p[a] = b; res += w; cnt++; &#125; &#125; if (cnt &lt; n) return -1; else return res; &#125; int main() &#123; /* read in */ int res = kruskal(); /* something else */ &#125; 染色法判定二分图 const int N = ..., M = 2 * N; int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a], h[a] = idx++; &#125; bool dfs(int u, int c) &#123; color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!color[j]) &#123; if (!dfs(j, 3 - c)) return false; &#125; else if (color[j] == c) return false; &#125; return true; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edges */ bool flag = true; for (int i = 1; i &lt;= n; i++) &#123; if (!color[i]) &#123; if (!dfs(i, 1)) &#123; flag = false; break; &#125; &#125; &#125; if (flag) puts(\"Yes\"); else puts(\"No\"); &#125; 匈牙利算法 int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; bool find(int x) &#123; // find if x can get matched for (int i = h[x]; i != -1; i++) &#123; int to = e[i]; if (!st[to]) &#123; st[to] = true; if (!match[to] || find(match[to])) &#123; match[to] = x; return true; &#125; &#125; &#125; return false; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edges */ int res = 0; for (int i = 1; i &lt;= n1; i++) &#123; memset(st, false, sizeof st); if (find(i)) res++; &#125; printf(\"%d\", res); return 0; &#125; 线性筛 void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; 约数 vector&lt;int> getDivisors(int n) &#123; vector&lt;int> res; for (int i = 1; i &lt;= n / i; i++) &#123; if (n % i == 0) &#123; res.push_back(i); if (i != n / i) res.push_back(n / i); &#125; &#125; sort(res.begin(), res.end()); return res; &#125; 约数个数 /** Defination for get the sum number of factors * unordered_map&lt;int> primes; // store map&lt;prime, power> of a number(factors multipled) * int x; // one factor * typedef long long LL; * const int mod = 10e9 + 7; */ void getFactors(int x) &#123; for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; x /= i; primes[i]++; &#125; &#125; if (x > 1) primes[x]++; &#125; // get result LL res = 1; for (auto &amp;prime: primes) res = res * (prime.second + 1) % mod; 约数之和 /** Defination for get the sum number of factors * unordered_map&lt;int> primes; // store map&lt;prime, power> of a number(factors multipled) * int x; // one factor * typedef long long LL; * const int mod = 10e9 + 7; */ void getFactors(int x) &#123; for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; x /= i; primes[i]++; &#125; &#125; if (x > 1) primes[x]++; &#125; // get result LL res = 1; for (auto &amp;prime: primes) &#123; int p = prime.first, a = prime.second; LL t = 1; while (a--) t = (t * p + 1) % mod; // 秦九韶算法，得到公式中的每一个因式 res = res * t % mod; &#125; 欧几里得算法 最大公因数 int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125; 欧拉函数 int getEuler(int a) &#123; int res = a; for (int i = 2; i &lt;= a / i; i++) &#123; if (a % i == 0) &#123; res = res / i * (i - 1); while (a % i == 0) a /= i; &#125; &#125; if (a > 1) res = res / a * (a - 1); return res; &#125; /** Defination for linear sieve to get Euler * int primes[N], cnt; * int phi[N]; * bool st[N]; */ void getEulers(int n) &#123; phi[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) &#123; phi[primes[j] * i] = primes[j] * phi[i]; break; &#125; else phi[primes[j] * i] = (primes[j] - 1) * phi[i]; &#125; &#125; &#125; 快速幂 typedef long long LL; // 乘因子可能会爆int所以要开long long int quickPow(int a, int k, int p) &#123; // return (a^k % p) int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; 扩展欧几里得算法 int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; 组合数 2000 void init() &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; &#125; &#125; &#125; 1e5 /** Defination for combination situation.2 * int fact[N], infact[N]; * typedef long long LL; */ int quickPow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; void init() &#123; fact[0] = infact[0] = 1; for (int i = 1; i &lt; N; i++) &#123; fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * quickPow(i, mod - 2, mod) % mod; &#125; &#125; /** output caution * printf(\"%d\", (LL)fact[a] * infact[a - b] % mod * infact[b] % mod); ** otherwise it can over range of &lt;int> */ 1e18, P in 1e5 -- Lucas \\[ C_a^b\\equiv C_{a\\text{ mod }p}^{b\\text{ mod }p}\\cdot C_{a/p}^{b/p}\\ (\\text{mod p})\\ .\\text{ for }b\\le a,p\\in\\mathrm{prime}\\ N^+\\tag{a} \\] /** Defination for combination situation.3 * typedef long long LL; * int p; */ int quickPow(int a, int k) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; &#125; return res; &#125; int C(int a, int b) &#123; int res = 1; for (int i = 1, j = a; i &lt;= b; i++, j--) &#123; res = (LL)res * j % p; res = (LL)res * quickPow(i, p - 2) % p; &#125; return res; &#125; int lucas(LL a, LL b) &#123; if (a &lt; p &amp;&amp; b &lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; &#125; 要精确值 /** Defination for combination situation.4 * int primes[N], cnt; * bool st[N]; * int sum[N]; */ void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[prinmes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; int getp(int n, int p) &#123; // get how many p in n int res = 0; while (n) &#123; res += n / p; n /= p; &#125; return res; &#125; vector&lt;int> mul(vector&lt;int> a, int b) &#123; if (!b) return &#123;0&#125;; vector&lt;int> c; int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t += a[i] * b; c.push_back(t % 10); t /= 10; &#125; while (t) &#123; c.push_back(t % 10); t /= 10; &#125; return c; &#125; int main() &#123; /* read in */ getPrimes(a); // because a >= b for (int i = 0; i &lt; cnt; i++) &#123; int p = primes[i]; sum[i] = getp(a, p) - getp(b, p) - getp(a - b, p); &#125; vector&lt;int> res; res.push_back(1); for (int i = 0; i &lt; cnt; i++) &#123; for (int j = 0; j &lt; sum[i]; j++) &#123; res = mul(res, primes[i]); &#125; &#125; for (int i = res.size() - 1; i >= 0; i--) printf(\"%d\", res[i]); return 0; &#125; 容斥原理 int n, m; int p[N]; typedef long long LL; int main() &#123; /* read in */ int res = 0; for (int i = 1; i &lt; 1 &lt;&lt; m; i++) &#123; int t = 1, cnt = 0; for (int j = 0; j &lt; m; j++) &#123; if (i >> j &amp; 1) &#123; // this set is chosen if ((LL)t * p[j] > n) &#123; t = -1; break; &#125; t *= p[j]; cnt++; &#125; &#125; if (t != -1) &#123; if (cnt % 2) res += n / t; else res -= n / t; &#125; &#125; /* output */ return 0; &#125; 背包 01 int n, m; int v[N], w[N]; int f[N]; int main() &#123; /* read in */ /* f[0][0]~f[0][m] = 0 */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= v[i]; j--) &#123; // 循环倒序更新使得 f[j-v[i]] 后被更新，先使用的是之前一轮的 f[j-v[i]] 值 f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; /* output f[m] */ return 0; &#125; 完全 int n, m; int v[N], w[N]; int f[N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = v[i]; j &lt;= m; j++) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; return 0; &#125; 多重 int n, m; int v[N], w[N]; int f[N]; int main() &#123; /* read in */ int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; cin >> a >> b >> s; int k = 1; while (k &lt;= s) &#123; cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; &#125; if (s > 0) &#123; cnt++; v[cnt] = a * s; w[cnt] = b * s; &#125; &#125; n = cnt; // 以下为 01 背包 for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; /* output f[m] */ return 0; &#125; 分组 int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= 0; j--) &#123; for (int k = 0; k &lt; s[i]; k++) &#123; if (v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); &#125; &#125; &#125; /* output f[m] */ return 0; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"板子","slug":"Algorithm/AcWing/算法基础课/板子","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Module","slug":"Module","permalink":"https://www.leolang.top/tags/Module/"}]},{"title":"AcWing 动态规划（四）","slug":"动态规划（四）计数DP","date":"2021-09-14T16:00:00.000Z","updated":"2021-09-15T02:44:54.000Z","comments":true,"path":"2021/09/15/动态规划（四）计数DP/","link":"","permalink":"https://www.leolang.top/2021/09/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%9B%9B%EF%BC%89%E8%AE%A1%E6%95%B0DP/","excerpt":"前言 本文将介绍区间DP有关内容。","text":"前言 本文将介绍区间DP有关内容。 动态规划（四）计数DP 〇、什么是计数DP 计数DP是一类所求集合属性是数量的DP问题。 一、整数划分 题目链接 AcWing 900 首先，本题可以用背包问题来做，是一个完全背包。由于本题不需要考虑顺序，那么可以把整数 \\(n\\)​ 看成是背包的容量，有 \\(n\\)​ 种物品可供选择，体积分别为 \\(1\\sim n\\)​​​​ ，数量无限。我们要求的恰好装满背包的方案数。对于整数的每一种划分方法都可以看成是一种背包的选法。 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 表示所有选法的集合 满足的条件 只能从 \\(1\\sim i\\) 范围中选 \\(\\sum v_i=j\\)​​​ 属性：需要存储的是什么属性 数量 状态计算 —— 集合的划分：不重、不漏 以数 \\(i\\)​​ 选取几个作为划分依据，设最多可以取出 \\(s\\)​ 个数 \\(i\\) ，有状态转移方程 \\[ f(i,j)=f(i-1,j)+f(i-1,j-i)+f(i-1,j-2i)+\\cdots +f(i-1,j-si) \\] 简记做 \\[ f(i,j)=\\sum_{k=1}^sf(i-1,j-ki) \\] 上述方法的时间复杂度为 \\(&lt;O(n^3)\\) ，回忆完全背包的优化方式并模仿，首先我们有 \\(f(i,j)\\)​ 的展开如上，之后，我们有 \\(f(i,j-i)\\) 的展开如下 \\[ f(i,j-i)=f(i-1,j-i)+f(i-1,j-2i)+\\cdots+f(i-1,j-si) \\] 可以发现，同样的这个式子的右侧和 \\(f(i,j)\\)​ 的展开式中等号右侧从第二项起的部分完全相同。那么和完全背包问题一样我们可以优化其至一维。 首先二维的优化后的状态转移方程为 \\[ f(i,j)=f(i-1,j)+f(i,j-1) \\] 降至一维后状态转移方程变为 \\[ g_i(j)=g_{i-1}(j)+g_i(j-1) \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010, mod = 1e9 + 7; int n; int f[N]; int main() &#123; cin >> n; f[0] = 1; // 数字为0，划分只有一种方式0 = 0 for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; f[j] = (f[j] + f[j - i]) % mod; &#125; &#125; cout &lt;&lt; f[n] &lt;&lt; endl; return 0; &#125; if __name__ == '__main__': n = int(input()) mod = int(1e9 + 7) f = [0] * (n + 1) f[0] = 1 for i in range(1, n + 1): for j in range(i, n + 1): f[j] = (f[j] + f[j - i]) % mod; print(f[n]) 再有，本题可以用另一种方式考虑。 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 所有总和是 \\(i\\) ，并且恰好表示成 \\(j\\) 个数的和的方案。 属性：需要存储的是什么属性 数量 状态计算 —— 集合的划分：不重、不漏 对于集合 \\(f(i,j)\\) 的划分方式是 \\(f(i,j)\\Rightarrow\\{\\text{最小值是1},\\text{最小值大于1}\\}\\) 。下面来看一下每一类的值是多少。 最小值是 \\(1\\) 由于方案中必定有一个 \\(1\\)​ 作为其最小值，那么将一个 \\(1\\)​​ 去掉，该方案就成为了总和为 \\(i-1\\)​ ，总共分成 \\(j-1\\) 个数的情况，那么也就是 \\(f(i-1,j-1)\\)​ ，两者的方案数相同。 最小值大于 \\(1\\)​ 由于方案中每个数都 \\(&gt; 1\\) ，那么对于每个数都减去 \\(1\\) 仍然符合题目的要求，这时这种情况就变为了总和是 \\(i-j\\) ，共 \\(j\\) 个数的情况，即 \\(f(i-j,j)\\) 。 那么得到本题的状态转移方程 \\[ f(i,j)=f(i-1,j-1)+f(i-j,j) \\] 最后的答案应该是 \\[ \\sum_{k=1}^nf(n,k)=f(n,1)+f(n,2)+\\cdots+f(n,n) \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010, mod = 1e9 + 7; int n; int f[N][N]; int main() &#123; cin >> n; f[0][0] = 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; &#125; &#125; int res = 0; for (int i = 1; i &lt;= n; i++) res = (res + f[n][i]) % mod; printf(\"%d\\n\", res); return 0; &#125; if __name__ == '__main__': n = int(input()) mod = int(1e9 + 7) f = [[0] * (n + 1) for _ in range(n + 1)] f[0][0] = 1 for i in range(1, n + 1): for j in range(1, n + 1): f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod res = 0 for i in range(1, n + 1): res = (res + f[n][i]) % mod print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"动态规划","slug":"Algorithm/AcWing/算法基础课/动态规划","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"DP","slug":"DP","permalink":"https://www.leolang.top/tags/DP/"}]},{"title":"AcWing 动态规划（三）","slug":"动态规划（三）区间DP","date":"2021-09-13T16:00:00.000Z","updated":"2021-12-01T14:50:58.000Z","comments":true,"path":"2021/09/14/动态规划（三）区间DP/","link":"","permalink":"https://www.leolang.top/2021/09/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89%E5%8C%BA%E9%97%B4DP/","excerpt":"前言 本文将介绍区间DP有关内容。","text":"前言 本文将介绍区间DP有关内容。 动态规划（三）区间DP 〇、什么是区间DP 区间DP也属于线性DP的一种，它以区间长度作为DP的阶段，使用两个坐标即区间的左右端点描述每个维度。 一、石子合并 题目链接 AcWing 282 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 所有将第 \\(i\\) 堆石子到第 \\(j\\) 堆石子合并成一堆石子的合并方式 属性：需要存储的是什么属性 最小值：所有合并方式的最小值。 状态计算 —— 集合的划分：不重、不漏 因为合并石子的最后一次操作一定是将两个大堆最终合成一堆，那么这里我们以最后一次合并的分界线的位置为集合划分的依据。那么集合的划分方式为 \\(f(i,j)\\Rightarrow\\{f(i,j,1),f(i,j,2),\\cdots,f(i,j,m-1)\\}\\)​​​ ，这里记 \\(m=j-i+1\\)​​​ ，状态中的第三个维度代表了分界线左边共有多少对石子。如果最后一次的合并为合并 \\([i,k]\\)​​​ 和 \\([k+1,j]\\)​​​​ 两区间内被合并过后产生的两堆石子，即状态 \\(f(i,j,k)\\) ，由于这一大类中最后一步都是要将上述两堆石子合并，那么我们就可以先行去掉这一步的操作，去看除了这一步之前的操作，最后将最后一步的代价加上即可。那么，到达状态 \\(f(i,j,k)\\) 的倒数第二步所要付出的最小代价即为合并左右两堆石子所要付出的最小代价之和，即为 \\(f(i,k)+f(k+1,j)\\) 。最后一步的代价是什么？最后一步要将区间 \\([i,j]\\)​ 内的所有的石子合并到一起，代价即是区间内所有石子的总重量 \\(w_{ij}\\) ，该值可以用前缀和求出，即 \\(w_{ij}=s_j-s_{i-1}\\) 。 经过以上推导，我们可得 \\(f(i,j,k)=f(i,k)+f(k+1,j)+(s_j-s_{i-1})\\)​ 。 那么就可以得到最后的状态转移方程为 \\[ f(i,j)=\\min_{i\\le k\\le j}\\{f(i,k)+f(k+1,j)+s_j-s_{i-1}\\} \\] #include &lt;iostream> #include &lt;algorithm> #include &lt;cstring> using namespace std; const int N = 310, INF = 1e9; int n; int s[N]; int f[N][N]; int main() &#123; cin >> n; for (int i = 1; i &lt;= n; i++) cin >> s[i]; for (int i = 1; i &lt;= n; i++) s[i] += s[i - 1]; // 区间长度为1即 len == 1 时，合并消耗体力为0，不需要做更改 for (int len = 2; len &lt;= n; len++) &#123; // 枚举区间长度 for (int i = 1; i + len - 1 &lt;= n; i++) &#123; // 枚举区间左端点 int l = i, r = i + len - 1; f[l][r] = INF; for (int k = l; k &lt; r; k++) &#123; // 枚举中间分界点 f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; &#125; &#125; printf(\"%d\\n\", f[1][n]); return 0; &#125; if __name__ == '__main__': n = int(input()) s = [0] + list(map(int, input().split())) for i in range(n + 1): s[i] += s[i - 1] f = [[0] * (n + 1) for _ in range(n + 1)] for len in range(2, n + 1): i = 1 while i + len - 1 &lt;= n: l = i; r = i + len - 1 f[l][r] = int(1e8) for k in range(l, r): f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]) i += 1 print(f[1][n])","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"动态规划","slug":"Algorithm/AcWing/算法基础课/动态规划","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"DP","slug":"DP","permalink":"https://www.leolang.top/tags/DP/"}]},{"title":"AcWing 动态规划（二）","slug":"动态规划（二）线性DP","date":"2021-09-10T16:00:00.000Z","updated":"2021-12-01T14:50:56.000Z","comments":true,"path":"2021/09/11/动态规划（二）线性DP/","link":"","permalink":"https://www.leolang.top/2021/09/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E6%80%A7DP/","excerpt":"前言 本文将介绍有关线性DP的相关内容。将以线性DP的几道经典例题作为讲解对象，给出题目的详细分析以及代码实现。读者可以通过例题来体会DP的思想，体会什么是线性DP。","text":"前言 本文将介绍有关线性DP的相关内容。将以线性DP的几道经典例题作为讲解对象，给出题目的详细分析以及代码实现。读者可以通过例题来体会DP的思想，体会什么是线性DP。 动态规划（二）线性DP 〇、什么是线性DP 具有线性 “阶段” 划分的动态规划算法呗统称为线性DP。无论是一维还是多维，DP 的阶段都沿着各个维度线性增长。 一、数字三角形 题目链接 AcWing 898 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 所有从起点走到 点 \\((i,j)\\) 的路径 属性：需要存储的是什么属性 最大值：集合中所有路径上数字的最大值 状态计算 —— 集合的划分：不重、不漏 对于到每一个数字点的集合 \\(f(i,j)\\)​ ，集合的划分方式为 \\(f(i,j)\\Rightarrow\\{\\text{左上向右下},\\text{右上向左下}\\}\\) 。这里先记作 \\(f(i,j)\\Rightarrow\\{f_l,f_r\\}\\) ，下面来看一下每个元素代表的集合中的元素是什么。 从左上向下得到的 \\(f_l\\) 还是和背包问题中提到过的 “曲线救国” 相类似的思想。能够得到状态 \\(f(i,j)\\) 就必然会经过点 \\((i,j)\\) ，去掉这一个点整个集合中路径的最大值取值是谁是不会改变的。那么就先在路径上不看这个点。由于这个状态是从左上点得到的，那么这个点必是由 \\((i-1,j-1)\\) 点转移而来，那么对于点 \\((i-1,j-1)\\) ，其状态表示是 \\(f(i-1,j-1)\\)​ 。最后再在路径上将点 \\((i,j)\\) 加回来，这里统一记数字集合为 \\(\\{a_{nm}\\}\\) ，那么现在这条路径，也就是点 \\((i,j)\\) 的状态就是 \\(f(i-1,j-1)+a_{ij}\\)​ ，即 \\[ f_l=f(i-1,j-1)+a_{ij} \\] 从右上向下得到的 \\(f_r\\) 和上面的分析思路完全一致，这里就不再重复一遍了。得到 \\(f_r\\) 为 \\[ f_r=f(i-1,j)+a_{ij} \\] 那么，由于最后需要的是最大值，那么得到状态转移方程 \\[ f(i,j)=\\max\\{f(i-1,j-1)+a_{ij},f(i-1,j)+a_{ij}\\} \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 510, INF = 1e9; int n; int a[N][N], f[N][N]; int main() &#123; cin >> n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cin >> a[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= i + 1; j++) &#123; f[i][j] = -INF; &#125; &#125; f[1][1] = a[1][1]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]); &#125; &#125; int res = -INF; for (int i = 1; i &lt;= n; i++) res = max(res, f[n][i]); printf(\"%d\", res); return 0; &#125; if __name__ == '__main__': n = int(input()) N = n + 10 INF = int(1e9) a = [[0] + list(map(int, input().split())) for _ in range(n)] f = [[0] * N for _ in range(N)] for i in range(1, n + 1): for j in range(i + 2): f[i][j] = -INF f[1][1] = a[0][1] for i in range(1, n + 1): for j in range(1, i + 1): f[i][j] = max(f[i - 1][j - 1] + a[i - 1][j], f[i - 1][j] + a[i - 1][j]) res = max(f[n][1:n + 1]) print(res) 二、最长上升子序列 题目链接 AcWing 895 状态表示 \\(f(i)\\)​ 集合：该状态表示的是哪一个集合 所有以第 \\(i\\) 个数结尾的上升子序列 属性：需要存储的是什么属性 最大值：集合中每一个上升子序列的长度的最大值 状态计算 —— 集合的划分：不重、不漏 因为状态 \\(f(i)\\)​​ 肯定包含第 \\(i\\)​​​​ 个数，集合的划分的方式就可以用序列的中它的前一个数来划分，上一个数可能是第 \\(1\\sim i-1\\)​​​ 个数，所以集合的划分就是 \\(f(i)\\Rightarrow\\{f(i,0),f(i,1),\\cdots,f(i,i-1)\\}\\)​​ ，其中第二个维度表示前一个数是第几个数。但其实不一定每一个元素都存在，如果 \\(a_k&lt; a_i\\)​​ ，那么才存在状态 \\(f(i,k)\\)​​​​ 。因为一定序列中最后一个元素是 \\(a_i\\)​ ，则最后只需在以倒数第二个数结尾的序列的长度上加一即可，对最大值没有影响。那么，接下来就可以分析集合中的某一个状态 \\(f(i,k)\\)​​​ ，它其实代表的是以第 \\(k\\)​ 个元素为结尾的元素的序列长度 \\(+1\\)​ ，那么就有 \\(f(i,k)=f(k)+1\\)​ 成立。那么就得到了问题的状态转移方程为 \\[ \\text{for all }a_j&lt;a_i,\\ f(i)=\\max_{0\\le j\\le i-1}\\{f(j)+1\\} \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n; int a[N], f[N]; int main() &#123; cin >> n; for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; f[i] = 1; for (int j = 1; j &lt; i; j++) &#123; if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1); &#125; &#125; int res = 0; for (int i = 1; i &lt;= n; i++) res = max(res, f[i]); printf(\"%d\", res); return 0; &#125; if __name__ == '__main__': n = int(input()) nums = [0] + list(map(int, input().split())) f = [0] * (n + 1) for i in range(1, n + 1): f[i] = 1 for j in range(1, i): if nums[j] &lt; nums[i]: f[i] = max(f[i], f[j] + 1) res = max(f[1:n + 1]) print(res) 如何存储最长上升子序列？ 发生状态转移时，记录该状态是从哪一个状态转移过来的，最后倒序向回找即可。 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n; int a[N], f[N], g[N]; int main() &#123; cin >> n; for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; f[i] = 1; for (int j = 1; j &lt; i; j++) &#123; if (a[j] &lt; a[i]) &#123; if (f[i] &lt; f[j] + 1) &#123; f[i] = f[j] + 1; g[i] = j; &#125; &#125; &#125; &#125; int k = 1; for (int i = 1; i &lt;= n; i++) &#123; if (f[k] > f[i]) k = i; &#125; printf(\"%d\\n\", f[k]); while (k) &#123; printf(\"%d \", a[k]); k = g[k]; &#125; return 0; &#125; 数据规模升级到 \\(10^6\\)​ 层级之后，上述的 DP 就会超时了，因为时间复杂度在 \\(O(n^2)\\)​​ 级别。那么就需要进行优化降低时间复杂度了。 题目链接 AcWing 896 这里的优化我们不再从元素的角度进行考虑，实际上已经脱离了 DP 的思想了。我们这里直接从最长上升子序列的长度进行考虑。 注：以下记原数组序列为 \\(\\{a_n\\}\\)​ ，子序列为 \\(\\{s_n\\}\\) ，下标从 \\(1\\) 开始。 首先，对于长度为 \\(1\\) 的最长上升子序列，每一个元素显然都可以当作序列的结尾。 之后，我们将长度增长 \\(1\\) ，对于长度为 \\(2\\)​ 的最长上升子序列，以原题中给出的输入样例作为例子我们来先实际分析一下： 7 3 1 2 1 8 5 6 这里我们要考虑的问题是，我们如何能够让上升子序列尽可能的长。当序列长度从 \\(1\\)​​​​ 增加至 \\(2\\)​​​​ 时，意味着要将长度为 \\(1\\)​​​​ 的子序列后面添加上一个新的值，那么我们考虑，如何能够让之后再度添加几个数字的时候上升子序列仍然能够合法，且尽可能长？显然，应该是序列长度为 \\(1\\)​​​​​ 的子序列的结尾值尽可能小，这样才能够使得后续可被 “接纳” 的值更多。从上例中足以见得，显然选择 \\(3\\) 优于 \\(1\\) 。推广至序列长度从 \\(k\\) 增加至 \\(k+1\\) 的情况，应当使得 \\(s_k\\) 尽可能的小，这样才能使 \\(s_{k+1}\\) 的可能性更多。这里，如果有两种对 \\(s_k\\) 取值的可能，分别为 \\(\\delta_1,\\delta_2\\) ，如果存在关系 \\(\\delta_1&lt;\\delta_2\\) 成立，我们称 \\(\\delta_1\\) 优于 \\(\\delta_2\\) 。我们为使得 \\(s_k\\) 的取值更优，应当取得 \\(s_k=\\min\\{\\delta_n\\}\\) ，其中 \\(\\{\\delta_n\\}\\) 是所有 \\(s_k\\) 的取值集合。有了以上的推理，我们便记下所有长度下最优的结尾值，记为 \\(\\{q_n\\}\\) ，其中元素 \\(q_i\\) 代表子序列长度为 \\(i\\) 时的最优取值。对于序列 \\(\\{q_n\\}\\) 有着很好的性质：\\(\\forall i&lt;j,\\ q_i&lt;q_j\\)​​ 。也就是说，序列中的元素是严格单调递增的。 证明如下： 假设有 \\(q_k\\ge q_{k+1}\\) 成立，记两者产生的序列分别为 \\(A,B\\) 。那么对于 \\(q_{k+1}\\)​ 产生序列中元素严格有 \\(B_k&lt;B_{k+1}\\) 成立，也就是 \\(B_k&lt;q_{k+1}\\) 。而在 \\(B\\) 中去掉元素 \\(q_{k+1}\\) 的序列 \\(B\\backslash q_{k+1}\\) 仍然是一个合法的上升子序列，并且有关系 \\(q_k\\ge q_{k+1}&gt;B_k\\) 成立，那么证明 \\(B_k\\) 优于 \\(q_k\\) ，但这与我们对 \\(\\{q_n\\}\\)​ 的定义相违，产生矛盾。假设不成立。证毕。 那么，我们接下来考虑原序列 \\(\\{a_n\\}\\)​ 。对于每一元素 \\(a_i\\) ，它应该能被插入所有满足 \\(q_k&lt;a_i\\) 的序列中，从而产生长度为 \\(k+1\\) 的序列。由于 \\(\\{q_n\\}\\) 严格单调递增，那么一定有 \\(q_k&lt;a_i&lt;q_{k+1}\\) 成立，此时 \\(a_i\\)​ 优于 \\(q_{k+1}\\) ，那么 \\(q_{k+1}\\) 理应被更新为 \\(a_i\\)​​ 。并且由于严格单调递增的性质，我们可以使用二分来找寻满足 \\(&lt;a_i\\) 的最大值的位置。 上面分析了一通，那么最长的上升子序列的最长应是多少？显然，每一个元素 \\(a_i\\) 都能够产生一个长度值 \\(l_i\\) ，对所有的长度值取最大即可，即 \\[ \\forall a_i\\in\\{a_n\\},\\ a_i\\mapsto l_i,\\ \\max_{1\\le i\\le n}\\{l_n\\} \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 100010; int n; int a[N], q[N]; int main() &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); int len = 0; for (int i = 0; i &lt; n; i++) &#123; int l = 0, r = len; while (l &lt; r) &#123; int mid = l + r + 1 >> 1; if (q[mid] &lt; a[i]) l = mid; else r = mid - 1; &#125; len = max(len, r + 1); q[r + 1] = a[i]; &#125; printf(\"%d\", len); return 0; &#125; if __name__ == '__main__': n = int(input()) a = list(map(int, input().split())) q = [0] * (n + 1) len = 0 for i in range(n): l = 0; r = len while l &lt; r: mid = l + r + 1 >> 1 if q[mid] &lt; a[i]: l = mid else: r = mid - 1 len = max(len, r + 1) q[r + 1] = a[i] print(len) 三、最长公共子序列 题目链接 AcWing 897 状态表示 \\(f(i,j)\\)​​ 集合：该状态表示的是哪一个集合 所有在第一个序列的前 \\(i\\) 个字母中出现，且在第二个序列的前 \\(j\\) 个字母也出现的子序列​ 属性：需要存储的是什么属性 最大值：集合中每一个公共子序列的长度的最大值 状态计算 —— 集合的划分：不重、不漏 记两字符串分别为 \\(\\{a_n\\},\\ \\{b_n\\}\\)​ 。对于集合 \\(f(i,j)\\)​ 的划分为 \\(f(i,j)\\Rightarrow\\{f(i,j,0,0),f(i,j,0,1),f(i,j,1,0),f(i,j,1,1)\\}\\) ，其中后两个分别维度代表了字母 \\(a_i,\\ b_j\\) 是否出现在子序列当中， \\(0\\) 代表不含有， \\(1\\)​ 代表含有。​​那么同样的，下面来看一下各元素的值是什么。 都选和都不选的情况 \\(f(i,j,0,0),\\ f(i,j,1,1)\\)​ 这两种情况的分析非常简单，\\(f(i,j,0,0)\\) 就可以直接简化为 \\(f(i-1,j-1)\\) ，而 \\(f(i,j,1,1)\\) 状态中其实默认了有 \\(a_i=b_j\\) 成立，那么通过曲线救国也可以直接简化为 \\(f(i-1,j-1)+1\\) 选一个的情况 \\(f(i,j,0,1),\\ f(i,j,1,0)\\)​ 这里最容易错误的想法是（以 \\(f(i,j,0,1)\\)​ 为例） \\(f(i,j,0,1)\\iff f(i-1,j)+1\\)​ 。但实际上两者是并不等价的。原因其实也很简单， \\(f(i-1,j)\\)​ 代表的含义是所有在第一个序列的前 \\(i-1\\)​ 个字母中出现，且在第二个序列的前 \\(j\\)​ 个字母也出现的子序列，加上 \\(1\\)​ 后意义变为所有在第一个序列的前 \\(i\\)​ 个字母中出现，且在第二个序列的前 \\(j+1\\)​​ 个字母也出现的子序列，可以看到它和 \\(f(i,j,0,1)\\)​ 的含义是完全不同的。那么这里应该如何求出这两个元素的值呢？对于 \\(\\max\\) 算子，计算的是数值的话如果包含的元素中有重复是不影响最后的结果的。可以看到 \\(f(i,j,0,1)\\subset f(i-1,j)\\) 是成立的，同样的 \\(f(i,j,1,0)\\subset f(i,j-1)\\) 也是成立的，而且最关键的一点是存在着 \\(f(i-1,j),f(i,j-1)\\subset f(i,j)\\)​ 这样的一个关系，这里不进行详细的证明了。那么这里的思路就是我用两个比原来大的、且包含于原集合的集合去替换那两个集合，由于前面提到过的关于 \\(\\max\\)​ 算子的性质，两个集合将原来的集合完全包含，那么最后求得的结果也就完全不受影响。 那么最后的状态转移方程就是 \\[ f(i,j)=\\max\\{f(i-1,j-1),f(i-1,j),f(i,j-1),f(i-1,j-1)+1\\} \\] 这里其实有了上面的思想之后我们还可以优化，不难发现，是有着 \\(f(i-1,j-1)\\subset f(i-1,j)\\) 和 \\(f(i-1,j-1)\\subset f(i,j-1)\\)​ 这样的关系成立的。那么套用上面的思想，我们完全可以直接去掉 \\(f(i-1,j-1)+1\\) 这一项，这样我们的状态转移方程可以简化为 \\[ f(i,j)=\\max\\{f(i-1,j),f(i,j-1),f(i-1,j-1)+1\\} \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() &#123; cin >> n >> m; scanf(\"%s%s\", a + 1, b + 1); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; &#125; printf(\"%d\", f[n][m]); return 0; &#125; if __name__ == '__main__': n, m = map(int, input().split()) a = ' ' + input() b = ' ' + input() f = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = max(f[i - 1][j], f[i][j - 1]) if a[i] == b[j]: f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1) print(f[n][m]) 四、编辑距离 4.1 最短编辑距离 题目链接 AcWing 902 分别记两字符串为 \\(\\{A_n\\},\\{B_n\\}\\)​ 。 状态表示 \\(f(i,j)\\)​​ 集合：该状态表示的是哪一个集合 将字符串 \\([A_1,A_i]\\) 更改为 \\([B_1,B_j]\\) 的所有操作方法集合 属性：需要存储的是什么属性 最小值：所有操作方法的操作数的最小值 状态计算 —— 集合的划分：不重、不漏 对于每一次状态转移，我们规定只能够修改一个字符，且只能从最后的部位进行修改。这种规定方式是正确的，符合了题目中的要求，虽然我们事实上每次可以修改字符串中的任意一个位置，但这种规定方式是有利于我们进行一位一位地状态转移。从 \\([A_1,A_i]\\)​ 到 \\([B_1,B_j]\\) 有三种方式可供选择：删除、增加、修改。那么对于 \\(f(i,j)\\) 的划分方式就很显然了，依据我们要从哪种方式得到 \\([B_1,B_j]\\)​ 来划分集合。则 \\(f(i,j)\\Rightarrow\\{f(i,j,\\mathrm d),f(i,j,\\mathrm a),f(i,j,\\mathrm c)\\}\\)​ ，分别对应上述三种方式。下面分别来看一下这三个值都是什么。 删除 \\(f(i,j,\\mathrm d)\\) 如果是通过删除操作得到的 \\([B_1,B_j]\\) ，那么就有 \\([A_1,A_{i-1}]=[B_1,B_j]\\) 成立。那么这个状态就是从使得 \\([A_1,A_{i-1}]\\to[B_1,B_j]\\) 的状态转移过来的，即 \\(f(i-1,j)\\) 。那么这个状态的等价状态：\\(f(i,j,\\mathrm d)\\iff f(i-1,j)+1\\) 。 添加 \\(f(i,j,\\mathrm a)\\) 通过添加操作得到 \\([B_1,B_j]\\)​ 就应有 \\([A_1,A_i]=[B_1,B_{j-1}]\\) 成立，通过添加 \\(B_j\\)​ 实质成立，和上面相同，这个状态是由 \\(f(i,j-1)\\)​ 转移而来的，那么就有 \\(f(i,j,\\mathrm a)\\iff f(i,j-1)+1\\) 。 修改 \\(f(i,j,\\mathrm c)\\)​ 同样的，应有 \\([A_1,A_{i-1}]=[B_1,B_{j-1}]\\) 成立，这里需要关注一下 \\(A_i\\) 和 \\(B_j\\) 的值，有下面的等价关系成立： \\[ f(i,j,\\mathrm c)\\iff \\begin{cases} f(i-1,j-1)&amp;A_i=B_j\\\\ f(i-1,j-1)+1&amp;A_i\\ne B_j\\\\ \\end{cases} \\] 那么我们就得到了本题的状态转移方程 \\[ f(i,j)= \\begin{cases} \\min\\{f(i-1,j)+1,f(i,j-1)+1,f(i-1,j-1)\\}&amp;A_i=B_j\\\\ \\min\\{f(i-1,j)+1,f(i,j-1)+1,f(i-1,j-1)\\}&amp;A_i\\ne B_j \\end{cases} \\] #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; char a[N], b[N]; int f[N][N]; int main() &#123; cin >> n; scanf(\"%s\", a + 1); cin >> m; scanf(\"%s\", b + 1); // 初始化边界状况 for (int i = 0; i &lt;= m; i++) f[0][i] = i; // 只能通过添加得到B for (int i = 0; i &lt;= n; i++) f[i][0] = i; // 只能通过删除得到B for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); else f[i][j] = min(f[i][j], f[i - 1][j - 1]); &#125; &#125; printf(\"%d\\n\", f[n][m]); return 0; &#125; if __name__ == '__main__': n = int(input()) a = \" \" + input() m = int(input()) b = \" \" + input() f = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): f[i][0] = i for i in range(1, m + 1): f[0][i] = i for i in range(1, n + 1): for j in range(1, m + 1): f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1) f[i][j] = min(f[i - 1][j - 1] + 1, f[i][j]) if a[i] != b[j] else min(f[i][j], f[i - 1][j - 1]) print(f[n][m]) 4.2 编辑距离 题目链接 AcWing 899 本题完全和最短编辑距离相同，只不过是目标串变成了多个，编写一使用上题思路的函数即可。 #include &lt;iostream> #include &lt;algorithm> #include &lt;cstring> using namespace std; const int N = 1010, M = 15; int n, m; char str[N][M]; int f[M][M]; int getValue(char a[], char b[]) &#123; int lena = strlen(a + 1), lenb = strlen(b + 1); for (int i = 0; i &lt;= lena; i++) f[i][0] = i; for (int i = 0; i &lt;= lenb; i++) f[0][i] = i; for (int i = 1; i &lt;= lena; i++) &#123; for (int j = 1; j &lt;= lenb; j++) &#123; f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (a[i] != b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); else f[i][j] = min(f[i][j], f[i - 1][j - 1]); &#125; &#125; return f[lena][lenb]; &#125; int main() &#123; cin >> n >> m; for (int i = 0; i &lt; n; i++) scanf(\"%s\", str[i] + 1); while (m--) &#123; char s[M]; int limit; scanf(\"%s%d\", s + 1, &amp;limit); int res = 0; for (int i = 0; i &lt; n; i++) &#123; if (getValue(str[i], s) &lt;= limit) res++; &#125; printf(\"%d\\n\", res); &#125; return 0; &#125; def getValue(a, b): global f lena = len(a) - 1; lenb = len(b) - 1 for i in range(lena + 1): f[i][0] = i for i in range(lenb + 1): f[0][i] = i for i in range(1, lena + 1): for j in range(1, lenb + 1): f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1) f[i][j] = min(f[i - 1][j - 1], f[i][j]) if a[i] == b[j] else min(f[i - 1][j - 1] + 1, f[i][j]) return f[lena][lenb] if __name__ == '__main__': n, m = map(int, input().split()) str = [\" \" + input() for _ in range(n)] f = [[0] * 15 for _ in range(15)] for _ in range(m): s, limit = input().split() s = \" \" + s limit = int(limit) res = 0 for i in range(n): if getValue(str[i], s) &lt;= limit: res += 1 print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"动态规划","slug":"Algorithm/AcWing/算法基础课/动态规划","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"DP","slug":"DP","permalink":"https://www.leolang.top/tags/DP/"}]},{"title":"AcWing 动态规划（一）","slug":"动态规划（一）背包问题","date":"2021-09-02T16:00:00.000Z","updated":"2022-03-23T11:44:44.196Z","comments":true,"path":"2021/09/03/动态规划（一）背包问题/","link":"","permalink":"https://www.leolang.top/2021/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"前言 本文将介绍动态规划中的背包问题。将介绍四种背包问题，并给出其经典的优化方式，最后给出算法模板。另外，本文中还会给出 DP 问题的分析方式（闫式dp）","text":"前言 本文将介绍动态规划中的背包问题。将介绍四种背包问题，并给出其经典的优化方式，最后给出算法模板。另外，本文中还会给出 DP 问题的分析方式（闫式dp） 动态规划（一）背包问题 〇、什么是背包问题，如何从dp分析背包问题 0.1 什么是背包问题 有 \\(N\\)​​​​​ 个物品和一个容量是 \\(V\\)​​​​​ 的背包。对于每个物品 \\(\\alpha_i\\)​​​ ，都有属性三元组 \\(\\alpha_i=(v_i,w_i,s_i)\\)​​​ ，其中 \\(v_i\\)​​​ 为物品的体积， \\(w_i\\)​​​ 为物品的价值， \\(s_i\\)​​ 为物品的数量。现在要挑选一些物品，问如何使得物品总体积小于等于 \\(V\\)​​​​​​​​ ，且总价值最大？ \\[ \\max \\sum_{i=1}^N w_i\\\\ \\mathrm{s.t.} \\left\\{ \\begin{array}{l} \\displaystyle\\sum_{i=1}^N v_i\\le V\\\\ w_i&gt;0\\\\ v_i&gt;0\\\\ s_i\\ge 0 \\end{array}\\quad(i=1,2,\\cdots,N) \\right. \\] 注：以下各符号若没有特殊说说明，均沿用此处标记，对于物品不区分用 \\(\\alpha\\)​ 表示与用数字序号表示，两者表达含义相同。 0.2 从dp分析背包问题 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 表示所有选法的集合 满足的条件 只能从前 \\(i\\) 个物品里选 \\(\\sum_\\alpha v_i\\leq j\\)​​ 属性：需要存储的是什么属性 最大值 最小值 数量 状态计算 —— 集合的划分：不重、不漏 一、01 背包问题 1.1 01 背包问题描述 要求为每件物品 \\(i\\)​​​ 只能使用一次，即 \\(\\forall \\alpha_i\\in N,\\ s_i=1\\)。 则数学描述为： \\[ \\begin{align} \\text{get }\\alpha_i\\in N\\Rightarrow\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_m),\\ \\forall \\alpha_i\\in N,\\ s_i=1\\\\[3px] \\mathrm{s.t.} \\ \\ \\max\\sum_\\alpha w_i\\text{ , where } \\sum_\\alpha v_i\\le V \\end{align} \\] 1.2 01 背包的 dp 分析 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 表示所有选法的集合 满足的条件 只能从前 \\(i\\) 个物品里选 \\(\\sum_\\alpha v_i\\leq j\\)​​ 属性：需要存储的是什么属性 最大值：价值最大 状态计算 —— 集合的划分：不重、不漏 对于 01 背包问题，集合的划分方式为：\\(f(i,j)\\Rightarrow\\{f(i,j,N_1),f(i,j,N_2)\\}\\)​​​ 。其中， \\(i\\notin N_1,i\\in N_2\\)​​​ ，\\(N_1,N_2\\subset N\\)​​​​​​​​ 。 故得到初步的状态转移方程为 \\[ f(i,j)=\\max\\{f(i,j,N_1),f(i,j,N_2)\\} \\] 由于状态表示中对状态的条件定义，我们又能将集合划分后的三维状态进行等价降维，即： \\[ \\begin{align} f(i,j)&amp;=\\max\\{f(i,j,N_1),f(i,j,N_2)\\}\\\\ &amp;\\iff\\max\\{f(i-1,j),f(i-1,j-v_i)+w_i\\big\\} \\end{align} \\] 证明： 对于不包含物品 \\(i\\)​​ 的情况 \\(f(i,j,N_1),\\ i\\notin N_1\\subset N\\) 我们要求状态 \\(f(x,y)\\)​ 表示只能从前 \\(x\\)​ 个物品中选取体积不超过 \\(y\\)​ 的物品，那么如果选取的集合要从前 \\(i\\)​ 个物品里选，但我们还要求不包含 \\(i\\)​ ，那么也就相当于从前 \\(i-1\\) 个物品中进行选取，故原三维状态可降维至二维状态 \\(f(i-1,j)\\)​ 。 对于包含物品 \\(i\\)​ 的情况 \\(f(i,j,N_2),\\ i\\in N_2\\subset N\\) 这里稍有些难以理解，我们要从前 \\(i\\)​​ 个中选取物品，还要包含第 \\(i\\)​​ 个物品，并且体积限制在 \\(\\leq j\\)​​ 。那么可以看到，这些选取方式是不是都选择了物品 \\(i\\)​​​ ？那么好了，逆向思维想一下，既然它一定会被选取，我们也就可以不去看这个物品 \\(i\\)​​ ，由于对于状态的条件定义，我们这时就是从前 \\(i-1\\)​​ 个物品中进行选取，由于物品 \\(i\\)​​ 一定会被选到，我们现在还没有将其算入我们的 “选定范围” 以内，那么体积的上限也就减小至 \\(\\leq j-v_i\\)​​​ ，那么这个对应的状态表示也就是 \\(f(i-1,j-v_i)\\)​ 。由于我们前面忽视了物品 \\(i\\)​ ，又因为这一集合包含的所有选法中是必然含有物品 \\(i\\)​ 的，所以我们最后需要把这一物品的价值加上才得到了包含物品 \\(i\\)​ 的完整选取方式。故原三维状态可降维为 \\(f(i-1,j-v_i)+w_i\\)​​​ 。 证毕。 注：等价降维的思想就是找到状态表示定义下某状态的意义，并找到与其等价的某一状态或去掉某一元素后等价的某一状态，即可进行等价降维。 那么我们得到了如何计算状态，即 01 背包问题状态转移方程： \\[ f(i,j)=\\max\\{f(i-1,j),f(i-1,j-v_i)+w_i\\} \\] 二维的01背包 int n, m; int v[N], w[N]; int f[N][N]; int main() &#123; /* read in */ /* f[0][0]~f[0][m] = 0 */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); // 包含i的情况在 总体积不够v[i]时 就是空集，是无效计算 &#125; &#125; /* output f[n][m] */ return 0; &#125; 1.3 01 背包的一维优化 由于我们的 \\(f(i,\\cdot)\\)​ 只用到了 \\(f(i-1,\\cdot)\\)​ 的情况，则可以用滚动数组做。而且始终有有 \\(j,j-v_i\\leq j\\)​​​​​ 成立 ，那么状态表示就可以减到一维。 那么原来的状态转移方程就被改成了 \\[ f(j)=\\max\\{f(j),f(j-v_i)+w_i\\} \\] 那么直接降维后的这个状态转移方程是否和二维的方程等价呢？答案是否定的。 引入符号 \\(g_k(V)\\)​​​ 为第 \\(k\\)​​​ 轮更新的体积 \\(\\leq V\\)​​​ 的状态，即 \\(g_x(y)\\iff f(x,y)\\) 。前文提到过， \\(j-v_i\\leq j\\)​​​​​ 始终成立。由于我们的循环是从小到大进行枚举的，那么实际上 \\(f(j-v_i)\\) 一定是在 \\(f(j)\\) 之前被更新的。那现在的 \\(f(j-v_i)\\) 其实应该是 \\(f(i,j-v_i)\\) ，或者写做 \\(g_i(j-v_i)\\)​ 。那么现在的状态转移方程实质上是： \\[ \\begin{align} g_i(j)&amp;=\\max\\{g_i(j),g_i(j-v_i)+w_i\\}\\\\ &amp;\\iff \\max\\{f(i,j),f(i,j-v_i)+w_i\\} \\end{align} \\] 可以看到，这在 \\(\\max\\) 算子中的第二项是完全不同的。那么应该如何修改呢？我们应让 \\(g_\\cdot(j-v_i)\\) 这一项是 \\(g_{i-1}(j-v_i)\\) 而不是 \\(g_i(j-v_i)\\) 。还是由于 \\(j-v_i\\leq j\\) 严格成立，我们只需先更新 \\(g_\\cdot(j)\\) ，后更新 \\(g_\\cdot(j-v_i)\\)​ 就可以了。那么严谨的一维的状态转移方程应被写作： \\[ g_i(j)=\\max\\{g_{i-1}(j),g_{i-1}(j-v_i)+w_i\\} \\] int n, m; int v[N], w[N]; int f[N]; int main() &#123; /* read in */ /* f[0][0]~f[0][m] = 0 */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= v[i]; j--) &#123; // 循环倒序更新使得 f[j-v[i]] 后被更新，先使用的是之前一轮的 f[j-v[i]] 值 f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; /* output f[m] */ return 0; &#125; 二、完全背包问题 2.1 完全背包问题描述 要求为每件物品 \\(i\\)​​​ 有无限个，即 \\(\\forall \\alpha_i\\in N,\\ s_i=+\\infty\\)​​​。 则数学描述为： \\[ \\begin{align} \\text{get }\\alpha_i\\in N\\Rightarrow\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_m),\\ \\forall \\alpha_i\\in N,\\ s_i=+\\infty\\\\[3px] \\mathrm{s.t.}\\ \\ \\ \\ \\max\\sum_\\alpha w_i\\text{ , where } \\sum_\\alpha v_i\\le V \\end{align} \\] 2.2 完全背包的 dp 分析 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 表示所有选法的集合 满足的条件 只能从前 \\(i\\) 个物品里选 \\(\\sum_\\alpha v_i\\leq j\\)​​ 属性：需要存储的是什么属性 最大值：价值最大 状态计算 —— 集合的划分：不重、不漏 对于完全背包问题，集合的划分方式为 \\(f(i,j)\\Rightarrow\\{f(i,j,0),f(i,j,1),f(i,j,2),\\cdots,f(i,j,m)\\}\\)​​​​ ，其中第三个值代表选取 \\(i\\)​​​​ 的个数，并假设最多可以取得 \\(m\\)​​​ 个，即满足 \\(m=\\displaystyle\\mathop{\\arg\\max}_{x\\text{ for }\\alpha_i} \\sum_\\alpha v_i\\)​​。 下面来看一下每个元素的值是什么： \\[ \\begin{gather} f(i,j,0)=f(i-1,j)\\\\ \\vdots\\\\ f(i,j,k)=f(i-1,j-kv_i)+kw_i\\\\ \\vdots\\\\ f(i,j,m)=f(i-1,j-mv_i)+mw_i \\end{gather} \\] 推导的思路和上面 01 背包的完全相同，也是逆向思维曲线救国，这里不再赘述。 于是得到了完全背包的状态转移方程 \\[ f(i,j)=\\max\\{f(i-1,j),f(i-1,j-v_i)+w_i,f(i-1,j-2v_i)+2w_i,\\cdots,f(i-1,j-mv_i)+mw_i\\} \\] 这里简写做： \\[ f(i,j)=\\max\\{f(i-1,j),f(i-1,j-kv_i)+kw_i\\}\\ ,\\ k\\in[1,m]\\subset\\mathbb Z \\] 进一步简写为： \\[ f(i,j)=\\max\\{f(i-1,j-kv_i)+kw_i\\}\\ ,\\ k\\in[0,m]\\subset\\mathbb Z \\] 要注意的是实际上严谨的描述这里实际上 \\(k\\) 应该能够取到 \\(+\\infty\\)​ ，即更准确描述应为 \\[ f(i,j)=\\max\\{f(i-1,j-kv_i)+kw_i\\}\\ ,\\ k\\in\\mathbb Z^+ \\] 只不过我们一定存在着最多取得物品 \\(i\\)​​ 数量的上限，如果溢出上限，选法集合就是空集，那么重复进行 \\(\\max\\) 也没有什么意义。 三维的完全背包 int n, m; int v[N], w[N]; int f[N][N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k * v[i] &lt;= j; k++) &#123; f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); &#125; &#125; &#125; /* output f[n][m] */ return 0; &#125; 2.3 完全背包的二维优化 可以看到上面的状态转移方程是三维的，与 \\(i,j,k\\) 都有关系，那么那么如何能够优化至二维呢？ 我们有 \\(f(i,j)\\) 的展开为 \\[ f(i,j)=\\max\\{f(i-1,j),f(i-1,j-v_i)+w_i,f(i-1,j-2v_i)+2w_i,f(i-1,j-3v_i)+w_i,\\cdots\\} \\] 当 \\(j=j-v_i\\) ，我们有 \\(f(i,j-v_i)\\) 的展开为 \\[ f(i,j-v_i)=\\max\\{f(i-1,j-v_i),f(i-1,j-2v_i)+w_i,f(i-1,j-3v_i)+2w_i,\\cdots\\} \\] 对比发现，\\(f(i,j-v_i)\\) 的展开式中 \\(\\max\\) 算子中的部分恰与 \\(f(i,j)\\) 展开式中 \\(\\max\\) 算子内第二项以后的部分近乎相同，只相差了一个 \\(w_i\\) 。由于完全背包问题中 \\(s_i=+\\infty\\) ，两部分是等势的。那么显然，我们可以将 \\(f(i,j)\\) 中第二项以后的部分直接变为 \\(f(i,j-v_i)+w_i\\)​ ，原理上面已经多次提到过了。那么就可以简化其状态转移方程为 \\[ f(i,j)=\\max\\{f(i-1,j),f(i,j-v_i)+w_i\\} \\] int n, m; int v[N], w[N]; int f[N][N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); &#125; &#125; /* output f[n][m] */ return 0; &#125; 这里对比一下 01 背包问题，我们会发现他们两个二维下的状态转移方程很像。 完全背包 \\[ f(i,j)=\\max\\{f(i-1,j),\\boxed{f(i,j-v_i)+w_i}\\} \\] 01 背包 \\[ f(i,j)=\\max\\{f(i-1,j),\\boxed{f(i-1,j-v_i)+w_i}\\} \\] 区别就在于二者第二项的更新来源不同，一个是从本轮更新，一个是从上一轮更新。 2.4 完全背包的一维优化 这里能够优化的原因和 01 背包完全相同，而且由上一讲关于与 01 背包的对比可以看到，完全背包使用的是本轮更新的状态，那么我们直接去掉一个维度即可，不会出现因上一轮状态被覆盖而更新错误的问题。 完全背包的一维状态转移方程写做 \\[ g_i(j)=\\max\\{g_{i-1}(j),g_i(j-v_i)+w_i\\} \\] 注：符号 \\(g_\\cdot(\\cdot)\\) 沿用 01 背包中的符号，以下均同。 int n, m; int v[N], w[N]; int f[N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = v[i]; j &lt;= m; j++) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; return 0; &#125; 三、多重背包问题 3.1 多重背包问题描述 要求为每件物品 \\(i\\)​​​​ 数量有限，即 \\(\\forall \\alpha_i\\in N,\\ s_i\\in\\Z^+\\)​​​​。 则数学描述为： \\[ \\begin{align} \\text{get }\\alpha_i\\in N\\Rightarrow\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_m),\\ \\forall \\alpha_i\\in N,\\ s_i\\in\\mathbb Z^+\\\\[3px] \\mathrm{s.t.}\\ \\ \\ \\ \\max\\sum_\\alpha w_i\\text{ , where } \\sum_\\alpha v_i\\le V \\end{align} \\] 3.2 多重背包的dp分析 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 表示所有选法的集合 满足的条件 只能从前 \\(i\\) 个物品里选 \\(\\sum_\\alpha v_i\\leq j\\)​​ 属性：需要存储的是什么属性 最大值：价值最大 状态计算 —— 集合的划分：不重、不漏 对于多重背包问题，集合的划分方式为 \\(f(i,j)\\Rightarrow\\{f(i,j,0),f(i,j,1),f(i,j,2),\\cdots,f(i,j,s_i)\\}\\)​ 。可以看到和完全背包问题是完全一致的。所以完全背包的三维状态转移方程为 \\[ f(i,j)=\\max\\{f(i-1,j),f(i-1,j-v_i)+w_i,f(i-1,j-2v_i)+2w_i,\\cdots,f(i-1,j-s_iv_i)+s_iw_i\\} \\] 简写做： \\[ f(i,j)=\\max\\{f(i-1,j-kv_i)+kw_i\\}\\ ,\\ k\\in[0,s_i]\\subset\\mathbb Z \\] 详细推导见完全背包问题。 三维的多重背包 int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++) &#123; f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); &#125; &#125; &#125; return 0; &#125; 3.3 多重背包的优化 同样的，当数据范围较大时，我们就需要优化多重背包问题。 我们有 \\(f(i,j)\\) 的展开为 \\[ f(i,j)=\\max\\{f(i-1,j),f(i-1,j-v_i)+w_i,f(i-1,j-2v_i)+2w_i,\\cdots\\ ,f(i-1,j-s_iv_i)+s_iw_i\\} \\] 当 \\(j=j-v_i\\) ，我们有 \\(f(i,j-v_i)\\) 的展开为 \\[ f(i,j-v_i)=\\max\\{f(i-1,j-v_i),f(i-1,j-2v_i)+w_i,\\cdots\\ ,f(i-1,j-s_iv_i)+(s_i-1)w_i,f(i-1,j-(s_i+1)v_i)+s_iw_i\\} \\] 这里可以看到， \\(f(i,j)\\)​ 相较于 \\(f(i,j-v_i)\\)​ 而言，确实 \\(f(i,j)\\)​ 的第 \\(2\\sim s_i+1\\)​ 项和 \\(f(i,j-v_i)\\)​ 的第 \\(1\\sim s_i\\)​ 项是很相似的，但是， \\(f(i,j-v_i)\\)​ 多出了一项 \\(\\boxed{f(i-1,j-(s_i+1)v_i)+s_iw_i}\\)​​ ，对于 \\(\\max\\)​​ 算子进行减法是不等价的变换方式，所以多重背包的优化不能够套用完全背包的优化方式。 多重背包问题经典的优化方式被称为二进制优化，即用二进制拆解数优化遍历次数到 \\(O(\\log_2n)\\)​​ 。 这里的思想和快速幂类似，快速幂的笔记中我们写过这样的两段话： …… 则最后我们的目的是将 \\(a^k\\)​ 拆成前面若干项乘积的形式，即假设 \\(a^k=a^{2^{r_1}} a^{2^{r_2}}\\cdots a^{2^{r_t}}\\)​ ，化简指数幂为 \\(a^k=a^{2^{r_1}+2^{r_2}+\\cdots+2^{r_t}}\\)​ ，于是显然有 \\(k=2^{r_1}+2^{r_2}+\\cdots+2^{r_t}\\)​ 成立，那么因为底数均为 \\(2\\)​ ，则有 \\(k=(r_1r_2\\cdots r_t)_2\\)​ 成立，即指数各项与 \\(k\\)​​​ 的二进制表示的各个数位一一对应…… [摘自【数论 2】] 于是如果 \\(k\\) 的二进制表示是 \\((x_mx_{m-1}\\cdots x_2x_1x_0)_2\\) ，那么我们就可以倒序使用位运算不断拆解 \\(k\\) ，由于次数从个位向上是递增的，且二进制表示下非 \\(0\\) 即 \\(1\\) ，那么也就是 \\(k\\) 的二进制表示有多少位，相对应的 \\(a^{2^i}\\) 就要进行平方多少次，能够得到某一位的因子，如果二进制表示下该位为 \\(1\\) ，则将这个因子与前面的结果相乘，最终便得到了 \\(a^k\\)。 [摘自【数论 2】] 对于一般的某数 \\(s\\)​​​​​​​​​​​ ，我们寻找 \\(k=\\displaystyle \\mathop{\\arg\\max}_x \\{2^x\\leq s\\},\\ C=s-(2^{k+1}-1)&lt;2^{k+1}\\)​​​​​​​​​​​​ ，则可以用集合 \\(\\{2^0,2^1,\\cdots,2^k,C\\}\\)​​​​​​​ ​去表示 \\([0,s]\\)​​​​​​​​ 内的所有整数，而且对于每一个数的表示方法唯一，对应每个元素非取则不取。 证明： ​ 对于 “二进制位” 集合 \\(B=\\{2^0,2^1,\\cdots,2^k\\}\\) ，我们可以表示 \\([0,2^{k+1}-1]\\) 内的所有整数。且每个元素非取则不取。原因是有如下等式成立： \\[ 2^0+2^1+\\cdots+2^k=2^{k+1}-1 \\] ​ 上式的证明非常简单，考虑等式左侧表示的二进制数 \\(b=\\underbrace{(111\\cdots1)_2}_{k\\text{ bit}}\\) 。其二进制转十进制展开对应形式就是等式左侧的形式。而 \\(b+1=\\underbrace{(1000\\cdots0)_2}_{k+1\\text{ bit}}\\) ，而显然的 \\(b+1=2^{k+1}\\) 。那么上式成立。上式证毕。 ​ 对于范围内的所有自然数，其二进制展开唯一，对应数位唯一，则元素取法唯一，非取则不取。则最初提到的结论成立。结论证毕。 ​ 那么我们现在距离 \\(s\\) 大小只差一点，由于幂级数已经不够再上涨，这时候就要补足一个常数去补足间距。我们有 \\(C=s-(2^{k+1}-1)\\) ，则有 \\(s=C+2^{k+1}-1\\) 。那么我们就可以表示 \\([C,s]\\) 的所有数了。 ​ 现在最后的问题就是 \\([0,s]=[0,2^{k+1}-1]\\cup[C,s]\\)​ 是否成立了。 由于我们全程数轴上、区间上只取整数，所以只要 \\(C\\leq2^{k+1}\\) 即可成立。那么显然，条件中对 \\(C\\) 的规定使得条件成立，那么区间拼凑成立。 ​ 那么这样我们就可以表示 \\([0,s]\\) 的所有数了。 ​ 证毕。 所以我们可以对物品的个数 \\(s_i\\) 进行拆分，拆分成总共 \\(\\log_2s_i\\)​ 个物品，之后对这总共 \\(\\log s_i\\)​ 个物品进行 01 背包，因为上面结论中已经写清每个元素非取则不取。则完全背包问题的时间复杂度降至 \\(O(NV\\log s)\\)​ 。 对于每个物品 \\(\\alpha_i=(v_i,w_i,s_i)\\)​​​​​​​​​ ，拆分成若干物品 \\(\\alpha_i\\Rightarrow\\beta_i=\\{x_1,x_2,\\cdots,x_{\\log_2s}\\}_i\\)​​​​​​​​​​ ，其中对于每个物品 \\(x_k=(kv_i,kw_i,k)\\)​​​​​​​​​​ ，最后产生全二进制拆解集 \\((\\beta_1,\\beta_2,\\cdots,\\beta_m)\\)​​​​​​ ，将里面的各 \\(\\beta\\)​​​ 中的 \\(x\\)​​​​ 项悉数展开并重新编号命名为 \\(y_\\cdot\\)​，得到新的物品集合 \\(N_{\\text{b}}=\\{y_1,y_2,\\cdots\\}\\)​​ 。最后使用一维的 01 背包优化，即 \\[ g_i(j)=\\max\\{g_i(j),g_{i-1}(j-v_i)+w_i\\} \\] 得到结果。 int n, m; int v[N], w[N]; int f[N]; int main() &#123; /* read in */ int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; cin >> a >> b >> s; int k = 1; while (k &lt;= s) &#123; cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; &#125; if (s > 0) &#123; cnt++; v[cnt] = a * s; w[cnt] = b * s; &#125; &#125; n = cnt; // 以下为 01 背包 for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; /* output f[m] */ return 0; &#125; 四、分组背包问题 4.1 分组背包问题描述 要求为共有 \\(\\cal N\\)​​​​​​​​ 组物品，要求每一组内只能选取一个物品，记每组物品中物品个数为 \\(\\{\\cal S _\\cal N\\}\\)​​ ，物品体积为 \\(\\{\\cal V_{\\cal N\\cal S_\\cal N}\\}\\) ，价值为 \\(\\{\\cal W_{\\cal N\\cal S_\\cal N}\\}\\)。记取出的每个物品所在的组别为 \\(\\cal \\{G_n\\}\\subset\\cal N\\) ，即存在 \\(\\alpha_i\\mapsto \\cal G_i\\)​​​​​​​​​ 。 则数学描述为： \\[ \\begin{align} \\text{get }\\alpha_i\\in N\\Rightarrow\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_m),\\ \\forall \\alpha_i\\in N,\\ s_i\\in\\mathbb Z^+,\\ \\forall \\alpha_i,\\alpha_j,\\ \\cal G_i\\ne\\cal G_j\\\\[3px] \\mathrm{s.t.}\\ \\ \\ \\ \\max\\sum_\\alpha w_i\\text{ , where } \\sum_\\alpha v_i\\le V \\end{align} \\] 4.2 分组背包的dp分析 状态表示 \\(f(i,j)\\) 集合：该状态表示的是哪一个集合 表示所有选法的集合 满足的条件 只能从前 \\(i\\)​ 组物品里选 \\(\\sum_\\alpha v_i\\leq j\\)​​ 属性：需要存储的是什么属性 最大值：价值最大 状态计算 —— 集合的划分：不重、不漏 分组背包问题需要注意，这里的条件变了，是从组中选择物品。那么分组背包问题的集合划分方式为 \\(f(i,j)\\Rightarrow\\{f(i,j,0),f(i,j,1),\\cdots,f(i,j,\\cal S_i)\\}\\)​​​​ 。这里第三个维度值代表了选取组别 \\(i\\) 中的第几个元素。这里来分析一下集合中每一个元素的值是什么。 \\[ \\begin{gather} f(i,j,0)=f(i-1,j)\\\\ \\vdots\\\\ f(i,j,k)=f(i-1,j-\\cal V_{ik})+\\cal W_{ik}\\\\ \\vdots\\\\ f(i,j,\\mathcal{S_i})=f(i-1,j-\\mathcal{V_{i\\mathcal S_i}})+\\cal W_{iS_i}\\\\ \\end{gather} \\] 代码的写法其实有了前面三个背包问题的分析这里也就是大同小异了。由于各种理由（这里略去），分组背包可以被简化至一维，使用滚动数组。 int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() &#123; /* read in */ for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= 0; j--) &#123; for (int k = 0; k &lt; s[i]; k++) &#123; if (v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); &#125; &#125; &#125; /* output f[m] */ return 0; &#125; 习题 AcWing 2 AcWing 2 C++ 朴素二维 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N][N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) cin >> v[i] >> w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; &#125; 一维优化 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) cin >> v[i] >> w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= v[i]; j--) &#123; f[j] = max(f[j] ,f[j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0; &#125; Python 朴素二维 if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ] f = [[0] * (m + 1) for _ in range(n + 1)] for _ in range(n): a, b = map(int, input().split()) v.append(a); w.append(b) for i in range(1, n + 1): for j in range(0, m + 1): f[i][j] = f[i - 1][j] if j >= v[i]: f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]) print(f[n][m]) 一维优化 if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ] f = [0] * (m + 1) for _ in range(n): a, b = map(int, input().split()) v.append(a); w.append(b); for i in range(1, n + 1): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i]) print(f[m]) AcWing 3 AcWing 3 C++ 朴素三维 会 TLE #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N][N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) cin >> v[i] >> w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k * v[i] &lt;= j; k++) &#123; f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); &#125; &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; &#125; 二维优化 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N][N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) cin >> v[i] >> w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; &#125; 一维优化 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 1010; int n, m; int v[N], w[N]; int f[N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) cin >> v[i] >> w[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = v[i]; j &lt;= m; j++) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0; &#125; Python 朴素三维 能过 if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ] f = [[0] * (m + 1) for _ in range(n + 1)] for _ in range(n): a, b = map(int, input().split()) v.append(a); w.append(b) for i in range(1, n + 1): for j in range(0, m + 1): k = 0 while k * v[i] &lt;= j: f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]) k += 1 print(f[n][m]) 二维优化 if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ] f = [[0] * (m + 1) for _ in range(n + 1)] for _ in range(n): a, b = map(int, input().split()) v.append(a); w.append(b) for i in range(1, n + 1): for j in range(0, m + 1): f[i][j] = f[i - 1][j] if j >= v[i]: f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]) print(f[n][m]) 一维优化 if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ] f = [0] * (m + 1) for _ in range(n): a, b = map(int, input().split()) v.append(a); w.append(b) for i in range(1, n + 1): for j in range(v[i], m + 1): f[j] = max(f[j], f[j - v[i]] + w[i]) print(f[m]) AcWing 4 AcWing 4 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 110; int n, m; int v[N], w[N], s[N]; int f[N][N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) cin >> v[i] >> w[i] >> s[i]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k * v[i] &lt;= j &amp;&amp; k &lt;= s[i]; k++) &#123; f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); &#125; &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; &#125; if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ]; s = [0, ] f = [[0] * (m + 1) for _ in range(n + 1)] for _ in range(n): a, b, c = map(int, input().split()) v.append(a); w.append(b); s.append(c) for i in range(1, n + 1): for j in range(m + 1): k = 0 while k * v[i] &lt;= j and k &lt;= s[i]: f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]); k += 1 print(f[n][m]) AcWing 5 AcWing 5 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 20010; int n, m; int v[N], w[N]; int f[N]; int main() &#123; cin >> n >> m; int cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; int a, b, c; cin >> a >> b >> c; int k = 1; while (k &lt;= c) &#123; cnt++; v[cnt] = a * k; w[cnt] = b * k; c -= k; k *= 2; &#125; if (c > 0) &#123; cnt++; v[cnt] = a * c; w[cnt] = b * c; &#125; &#125; n = cnt; for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0; &#125; if __name__ == '__main__': n, m = map(int, input().split()) v = [0, ]; w = [0, ]; s = [0, ] f = [0] * (m + 1) cnt = 0 for _ in range(n): k = 1 a, b, c = map(int, input().split()) while k &lt;= c: cnt += 1 v.append(a * k); w.append(b * k) c -= k k *= 2 if c > 0: cnt += 1 v.append(a * c); w.append(b * c) for i in range(1, cnt + 1): for j in range(m, v[i] - 1, -1): f[j] = max(f[j], f[j - v[i]] + w[i]) print(f[m]) AcWing 9 AcWing 9 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() &#123; cin >> n >> m; for (int i = 1; i &lt;= n; i++) &#123; cin >> s[i]; for (int j = 0; j &lt; s[i]; j++) &#123; cin >> v[i][j] >> w[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j >= 0; j--) &#123; for (int k = 0; k &lt; s[i]; k++) &#123; if (v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); &#125; &#125; &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0; &#125; if __name__ == '__main__': n, m = map(int, input().split()) N = 110 s = [0] * N v = [[0] * N for _ in range(N)]; w = [[0] * N for _ in range(N)] f = [0] * N for i in range(1, n + 1): num = int(input()) s[i] = num for j in range(s[i]): a, b = map(int, input().split()) v[i][j] = a; w[i][j] = b for i in range(1, n + 1): for j in range(m, -1, -1): for k in range(s[i]): if v[i][k] &lt;= j: f[j] = max(f[j], f[j - v[i][k]] + w[i][k]) print(f[m])","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"动态规划","slug":"Algorithm/AcWing/算法基础课/动态规划","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"DP","slug":"DP","permalink":"https://www.leolang.top/tags/DP/"}]},{"title":"AcWing 数学知识（六）","slug":"数学知识（六）博弈论","date":"2021-08-24T16:00:00.000Z","updated":"2021-08-25T13:32:44.000Z","comments":true,"path":"2021/08/25/数学知识（六）博弈论/","link":"","permalink":"https://www.leolang.top/2021/08/25/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%AD%EF%BC%89%E5%8D%9A%E5%BC%88%E8%AE%BA/","excerpt":"前言 本文将介绍有关博弈论的相关内容，包括 Nim 游戏，SG函数。","text":"前言 本文将介绍有关博弈论的相关内容，包括 Nim 游戏，SG函数。 数学知识（六）博弈论 一、NIM 游戏 1.1 NIM 游戏相关概念 NIM 游戏的一般形式为：（摘自蓝书） ​ 给定 \\(n\\) 堆物品，第 \\(i\\) 堆物品有 \\(A_i\\)​ 个，两名玩家轮流行动，每次可以任选一堆，取走任意多个物品。可把一堆取光，但不能不取。取走最后一件物品者胜。两人都采取最优策略，问先手能否必胜。 把游戏中面临的状态称为局面。若在某一局面下无论采取任何行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种举动，使得行动后对手面临必败局面，则优先采取该行动。同时，这样的局面称为必胜。 NIM 博弈不存在平局，只有先手必胜和先手必败两种情况。 1.2 定理 NIM 游戏先手必胜，当且仅当 \\(A_1\\text{ xor } A_2\\text{ xor }\\cdots\\text{ xor }A_n\\neq0\\) 证明： 首先，对于所有物品都被拿光的局面而言，有 \\[ A_1=A_2=\\cdots=A_n=0 \\] 成立。那么，此时必然有 \\[ A_1\\text{ xor } A_2\\text{ xor }\\cdots\\text{ xor }A_n=0\\text{ xor } 0\\text{ xor }\\cdots\\text{ xor }0=0 \\] 成立。显然，这是一个必败局面。 对于任意一个局面，如果有 \\(A_1\\text{ xor } A_2\\text{ xor }\\cdots\\text{ xor }A_n=x\\neq0\\)​​​​​​​ ，设 \\(x\\)​​​​​ 的二进制表示下最高位的 \\(1\\)​​​​​ 在第 \\(k\\)​​​​​​ 位，那么至少存在一堆石子 \\(A_i\\)​​​​​ ，其第 \\(k\\)​​​​​ 位是 \\(1\\)​​​​​ 。显然有 \\(A_i\\text{ xor }x&lt;A_i\\)​​​​​​ 成立（异或后的结果第 \\(k\\)​ 为会变为 \\(0\\)​ ，则结果一定更小），那么必然有一种操作是 \\(A_i\\to A_i\\text{ xor }x\\)​ ，这样就得到了 \\(\\text{xor }_1^nA_p=x\\text{ xor }x=0\\)​​​​​ 。 对于任意一个局面，如果有 \\(A_1\\text{ xor } A_2\\text{ xor }\\cdots\\text{ xor }A_n=0\\)​​ ，那么无论怎么取走石子，得到的局面下各堆异或都不等于 \\(0\\) 。可用反证法证明，假如进行操作 \\(A_i\\to A_i&#39;\\)​ 后仍有 \\(\\text{xor}_1^nA_p=0\\) ，则有 \\(A_i\\text{ xor }A_i&#39;=0\\) 。那么就有 \\(A_i=A_i&#39;\\) ，与 “不能不取石子” 矛盾。 证毕。 while (n--) &#123; int x; res ^= x; &#125; /* judge x */ 二、SG 函数 2.1 相关概念 2.1.1 公平组合游戏 ICG 若一个游戏满足： 由两名玩家交替行动； 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关； 不能行动的玩家判负； 则称该游戏为一个公平组合游戏。 NIM博弈属于公平组合游戏，但常见的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。 2.1.2 有向图游戏 给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。 2.2 Mex 运算 设 \\(S\\) 表示一个非负整数集合，定义 \\(\\mathrm{mex}(S)\\) 为求出不属于集合 \\(S\\) 的最小非负整数的运算，即： \\[ \\mathrm{mex}(S)=\\min_{x\\in\\N,x\\notin S}\\{x\\} \\] 2.3 SG 函数 在有向图游戏中，对于每个节点 \\(x\\) ，设从 \\(x\\) 出发共有 \\(k\\) 条有向边，分别到达节点 \\(y_1,y_2,\\cdots,y_k\\) ，定义 \\(\\mathrm{SG}(x)\\) 为 \\(x\\) 的后继节点 \\(y_1,y_2,\\cdots,y_k\\) 的 SG 函数值构成的集合再执行 Mex 运算的结果，即 \\[ \\mathrm{SG}(x)=\\mathrm{mex}(\\{\\mathrm{SG}(y_1),\\mathrm{SG}(y_2),\\cdots,\\mathrm{SG}(y_k)\\}) \\] 特别地，整个有向图游戏 \\(G\\) 的 SG 函数值被定义为有向图游戏起点 \\(s\\) 的 SG 函数值，即 \\(\\mathrm{SG}(G)=\\mathrm{SG}(s)\\) 2.4 定理 有向图游戏的某个局面必胜，当且仅当该局面对应的节点 SG 函数值大于 \\(0\\) 。 有向图游戏的某个局面必败，当且仅当该局面对应的节点 SG 函数值等于 \\(0\\) 。 2.5 有向图游戏的和 设设\\(G_1,G_2, \\cdots,G_m\\) 是 \\(m\\) 个有向图游戏。定义有向图游戏 \\(G\\)，它的行动规则是任选某个有向图游戏\\(G_i\\) ，并在\\(G_i\\) 上行动一步。\\(G\\) 被称为有向图游戏 \\(G_1,G_2,\\cdots,G_m\\) 的和。 有向图游戏的和的 SG 函数值等于它包含的各个子游戏 SG 函数值的异或和，即： \\[ \\mathrm{SG}(G)=\\mathrm{SG}(G_1)\\text{ xor }\\mathrm{SG}(G_2)\\text{ xor }\\cdots\\text{ xor }\\mathrm{SG}(G_m) \\] int n, m; int s[N], f[M]; // f 存储所有出现过的sg值 int sg(int x) &#123; // 记忆化搜索 if (f[x] != -1) return f[x]; // 已经算过这个数的sg值了，直接返回 unordered_set&lt;int> S; // 集合设立存储后继节点sg值，为方便后续进行 mex 操作 for (int i = 0; i &lt; m; i++) &#123; int sum = s[i]; if (x >= sum) S.insert(sg(x - sum)); // 循环集合中所有可能的情况进行DFS，如果还能合法地拿得出石子，就向下继续搜索，同时添加其后继节点的sg值进入集合中为后面进行mex操作做准备 &#125; for (int i = 0; ; i++) &#123; if (!S.count(i)) return f[x] = i; // mex操作 &#125; &#125; 习题 AcWing 891 AcWing 891 #include &lt;iostream> using namespace std; int n; int main() &#123; scanf(\"%d\", &amp;n); int res = 0; while (n--) &#123; int x; scanf(\"%d\", &amp;x); res ^= x; &#125; if (res != 0) puts(\"Yes\"); else puts(\"No\"); return 0; &#125; n = int(input()) res = 0 nums = list(map(int, input().split())) for num in nums: res ^= num if res != 0: print(\"Yes\") else: print(\"No\") AcWing 892 AcWing 892 将奇数台阶看为一个 Nim 游戏，先手必胜，当且仅当奇数台阶石子数异或值不为 \\(0\\) 。 证明： 对于局面 \\(\\mathrm{xor}\\{A_{2k+1}\\}\\ne0\\) ，由前面 Nim 游戏的证明，先手总能将局面变为 \\(\\mathrm{xor}\\{A_{2k+1}\\}=0\\)​​​ 。这时局面留给后手，分为两种情况： 后手动偶数阶的石子：先手应对就只需要将他移动的石子在移到下一台阶上去，这样保证了奇数阶石子数不变，于是奇数阶又可以应对原来的 \\(\\mathrm{xor}\\{A_{2k+1}\\}\\ne0\\) 的局面，也就自然又能留给后手 \\(\\mathrm{xor}\\{A_{2k+1}\\}=0\\) 的局面。 后手动奇数阶的石子：由于先手留给后手处理的是 \\(\\mathrm{xor}\\{A_{2k+1}\\}=0\\) 局面，那么后手如果动了奇数阶的石子，必然会使得局面变为 \\(\\mathrm{xor}\\{A_{2k+1}\\}\\ne0\\) 。（因为改变了原有异或为 \\(0\\) 的数中的单一个，则异或情况改变，异或值变为 \\(1\\) ）。同样的，先手自然还是能够使得局面变为 \\(\\mathrm{xor}\\{A_{2k+1}\\}=0\\)​ 而留给后手。 则对于该种情况而言，先手必胜 对于局面 \\(\\mathrm{xor}\\{A_{2k+1}\\}=0\\)​ ，可以通过反证法进行证明，证明思路同 Nim 游戏中的证明思路，此处略。 证毕。 #include &lt;iostream> using namespace std; int n; int main() &#123; scanf(\"%d\", &amp;n); int res = 0; for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(\"%d\", &amp;x); if (i &amp; 1) res ^= x; &#125; if (res != 0) puts(\"Yes\"); else puts(\"No\"); return 0; &#125; if __name__ == '__main__': n = int(input()) nums = list(map(int, input().split())) res = 0 for i in range(1, len(nums) + 1): if i &amp; 1: res ^= nums[i - 1] if res: print(\"Yes\") else: print(\"No\") AcWing 893 AcWing 893 #include &lt;iostream> #include &lt;cstring> #include &lt;unordered_set> using namespace std; const int N = 110, M = 10010; int k, n; int s[N], f[M]; int sg(int x) &#123; if (f[x] != -1) return f[x]; unordered_set&lt;int> S; for (int i = 0; i &lt; k; i++) &#123; int out = s[i]; if (x >= out) S.insert(sg(x - out)); &#125; for (int i = 0; ; i++) &#123; if (!S.count(i)) return f[x] = i; &#125; &#125; int main() &#123; scanf(\"%d\", &amp;k); for (int i = 0; i &lt; k; i++) scanf(\"%d\", &amp;s[i]); cin >> n; memset(f, -1, sizeof f); int res = 0; while (n--) &#123; int x; scanf(\"%d\", &amp;x); res ^= sg(x); &#125; if (res) puts(\"Yes\"); else puts(\"No\"); return 0; &#125; from collections import defaultdict def mex(S, x): i = 0 while True: if i not in S: f[x] = i return i i += 1 def sg(x): if x in f: return f[x] S = set() for v in s: if x >= v: S.add(sg(x - v)) return mex(S, x) if __name__ == '__main__': k = int(input()) s = list(map(int, input().split())) n = int(input()) res = 0 f = defaultdict() nums = list(map(int, input().split())) for num in nums: res ^= sg(num) if res: print(\"Yes\") else: print(\"No\") AcWing 896 AcWing 896 整体思路基本与集合 Nim 一致，唯一的区别在于搜索树中节点状态的分别。在拆分 Nim 中，每一个单状态进入下一状态都会产生两个搜索树 “分支” ，即一个有向图游戏会分支出两个有向图游戏。在 SG 函数中的体现为： \\[ \\mathrm{SG}(x)=\\mathrm{SG}(x_1)+\\mathrm{SG}(x_2)\\ (x_1,x_2&lt;x) \\] 于是此题就可以完全照搬上面的模板，只需要在 mex 的预备操作上做修改就可以了。 #include &lt;iostream> #include &lt;cstring> #include &lt;unordered_set> using namespace std; const int N = 110; int f[N]; int n; int sg(int x) &#123; if (f[x] != -1) return f[x]; unordered_set&lt;int> S; for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; S.insert(sg(i) ^ sg(j)); &#125; &#125; for (int i = 0; ; i++) &#123; if (!S.count(i)) return f[x] = i; &#125; &#125; int main() &#123; cin >> n; memset(f, -1, sizeof f); int res = 0; while (n--) &#123; int x; scanf(\"%d\", &amp;x); res ^= sg(x); &#125; if (res) puts(\"Yes\"); else puts(\"No\"); return 0; &#125; from collections import defaultdict def mex(S, x): i = 0 while True: if i not in S: f[x] = i return i i += 1 def sg(x): if x in f: return f[x] S = set() for i in range(0, x): for j in range(0, i + 1): S.add(sg(i) ^ sg(j)) return mex(S, x) if __name__ == '__main__': n = int(input()) nums = list(map(int, input().split())) res = 0 f = defaultdict() for num in nums: res ^= sg(num) if res: print(\"Yes\") else: print(\"No\")","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"https://www.leolang.top/tags/Game-Theory/"},{"name":"Nim games","slug":"Nim-games","permalink":"https://www.leolang.top/tags/Nim-games/"},{"name":"SG function","slug":"SG-function","permalink":"https://www.leolang.top/tags/SG-function/"}]},{"title":"AcWing 数学知识（五）","slug":"数学知识（五）容斥原理","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-25T13:31:02.000Z","comments":true,"path":"2021/08/24/数学知识（五）容斥原理/","link":"","permalink":"https://www.leolang.top/2021/08/24/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%94%EF%BC%89%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"前言 本文将介绍有关容斥原理的相关内容。","text":"前言 本文将介绍有关容斥原理的相关内容。 数学知识（五）容斥原理 求下 Venn 图 的总面积。 记总面积为 \\(S\\) ，大圆面积分别为 \\(S_1,S_2,S_3\\)​ ，三梨形区域面积分别为 \\(S_4,S_5,S_6\\) ，中间三圆交汇部分面积为 \\(S_7\\) \\[ S=S_1+S_2+S_3-S_4-S_5-S_6+S_7 \\] 总结规律如下： \\[ \\begin{align} S=&amp;+S_1+S_2+S_3(\\text{in 1 cir})\\\\ &amp;-S_1\\cap S_2-S_1\\cap S_3-S_2\\cap S_3(\\text{in 2 cir})\\\\ &amp;+S_1\\cap S_2\\cap S_3(\\text{in 3 cir}) \\end{align} \\] 推广至 \\(n\\)​ 个集合的 Venn 图： 简记交集为 \\(\\sigma(a_1,a_2,\\cdots,a_n)=\\displaystyle\\bigcap_{a_1,a_2,\\cdots,a_n}S_i=S_{a_1}\\cap S_{a_2}\\cap\\cdots\\cap S_{a_n}\\)​​​​ ，记 \\(\\sigma_k=\\mathrm{all}\\ \\sigma(x_1,\\cdots,x_k),\\forall x_i\\in[1,n]\\subset Z\\) ，规定 \\(\\sigma_1=\\mathrm{all}\\ S_i\\)​​​​​​ 。 \\[ S=\\sigma_1-\\sigma_2+\\cdots=\\large\\sum_{i=1}^n(-1)^{n-1}\\cdot \\sigma_n \\] 即 \\[ \\large\\bigcup_{i\\in[1,n]\\subset Z}|S_i|=\\large\\sum_{i=1}^n(-1)^{n-1}\\cdot |\\sigma_n| \\] 上述公式被称为容斥原理。 容斥原理公式中一共项数为： \\[ N=C_n^1+\\cdots+C_n^n=2^n-1 \\] 则时间复杂度为 \\(O(2^n)\\) 。 枚举集合情况可以写成 DFS ，一个比较nb的写法是运用位运算来进行枚举。 由于我们只需要枚举 \\([1,2^n-1]\\)​ 的情况，那么对于循环变量 \\(i\\)​ 我们可以将其看成一个二进制数，如果二进制位为 \\(1\\)​ 证明该集合被选中。例如 \\(\\displaystyle 5=(\\overbrace{0000\\cdots00101}^{n\\text{ bit}})\\)​​ ，就可以看成两个 \\(1\\) 位置的集合被选中。 int n, m; int p[N]; typedef long long LL; int main() &#123; /* read in */ int res = 0; for (int i = 1; i &lt; 1 &lt;&lt; m; i++) &#123; int t = 1, cnt = 0; for (int j = 0; j &lt; m; j++) &#123; if (i >> j &amp; 1) &#123; // this set is chosen if ((LL)t * p[j] > n) &#123; t = -1; break; &#125; t *= p[j]; cnt++; &#125; &#125; if (t != -1) &#123; if (cnt % 2) res += n / t; else res -= n / t; &#125; &#125; /* output */ return 0; &#125; 习题 AcWing 890 AcWing 890 #include &lt;iostream> using namespace std; typedef long long LL; const int N = 20; int n, m; int p[N]; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) scanf(\"%d\", &amp;p[i]); int res = 0; for (int i = 1; i &lt; 1 &lt;&lt; m; i++) &#123; int cnt = 0, t = 1; for (int j = 0; j &lt; m; j++) &#123; if (i >> j &amp; 1) &#123; if ((LL)p[j] * t > n) &#123; t = -1; break; &#125; t *= p[j]; cnt++; &#125; &#125; if (t != -1) &#123; if (cnt % 2) res += n / t; else res -= n / t; &#125; &#125; printf(\"%d\", res); return 0; &#125; if __name__ == '__main__': n, m = map(int, input().split()) primes = list(map(int, input().split())) res = 0 for i in range(1, 1 &lt;&lt; m): cnt = 0; t = 1 for j in range(0, m): if i >> j &amp; 1: if t * primes[j] > n: t = -1 break cnt += 1 t *= primes[j] if t != -1: res += int(n / t) if cnt % 2 else - int(n / t) print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Inclusion and Exclusion principle","slug":"Inclusion-and-Exclusion-principle","permalink":"https://www.leolang.top/tags/Inclusion-and-Exclusion-principle/"}]},{"title":"AcWing 数学知识（四）","slug":"数学知识（四）组合数","date":"2021-08-11T16:00:00.000Z","updated":"2021-08-25T13:28:46.000Z","comments":true,"path":"2021/08/12/数学知识（四）组合数/","link":"","permalink":"https://www.leolang.top/2021/08/12/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%84%E5%90%88%E6%95%B0/","excerpt":"前言 本文将介绍有关组合数在四种不同数据范围下的求法，之后将介绍关于卡特兰数的相关内容。","text":"前言 本文将介绍有关组合数在四种不同数据范围下的求法，之后将介绍关于卡特兰数的相关内容。 数学知识（四）组合数 一、组合数相关概念 求组合数 \\(C_a^b\\)​​ 的公式是 \\[ \\large\\begin{align} C_a^b &amp;=\\frac{a(a-1)\\cdots(a-b+1)}{1\\times2\\times3\\times\\cdots\\times b}\\\\ &amp;=\\frac{a!}{b!(a-b)!} \\end{align} \\] 高中学习过组合数有如下性质： \\[ C_a^b=C_{a-1}^b+C_{a-1}^{b-1} \\] 相关推导过程可以查阅有关资料，于是通过上面的公式就可以通过递推求出每一个组合数的值。 二、得到组合数结果 数值范围： \\(10^5\\)​​​ 组询问， \\(1\\leq b \\leq a\\leq 2000\\)​​​ 。正常递推算出每一个组合数 时间复杂度为 \\(O(n^2)\\) void init() &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; &#125; &#125; &#125; 数值范围： \\(10^4\\)​​​​​​​​ 组询问， \\(1\\leq b \\leq a\\leq 10^5\\)​​​​​​​​​ 。则需要预处理出每一个阶乘即阶乘的逆元（因为最后要取模，取模情况下除法 “不适用” ，需要转化为乘以分母的逆元，使用快速幂求解）。记阶乘为 \\(f_{\\mathrm{fac}}(i)\\)​​​​​​​​ ，逆元为 \\(f_{\\mathrm{fac}}^{-1}(i)\\)​​​​​​​​​ ，则公式写作： \\[ \\begin{align} C_a^b &amp;=\\frac{a!}{b!(a-b)!}\\\\ &amp;=f_{\\mathrm{fac}}(a)\\times f_{\\mathrm{fac}}^{-1}(a-b)\\times f_{\\mathrm{fac}}^{-1}(b) \\end{align} \\] 时间复杂度为 \\(O(n\\log n)\\) /** Defination for combination situation.2 * int fact[N], infact[N]; * typedef long long LL; */ int quickPow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; void init() &#123; fact[0] = infact[0] = 1; for (int i = 1; i &lt; N; i++) &#123; fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * quickPow(i, mod - 2, mod) % mod; &#125; &#125; /** output caution * printf(\"%d\", (LL)fact[a] * infact[a - b] % mod * infact[b] % mod); ** otherwise it can over range of &lt;int> */ 数值范围： \\(20\\) 组询问， \\(1\\leq b \\leq a\\leq 10^{18}\\) ， \\(1\\leq p\\leq 10^5\\)​​ 。则应用卢卡斯（Lucas）定理进行求解。 卢卡斯定理： \\[ \\begin{align} \\text{when } \\begin{cases} n=sp+q\\\\ m=tp+r \\end{cases}\\text{ then }\\\\ &amp;\\begin{pmatrix} n\\\\m \\end{pmatrix}= \\begin{pmatrix} sp+q\\\\tp+r \\end{pmatrix}\\equiv \\begin{pmatrix} s\\\\t \\end{pmatrix} \\begin{pmatrix} q\\\\r \\end{pmatrix}\\ (\\text{mod }p) \\end{align} \\] \\[ C_a^b\\equiv C_{a\\text{ mod }p}^{b\\text{ mod }p}\\cdot C_{a/p}^{b/p}\\ (\\text{mod p})\\ .\\text{ for }b\\le a,p\\in\\mathrm{prime}\\ N^+\\tag{a} \\] 时间复杂度为 \\(O(\\log_pn\\cdot p\\cdot\\log p)\\)​​​ 卢卡斯定理的证明： \\[ \\begin{align} \\text{change }a, b\\text{ to }(\\text{digit }p)\\Rightarrow\\\\ &amp;a=a_k\\cdot p^k+a_{k-1}\\cdot p^{k-1}+\\cdots+a_0\\cdot p^0\\\\ &amp;b=b_k\\cdot p^k+b_{k-1}\\cdot p^{k-1}+\\cdots+b_0\\cdot p^0\\\\ \\end{align} \\] ​ 生成函数法： \\[ (1+x)^p=1+C_p^1x+C_p^2x^2+\\cdots+C_p^px^p\\\\ \\] \\[ \\begin{align} (1+x)^p\\text{ mod }p &amp;=(1+C_p^1x+C_p^2x^2+\\cdots+C_p^px^p)\\text{ mod }p\\\\ &amp;=(C_p^0x^0+C_p^1x+C_p^2x^2+\\cdots+C_p^px^p)\\text{ mod }p\\\\ &amp;=(1+\\frac{p}1x+\\frac{p(p-1)\\cdots2}2x^2+\\cdots+x^p)\\text{ mod }p\\\\ &amp;=1+0+0+\\cdots+0+x^p \\ \\ \\Leftrightarrow\\boxed{(1+x)^p\\equiv1+x^p\\ (\\text{mod }p)\\tag{b}}\\\\ \\end{align} \\] \\[ \\Rightarrow\\text{Inference: }(1+x)^{p^m}\\equiv1+x^{p^k}(\\text{mod }p)\\tag{c} \\] \\[ \\begin{align} \\text{we have }a,b\\text{ as } \\begin{cases} a=(a_ka_{k-1}\\cdots a_0)_p\\\\ b=(b_kb_{k-1}\\cdots b_0)_p \\end{cases}\\text{ then}\\\\ (1+x)^a &amp;=(1+x)^{a_0}\\big((1+x)^p\\big)^{a_1}\\big((1+x)^{p^2}\\big)^{a_2}\\cdots\\big((1+x)^{p^k}\\big)^{a_k}\\\\ &amp;\\equiv \\big(1+x\\big)^{a_0}\\big(1+x^p\\big)^{a_1}\\big(1+x^{p^2}\\big)^{a_2}\\cdots\\big(1+x^{p^k}\\big)^{a_k}\\ (\\text{mod }p) \\end{align} \\] ​ 取等式 \\[ (1+x)^a\\equiv\\big(1+x\\big)^{a_0}\\big(1+x^p\\big)^{a_1}\\big(1+x^{p^2}\\big)^{a_2}\\cdots\\big(1+x^{p^k}\\big)^{a_k}\\ (\\text{mod }p)\\tag{d} \\] ​ 中所有因子中 \\(x^b\\) 项的系数（通过二项式定理展开每个因子），得到有如下的公式成立： \\[ C_a^b\\equiv C_{a_k}^{b_k}C_{a_{k-1}}^{b_{k-1}}\\cdots C_{a_0}^{b_0}\\ (\\text{mod }p) \\] ​ 即 \\[ \\begin{pmatrix} a\\\\b \\end{pmatrix} \\equiv \\begin{pmatrix} a_k\\\\b_k \\end{pmatrix} \\begin{pmatrix} a_{k-1}\\\\b_{k-1} \\end{pmatrix} \\cdots \\begin{pmatrix} a_0\\\\b_0 \\end{pmatrix}\\ (\\text{mod }p)\\tag{e} \\] ​ 证毕。 注意， \\(\\text{Eq.e}\\)​​ 是一个递推式的完全展开式，到此还无法直观看出形如 \\(\\text{Eq.a}\\)​​ 的形式。我们下面将其继续向下推导一步使之更加直观： 对于 \\(p\\) 进制下的 \\(a,b\\) ，由于 \\[ \\begin{align} &amp;\\begin{cases} a\\text{ mod }p=a_0\\\\[3px] b\\text{ mod }p=b_0 \\end{cases}\\tag{f.a}\\\\[10px] &amp;\\begin{cases} a/p=a_k\\cdot p^{k-1}+a_{k-1}\\cdot p^{k-2}+\\cdots+{a_1\\cdot p^0}+0\\\\[3px] b/p=b_k\\cdot p^{k-1}+b_{k-1}\\cdot p^{k-2}+\\cdots+{b_1\\cdot p^0}+0 \\end{cases}\\tag{f.b}\\\\ \\end{align}\\tag{f} \\] 由 \\(\\text{Eq.(f.a)}\\)​​​ 有 \\(\\begin{pmatrix} a\\text{ mod }p\\\\ b\\text{ mod }p \\end{pmatrix}= \\begin{pmatrix} a_0\\\\ b_0 \\end{pmatrix}\\)​​ 。 记 \\(\\sigma:x\\to x/p\\ (x\\in Z)\\)​​​​​​​ ，规定 \\(\\sigma^n=\\sigma\\circ\\sigma^{n-1},\\sigma^0(x)=x\\) 。则 \\(\\text{Eq.(f.b)}\\) 可被写作 \\[ \\begin{gather} \\sigma(a)=a_k\\cdot p^{k-1}+a_{k-1}\\cdot p^{k-2}+\\cdots+{a_1\\cdot p^0}\\\\ \\sigma(b)=b_k\\cdot p^{k-1}+b_{k-1}\\cdot p^{k-2}+\\cdots+{b_1\\cdot p^0} \\end{gather}\\tag{f.b&#39;} \\] 做换元 \\(t=k-1\\)​ ，则上式写做 \\[ \\begin{gather} \\sigma(a)=a_k\\cdot p^{m}+a_{m}\\cdot p^{m-1}+\\cdots+{a_1\\cdot p^0}\\\\ \\sigma(b)=b_k\\cdot p^{m}+b_{m}\\cdot p^{m-1}+\\cdots+{b_1\\cdot p^0} \\end{gather}\\tag{f.b&#39;&#39;} \\] 我们把前面我们对于 \\(a,b\\) 的 \\(p\\)​ 进制展开拿过来对比一下 \\[ \\begin{gather} a=a_k\\cdot p^k+a_{k-1}\\cdot p^{k-1}+\\cdots+a_0\\cdot p^0\\\\ b=b_k\\cdot p^k+b_{k-1}\\cdot p^{k-1}+\\cdots+b_0\\cdot p^0\\\\ \\end{gather} \\] 于是我们发现，这里和上面的形式是完全一样的，于是我们可以对 \\(\\sigma(a),\\sigma(b)\\)​​ 执行上面同样的过程（生成函数法）。这里详细的推导过程略去，我们最后可以得到 \\[ \\begin{pmatrix} \\sigma(a)\\\\ \\sigma(b)\\\\ \\end{pmatrix}= \\begin{pmatrix} a_k\\\\b_k \\end{pmatrix} \\begin{pmatrix} a_{k-1}\\\\b_{k-1} \\end{pmatrix} \\cdots \\begin{pmatrix} a_1\\\\b_1 \\end{pmatrix} \\] 那么显然，\\(\\text{Eq.e}\\) 可写做 \\[ \\begin{pmatrix} a\\\\b \\end{pmatrix} \\equiv \\begin{pmatrix} \\sigma(a)\\\\ \\sigma(b)\\\\ \\end{pmatrix} \\begin{pmatrix} a_0\\\\b_0 \\end{pmatrix}\\ (\\text{mod }p)\\tag{e&#39;} \\] 将我们上面设立的记号还原回去，便有 \\(\\text{Eq.a}\\Leftrightarrow\\text{Eq.e&#39;}\\)​ 。当然了这个式子是递推式，自然有 \\[ \\begin{pmatrix} \\sigma(a)\\\\ \\sigma(b)\\\\ \\end{pmatrix} \\equiv \\begin{pmatrix} \\sigma^2(a)\\\\ \\sigma^2(b)\\\\ \\end{pmatrix} \\begin{pmatrix} a_0\\\\b_0 \\end{pmatrix}\\ (\\text{mod }p)\\tag{e&#39;&#39;} \\] 等一系列形如 \\[ \\begin{pmatrix} \\sigma^m(a)\\\\ \\sigma^m(b)\\\\ \\end{pmatrix} \\equiv \\begin{pmatrix} \\sigma^{m-1}(a)\\\\ \\sigma^{m-1}(b)\\\\ \\end{pmatrix} \\begin{pmatrix} a_0\\\\b_0 \\end{pmatrix}\\ (\\text{mod }p)\\ (m\\in N\\backslash0)\\tag{g} \\] /** Defination for combination situation.3 * typedef long long LL; * int p; */ int quickPow(int a, int k) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; &#125; return res; &#125; int C(int a, int b) &#123; int res = 1; for (int i = 1, j = a; i &lt;= b; i++, j--) &#123; res = (LL)res * j % p; res = (LL)res * quickPow(i, p - 2) % p; &#125; return res; &#125; int lucas(LL a, LL b) &#123; if (a &lt; p &amp;&amp; b &lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; &#125; 虽然组合数很大，但要求求出其原始结果，不取模 思路是直接从定义出发，直接算高精度乘除法。 \\[ \\begin{align} C_a^b &amp;=\\frac{a(a-1)\\cdots(a-b+1)}{1\\times2\\times3\\times\\cdots\\times b}\\\\ &amp;=\\frac{a!}{b!(a-b)!} \\end{align} \\] 但这样实现效率很低而且要写高精度的 mul() 、div() 比较麻烦。那优化的方式就是将 \\(C_a^b\\) 分解质因数，变为 \\[ \\large C_a^b=p_1^{r_1}p_2^{r_2}\\cdots p_k^{r_k} \\] 这样就只需要实现高精度乘法 mul() 就可以了。 那么如何求阶乘中包含多少个 \\(p_i\\) 呢？有这样的公式： 记 \\(N_{p_i}(x)\\)​​​​​​ 为数 \\(x\\)​​​​ 中 \\(p_i\\)​​​​​​​ 的个数，则 \\[ \\begin{align} N_{p}(a!) &amp;=\\lfloor\\frac a p\\rfloor+\\lfloor\\frac a {p^2}\\rfloor+\\lfloor\\frac a {p^3}\\rfloor+\\cdots\\\\ &amp;=\\large\\sum_{\\frac{a}{p^i}&gt;0}\\lfloor\\frac a {p^i}\\rfloor \\end{align} \\] 公式的意思是每次取出一个 \\(p\\)​ ，就相当于 \\(p\\to p^2\\to p^3\\to \\cdots\\)​​​ ，每次都拿出来一个，看看最后拿完能拿出来多少。 /** Defination for combination situation.4 * int primes[N], cnt; * bool st[N]; * int sum[N]; */ void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[prinmes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; int getp(int n, int p) &#123; // get how many p in n int res = 0; while (n) &#123; res += n / p; n /= p; &#125; return res; &#125; vector&lt;int> mul(vector&lt;int> a, int b) &#123; if (!b) return &#123;0&#125;; vector&lt;int> c; int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t += a[i] * b; c.push_back(t % 10); t /= 10; &#125; while (t) &#123; c.push_back(t % 10); t /= 10; &#125; return c; &#125; int main() &#123; /* read in */ getPrimes(a); // because a >= b for (int i = 0; i &lt; cnt; i++) &#123; int p = primes[i]; sum[i] = getp(a, p) - getp(b, p) - getp(a - b, p); &#125; vector&lt;int> res; res.push_back(1); for (int i = 0; i &lt; cnt; i++) &#123; for (int j = 0; j &lt; sum[i]; j++) &#123; res = mul(res, primes[i]); &#125; &#125; for (int i = res.size() - 1; i >= 0; i--) printf(\"%d\", res[i]); return 0; &#125; 三、卡特兰数 卡特兰数（Catalan number），又称明安图数。 卡特兰数 \\(C_n\\) 满足如下递推关系： \\[ \\begin{gather} C_{n+1}=C_0C_n+C_1C_{n-1}+\\cdots+C_nC_0\\\\ (n-3)C_n=\\frac n 2(C_3C_{n-1}+C_4C_{n-2}+C_5C_{n-3}+\\cdots+C_{n-2}C_4+C_{n-1}C_3) \\end{gather} \\] 卡特兰数的另类递推式有： \\[ \\begin{align} &amp;C_n=C_{n-1}\\times\\frac{4n-2}{n+1}\\\\ &amp;C_{n+1}=C_n\\times\\frac{4n+2}{n+2} \\end{align} \\] 其中，\\(C_1=1\\) 。 为防止符号冲突，记 \\(\\delta(x,y)=\\begin{pmatrix} x\\\\y \\end{pmatrix}\\) 递推关系的解为： \\[ C_n=\\frac{ \\delta(2n,n) }{n+1}=\\frac{\\delta(2n,n)}{\\delta(2n,n-1)}(n\\in N) \\] 很多问题的解是卡特兰数。 求解卡特兰数 int quickPow(int a, int b, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; &#125; return res; &#125; int main() &#123; /* read in */ int res = 1; int a = 2 * n, b = n; for (int i = a; i > a - b; i--) res = (LL)res * i % mod; for (int i = 1; i &lt;= b; i++) res = (LL)res * quickPow(i, mod - 2, mod) % mod; res = (LL)res * quickPow(n + 1, mod - 2, mod) % mod; /* output */ &#125; 习题 AcWing 885 AcWing 885 #include &lt;iostream> using namespace std; const int N = 2010, mod = 1e9 + 7; int n; int c[N][N]; void init() &#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod; &#125; &#125; &#125; int main() &#123; init(); scanf(\"%d\", &amp;n); while (n--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", c[a][b]); &#125; return 0; &#125; def init(): global N mod = int(1e9 + 7) for i in range(N): for j in range(i + 1): c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod if j else 1 if __name__ == '__main__': n = int(input()) N = 2010 c = [[0] * N for _ in range(N)] init() for _ in range(n): a, b = map(int, input().split()) print(c[a][b]) AcWing 886 AcWing 886 #include &lt;iostream> using namespace std; typedef long long LL; const int N = 100010, mod = 1e9 + 7; int n; int fact[N], infact[N]; int quickPow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; void init() &#123; fact[0] = infact[0] = 1; for (int i = 1; i &lt; N; i++) &#123; fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * quickPow(i, mod - 2, mod) % mod; &#125; &#125; int main() &#123; scanf(\"%d\", &amp;n); init(); while (n--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); int res = (LL)fact[a] * infact[a - b] % mod * infact[b] % mod; printf(\"%d\\n\", res); &#125; return 0; &#125; def quickPow(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k >>= 1 a = a * a % p return res if __name__ == '__main__': n = int(input()) N = int(1e5 + 10) mod = int(1e9 + 7) fact = [0] * N; infact = [0] * N fact[0] = infact[0] = 1 for i in range(1, N): fact[i] = fact[i - 1] * i % mod infact[i] = infact[i - 1] * quickPow(i, mod - 2, mod) % mod for _ in range(n): a, b = map(int, input().split()) print(fact[a] * infact[a - b] % mod * infact[b] % mod) AcWing 887 AcWing 887 #include &lt;iostream> using namespace std; typedef long long LL; int p; int quickPow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; int C(int a, int b) &#123; int res = 1; for (int i = 1, j = a; i &lt;= b; i++, j--) &#123; res = (LL)res * j % p; res = (LL)res * quickPow(i, p - 2, p) % p; &#125; return res; &#125; int lucas(LL a, LL b) &#123; if (a &lt; p &amp;&amp; b &lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; LL a, b; scanf(\"%lld%lld%d\", &amp;a, &amp;b, &amp;p); int res = lucas(a, b); printf(\"%d\\n\", res); &#125; return 0; &#125; def quickPow(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k >>= 1 a = a * a % p return res def C(a, b, p): res = 1 j = a for i in range(1, b + 1): res = res * j % p res = res * quickPow(i, p - 2, p) % p j -= 1 return res def lucas(a, b, p): if a &lt; p and b &lt; p: return C(a, b, p) return C(a % p, b % p, p) * lucas(a // p, b // p, p) % p if __name__ == '__main__': n = int(input()) for _ in range(n): a, b, p = map(int, input().split()) res = lucas(a, b, p) print(res) AcWing 888 AcWing 888 #include &lt;iostream> #include &lt;vector> using namespace std; const int N = 5010; int primes[N], cnt; bool st[N]; int sum[N]; void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; int getp(int n, int p) &#123; int res = 0; while (n) &#123; res += n / p; n /= p; &#125; return res; &#125; vector&lt;int> mul(vector&lt;int> a, int b) &#123; if (b == 0) return &#123;0&#125;; vector&lt;int> res; int t = 0; for (int i = 0; i &lt; a.size(); i++) &#123; t = a[i] * b + t; res.push_back(t % 10); t /= 10; &#125; while (t) &#123; res.push_back(t % 10); t /= 10; &#125; return res; &#125; int main() &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); getPrimes(a); for (int i = 0; i &lt; cnt; i++) &#123; int p = primes[i]; sum[i] = getp(a, p) - getp(b, p) - getp(a - b, p); &#125; vector&lt;int> res; res.push_back(1); for (int i = 0; i &lt; cnt; i++) &#123; for (int j = 0; j &lt; sum[i]; j++) &#123; res = mul(res, primes[i]); &#125; &#125; for (int i = res.size() - 1; i >= 0; i--) printf(\"%d\", res[i]); return 0; &#125; def getPrimes(n): i = 2 while i &lt;= n: if not st[i]: primes.append(i) j = 0 while primes[j] &lt;= n / i: st[primes[j] * i] = True if i % primes[j] == 0: break j += 1 i += 1 def getp(n, p): res = 0 while n: res += n // p n //= p return res if __name__ == '__main__': a, b = map(int, input().split()) primes = [] st = [False] * (a + 10) getPrimes(a) sum = [] for prime in primes: cnt = getp(a, prime) - getp(b, prime) - getp(a - b, prime) sum.append(cnt) res = 1 for i in range(len(primes)): res *= primes[i] ** sum[i] print(res) Python 的 粗暴写法 from math import factorial a, b = map(int, input().split()) res = factorial(a) // (factorial(a - b) * factorial(b)) print(res) AcWing 889 AcWing 889 #include &lt;iostream> using namespace std; typedef long long LL; const int mod = 1e9 + 7; int quickPow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); int res = 1; for (int i = 2 * n; i > n; i--) res = (LL)res * i % mod; for (int i = 1; i &lt;= n; i++) res = (LL)res * quickPow(i, mod - 2, mod) % mod; res = (LL)res * quickPow(n + 1, mod - 2, mod) % mod; printf(\"%d\", res); return 0; &#125; def quickPow(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k >>= 1 a = a * a % p return res if __name__ == '__main__': n = int(input()) res = 1 mod = int(1e9 + 7) for i in range(2 * n, n, -1): res = res * i % mod for i in range(1, n + 1): res = res * quickPow(i, mod - 2, mod) % mod res = res * quickPow(n + 1, mod - 2, mod) % mod print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Combination number","slug":"Combination-number","permalink":"https://www.leolang.top/tags/Combination-number/"}]},{"title":"AcWing 数学知识（三）","slug":"数学知识（三）高斯消元","date":"2021-08-09T16:00:00.000Z","updated":"2021-08-25T13:47:40.000Z","comments":true,"path":"2021/08/10/数学知识（三）高斯消元/","link":"","permalink":"https://www.leolang.top/2021/08/10/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"前言 本文将介绍有关解线性方程组的高斯消元法的相关内容，并给出算法模板。","text":"前言 本文将介绍有关解线性方程组的高斯消元法的相关内容，并给出算法模板。 数学知识（三）高斯消元 一、预备知识 高斯消元可以在 \\(O(n^3)\\)​ 的时间复杂度内解出一个含 \\(n\\)​ 个变量的多元线性方程组： \\[ \\begin{cases} a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n=b_1\\\\ a_{21}x_1+a_{22}x_2+\\cdots+a_{2n}x_n=b_2\\\\ \\cdots\\cdots\\\\ a_{n1}x_1+a_{n2}x_2+\\cdots+a_{nn}x_n=b_n\\\\ \\end{cases} \\] 方程组可表示为 \\[ \\begin{pmatrix} a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\\\ a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\ \\vdots&amp;\\ddots&amp;&amp;\\vdots\\\\ \\vdots&amp;&amp;\\ddots&amp;\\vdots\\\\ a_{n1}&amp;a_{n2}&amp;\\cdots&amp;a_{nn}\\\\ \\end{pmatrix} \\times \\begin{pmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{pmatrix} = \\begin{pmatrix} a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\\\ a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\ \\vdots&amp;\\ddots&amp;&amp;\\vdots\\\\ \\vdots&amp;&amp;\\ddots&amp;\\vdots\\\\ a_{n1}&amp;a_{n2}&amp;\\cdots&amp;a_{nn}\\\\ \\end{pmatrix} \\times \\begin{pmatrix} x_1,x_2,\\cdots,x_n \\end{pmatrix}^\\mathrm T=Ax^{\\mathrm T} \\] 系数矩阵 \\[ \\text{coefficient matrix }A= \\begin{pmatrix} a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\\\ a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\ \\vdots&amp;\\ddots&amp;&amp;\\vdots\\\\ \\vdots&amp;&amp;\\ddots&amp;\\vdots\\\\ a_{n1}&amp;a_{n2}&amp;\\cdots&amp;a_{nn}\\\\ \\end{pmatrix} \\] 增广矩阵 \\[ \\text{augmented matrix }\\tilde A=(A,b)= \\begin{pmatrix} a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}&amp;b_1\\\\ a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}&amp;b_2\\\\ \\vdots&amp;\\ddots&amp;&amp;&amp;\\vdots\\\\ \\vdots&amp;&amp;\\ddots&amp;&amp;\\vdots\\\\ \\vdots&amp;&amp;&amp;\\ddots&amp;\\vdots\\\\ a_{n1}&amp;a_{n2}&amp;\\cdots&amp;a_{nn}&amp;b_n\\\\ \\end{pmatrix} \\] 矩阵的初等变换（以初等行变换为例），变换后的矩阵等价： \\(r_i\\times k\\ (k\\ne0)\\)​​​ \\(r_i\\leftrightarrow r_j\\)​​ \\(r_i\\times k+r_j\\) 通过矩阵的初等变换将系数矩阵 \\(A\\) 变为上三角矩阵 \\[ A&#39;=\\begin{pmatrix} a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\\\ &amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\ &amp;\\ddots&amp;&amp;\\vdots\\\\ &amp;&amp;\\ddots&amp;\\vdots\\\\ &amp;&amp;&amp;a_{nn}\\\\ \\end{pmatrix} \\] 方程变为 \\[ \\begin{cases} a_{11}x_1+&amp;a_{12}x_2+&amp;\\cdots+&amp;a_{1n}x_n&amp;=b_1\\\\ &amp;a_{22}x_2+&amp;\\cdots+&amp;a_{2n}x_n&amp;=b_2\\\\ &amp;&amp;\\cdots+&amp;\\cdots\\\\ &amp;&amp;&amp;x_n&amp;=b_n \\end{cases} \\] 我们得到了 \\(x_n\\) 的值，于是向上倒推出所有变量的值 \\[ \\left\\{ \\begin{array}{cc} a_{11}x_1+&amp;a_{12}x_2+&amp;\\cdots+&amp;a_{1n}x_n&amp;=b_1\\\\ &amp;a_{22}x_2+&amp;\\cdots+&amp;a_{2n}x_n&amp;=b_2\\\\ &amp;&amp;\\cdots+&amp;\\cdots\\\\ &amp;&amp;&amp;x_n&amp;=b_n \\end{array} \\ \\ \\ \\ \\right\\uparrow \\Rightarrow x_{i\\ \\downarrow} \\] 解的情况有三种：无解、有无穷多组解、有唯一解 唯一解：方程组可被化为如上形式的阶梯型矩阵 无解：方程组中某一方城产生矛盾 \\(0=C\\ (C\\neq0)\\)​ 无穷多解：方程组中一个方程可有另外的方程组中方程线性表示，即存在 \\(0=0\\) 二、高斯消元 高斯消元的步骤： 对于增广矩阵 \\(\\tilde A\\)​​ ，枚举每一列 \\(c_k\\)​​ ，初始 \\(k=1\\) 找到列 \\(c_k\\) 未处理过的行（未处理过的方程）中绝对值最大的一元素，将该行换到最上面，即假设绝对值最大的一行为 \\(r_t\\) ，则进行变换 \\(r_t\\leftrightarrow r_k\\)​​​ 将该行第一个非零数（就是上面找到的绝对值最大的元素）变为 \\(1\\)​​​​​​​​​ ，相应的，其余各元素都乘以一个倍数。设当前第一个元素为 \\(a_{kj}\\)​​​​​​​ ，则对矩阵进行变换：\\(\\displaystyle r_k\\times\\frac 1 {a_{kj}}\\)​​​​​​​​​ 用 \\(a_{kj}=1\\)​​​​​ 将下面所有行的当前列消为 \\(0\\)​​​​​​​ ，即对矩阵进行变换 \\(\\forall i,\\displaystyle-r_k\\times\\frac{a_{ij}}{a_{kj}}+r_i\\)​​​​​ \\(k=k+1\\)​ ，进行下一轮迭代，直至 \\(k=n\\) /** Defination for Gauss-Jordan Elimination * double a[N][N]; // store Equations * const double eps = 1e-6; // error &lt; eps see as 0 * define func&lt;gauss> return value: * return 0: has only one solution * return 1: has infinite group solutions * return 2: has not solution */ int gauss() &#123; int c, r; for (c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) &#123; // get max value from column&lt;c> if (fabs(a[i][c]) > fabs(a[t][c])) t = i; &#125; if (fabs(a[t][c]) &lt; eps) continue; // judge if it is 0 for (int i = c; i &lt;= n; i++) swap(a[t][i], a[r][i]); for (int i = n; i >= c; i--) a[r][i] /= a[r][c]; for (int i = r + 1; i &lt; n; i++) &#123; if (fabs(a[i][c]) > eps) &#123; for (int j = n; j >= c; j--) &#123; a[i][j] -= a[r][j] * a[i][c]; &#125; &#125; &#125; r++; &#125; if (r &lt; n) &#123; for (int i = r; i &lt; n; i++) &#123; if (fabs(a[i][n]) > eps) return 2; &#125; return 1; &#125; for (int i = n - 1; i >= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; a[i][n] -= a[i][j] * a[j][n]; &#125; &#125; return 0; &#125; 习题 AcWing 883 AcWing 883 #include &lt;iostream> #include &lt;cmath> using namespace std; const int N = 110; const double eps = 1e-6; double a[N][N]; int n; int gauss() &#123; int c, r; for (c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) &#123; if (fabs(a[i][c]) > fabs(a[t][c])) t = i; &#125; if (fabs(a[t][c]) &lt; eps) continue; for (int i = c; i &lt; n + 1; i++) swap(a[t][i], a[r][i]); for (int i = n; i >= c; i--) a[r][i] /= a[r][c]; for (int i = r + 1; i &lt; n; i++) &#123; if (fabs(a[i][c]) > eps) &#123; for (int j = n; j >= c; j--) &#123; a[i][j] -= a[r][j] * a[i][c]; &#125; &#125; &#125; r++; &#125; if (r &lt; n) &#123; for (int i = r; i &lt; n; i++) &#123; if (fabs(a[i][n]) > eps) return 2; &#125; return 1; &#125; for (int i = n - 1; i >= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; a[i][n] -= a[i][j] * a[j][n]; &#125; &#125; return 0; &#125; int main() &#123; cin >> n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; cin >> a[i][j]; &#125; &#125; int res = gauss(); if (res == 0) &#123; for (int i = 0; i &lt; n; i++) printf(\"%.2lf\\n\", a[i][n]); &#125; else if (res == 1) puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0; &#125; def gauss(): global n eps = 1e-6 r = 0 for c in range(n): t = r for i in range(r, n): if abs(mat[i][c]) > abs(mat[t][c]): t = i if abs(mat[t][c]) &lt; eps: continue for i in range(c, n + 1): mat[t][i], mat[r][i] = mat[r][i], mat[t][i] for i in range(n, c - 1, -1): mat[r][i] /= mat[r][c] for i in range(r + 1, n): if abs(mat[i][c]) > eps: for j in range(n, c - 1, -1): mat[i][j] -= mat[r][j] * mat[i][c]; r += 1 if r &lt; n: for i in range(r, n): if abs(mat[i][n] > eps): return 2 return 1 for i in range(n - 1, -1, -1): for j in range(i + 1, n): mat[i][n] -= mat[i][j] * mat[j][n] return 0 if __name__ == '__main__': n = int(input()) mat = [list(map(float, input().split())) for _ in range(n)] res = gauss() if res == 0: for i in range(n): print(\"%.2f\" % mat[i][n]) elif res == 1: print(\"Infinite group solutions\") else: print(\"No solution\") AcWing 884 AcWing 884 #include &lt;iostream> using namespace std; const int N = 110; int n; int a[N][N]; int gauss() &#123; int c, r; for (c = 0, r = 0; c &lt; n; c++) &#123; int t = r; for (int i = r; i &lt; n; i++) &#123; if (a[i][c] == 1) &#123; t = i; break; &#125; &#125; if (!a[t][c]) continue; for (int i = c; i &lt; n + 1; i++) swap(a[r][i], a[t][i]); for (int i = r + 1; i &lt; n; i++) &#123; if (a[i][c]) &#123; for (int j = n; j >= c; j--) &#123; a[i][j] ^= a[r][j]; &#125; &#125; &#125; r++; &#125; if (r &lt; n) &#123; for (int i = r; i &lt; n; i++) &#123; if (a[i][n]) return 2; &#125; return 1; &#125; for (int i = n - 1; i >= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; a[i][n] ^= a[i][j] &amp; a[j][n]; &#125; &#125; return 0; &#125; int main() &#123; cin >> n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; cin >> a[i][j]; &#125; &#125; int res = gauss(); if (res == 0) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i][n] &lt;&lt; endl; &#125; else if (res == 1) puts(\"Multiple sets of solutions\"); else puts(\"No solution\"); return 0; &#125; def gauss(): global n r = 0 for c in range(n): t = r for i in range(r, n): if a[i][c]: t = i break if not a[t][c]: continue a[r], a[t] = a[t], a[r] for i in range(r + 1, n): if a[i][c]: for j in range(n, c - 1, -1): a[i][j] ^= a[r][j] r += 1 if r &lt; n: for i in range(r, n): if a[i][n]: return 2 return 1 for i in range(n - 1, -1, -1): for j in range(i + 1, n): a[i][n] ^= a[i][j] &amp; a[j][n] return 0 if __name__ == '__main__': n = int(input()) a = [list(map(int, input().split())) for _ in range(n)] res = gauss() if res == 0: for i in range(n): print(a[i][n]) elif res == 1: print(\"Multiple sets of solutions\") else: print(\"No solution\")","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Gauss-Jordan Elimination","slug":"Gauss-Jordan-Elimination","permalink":"https://www.leolang.top/tags/Gauss-Jordan-Elimination/"}]},{"title":"AcWing 数学知识（二）","slug":"数学知识（二）数论 2","date":"2021-08-07T16:00:00.000Z","updated":"2021-08-25T13:29:14.000Z","comments":true,"path":"2021/08/08/数学知识（二）数论 2/","link":"","permalink":"https://www.leolang.top/2021/08/08/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E8%AE%BA%202/","excerpt":"前言 本文将继续介绍数论的有关内容。内容包括欧拉函数、快速幂、扩展欧几里得算法、中国剩余定理。将给出相关定理证明及算法实现模板。","text":"前言 本文将继续介绍数论的有关内容。内容包括欧拉函数、快速幂、扩展欧几里得算法、中国剩余定理。将给出相关定理证明及算法实现模板。 数学知识（二）数论 2 一、欧拉函数 1.1 欧拉函数公式 欧拉函数 \\(\\varphi(n)\\)​​ 为 \\([1,n]\\)​​ 中与 \\(n\\)​​ 互质的数的个数。由离散数学知识，对于一个正整数 \\(N\\)​​ ，由算数基本定理，若其标准分解式为 \\(N=p_1^{m_1}p_2^{m_2}\\cdots p_k^{m_k}(p_1&lt;p_2&lt;\\cdots&lt;p_k)\\)​​​ ，则有 \\(\\varphi(n)\\)​ 的值为 \\[ \\begin{align} \\varphi(n)&amp;=N(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_k})\\\\ &amp;=N\\prod_{i=1}^k(1-\\frac{1}{p_i})\\\\ \\end{align} \\] 那么用这个公式去求欧拉函数的值的时间复杂度为 \\(O(\\sqrt n\\cdot a_i)\\)​ int getEuler(int a) &#123; int res = a; for (int i = 2; i &lt;= a / i; i++) &#123; if (a % i == 0) &#123; res = res / i * (i - 1); while (a % i == 0) a /= i; &#125; &#125; if (a > 1) res = res / a * (a - 1); return res; &#125; 1.2 筛法求欧拉函数 应用线性筛在 \\(O(n)\\)​ 的复杂度内求得每个数的欧拉函数 关于公式的推导： i % priems[j] == 0 ： \\[ \\text{if }i\\text{ mod }p_j=0\\Rightarrow\\varphi(p_j\\times i)=p_j\\times\\varphi(i) \\] \\[ \\begin{align} &amp;i\\text{ mod }p_j=0\\Leftrightarrow i=p_1p_2\\cdots p_j\\cdots p_k\\\\ &amp;\\varphi(i)=i(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_j})\\cdots(1-\\frac{1}{p_k})\\\\ &amp;m=p_j\\times i=p_1p_2\\cdots p_j^2\\cdots p_k\\\\ &amp;\\varphi(m)=m(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_j})\\cdots(1-\\frac{1}{p_k})\\\\ &amp;\\Rightarrow\\frac{\\varphi(i)}{i}=\\frac{\\varphi(m)}{m}=\\frac{\\varphi(m)}{p_j\\times i}\\\\ &amp;\\Leftrightarrow\\varphi(m)=\\varphi(p_j\\times i)=p_j\\times\\varphi(i) \\end{align} \\] i % primes[j] != 0 ： \\[ \\text{if }i\\text{ mod }p_j\\ne0\\Rightarrow\\varphi(p_j\\times i)=(p_j-1)\\varphi(i) \\] \\[ \\begin{align} &amp;i\\text{ mod }p_j\\ne0\\Leftrightarrow i=p_1p_2\\cdots p_k\\\\ &amp;\\varphi(i)=i(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_k})\\\\ &amp;m=p_j\\times i=p_1p_2\\cdots p_j\\cdots p_k=p_j\\times(p_1p_2\\cdots p_k)\\\\ &amp;\\varphi(m)=m(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_j})\\cdots(1-\\frac{1}{p_k})=m(1-\\frac{1}{p_j})\\Big[(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_k})\\Big]\\\\ &amp;\\Rightarrow\\frac{\\varphi(i)}{i}=\\frac{\\varphi(m)}{m\\times(1-\\frac{1}{p_j})}=\\frac{\\varphi(m)}{p_j(1-\\frac{1}{p_j})\\times i}\\\\ &amp;\\Leftrightarrow\\varphi(m)=\\varphi(p_j\\times i)(1-\\frac{1}{p_j})=p_j(1-\\frac{1}{p_j})\\times\\varphi(i)=(p_j-1)\\varphi(i) \\end{align} \\] /** Defination for linear sieve to get Euler * int primes[N], cnt; * int phi[N]; * bool st[N]; */ void getEulers(int n) &#123; phi[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) &#123; phi[primes[j] * i] = primes[j] * phi[i]; break; &#125; else phi[primes[j] * i] = (primes[j] - 1) * phi[i]; &#125; &#125; &#125; 1.3 Euler 定理 若 \\(a\\) 与 \\(n\\) 互质，则有 \\(a^{\\varphi(n)}\\equiv1(\\text{mod } n)\\)​​​。 推论： Pass 1 若 \\(p\\) 为质数，则有 \\(a^{\\varphi(p)}\\equiv 1(\\text{mod }p)\\)​ 。 Pass 2：Fermat 小定理 若 \\(p\\) 为质数，则有 \\(a^{p-1}\\equiv1(\\text{mod }p)\\) 。 二、快速幂 快速幂能够快速的在 \\(O(\\log k)\\) 的下复杂度求出 \\(a^k\\mod p\\)​ 的结果。 快速幂的核心思路是反复平方法，核心思想是：有数 \\(a,k,p\\) ，预处理出 \\(a^{2^0} \\mod p,a^{2^1}\\mod p,a^{2^2}\\mod p，\\cdots,a^{2^{\\log k}}\\mod p\\) 的值，则最后我们的目的是将 \\(a^k\\) 拆成前面若干项乘积的形式，即假设 \\(a^k=a^{2^{r_1}} a^{2^{r_2}}\\cdots a^{2^{r_t}}\\) ，化简指数幂为 \\(a^k=a^{2^{r_1}+2^{r_2}+\\cdots+2^{r_t}}\\) ，于是显然有 \\(k=2^{r_1}+2^{r_2}+\\cdots+2^{r_t}\\)​ 成立，那么因为底数均为 \\(2\\) ，则有 \\(k=(r_1r_2\\cdots r_t)_2\\) 成立，即指数各项与 \\(k\\)​​ 的二进制表示的各个数位一一对应。 那么我们要如何预处理上面的一系列数呢？显然，我们有下面的递推关系成立： \\[ \\begin{align} &amp;a^{2^0}=a^1\\\\ &amp;a^{2^1}=a^{2^0\\cdot2}=(a^{2^0})^2\\\\ &amp;a^{2^2}=(a^{2^1})^2\\\\ &amp;\\cdots\\\\ &amp;a^{2^{\\log k}}=(a^{2^{\\log k}-1})^2\\\\ \\end{align} \\] 那么有递推公式 \\(a^{2^i}=(a^{2^{i-1}})^2\\)​​ 成立，我们就能够得出这一系列的数值了。 于是如果 \\(k\\) 的二进制表示是 \\((x_mx_{m-1}\\cdots x_2x_1x_0)_2\\) ，那么我们就可以倒序使用位运算不断拆解 \\(k\\) ，由于次数从个位向上是递增的，且二进制表示下非 \\(0\\) 即 \\(1\\) ，那么也就是 \\(k\\) 的二进制表示有多少位，相对应的 \\(a^{2^i}\\) 就要进行平方多少次，能够得到某一位的因子，如果二进制表示下该位为 \\(1\\) ，则将这个因子与前面的结果相乘，最终便得到了 \\(a^k\\)。 typedef long long LL; // 乘因子可能会爆int所以要开long long int quickPow(int a, int k, int p) &#123; // return (a^k % p) int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; return res; &#125; 快速幂求逆元 乘法逆元的定义 若整数 \\(b,m\\)​ 互质，并且对于任意的整数 \\(a\\)​，如果满足 \\(b|a\\)​ ，则存在一个整数 \\(x\\)​ ，使得 \\(a/b≡a×x(\\text{mod }m)\\)​ 则称 \\(x\\) 为 \\(b\\) 的模 \\(m\\) 乘法逆元，记为 \\(b^{−1}(\\text{mod }m)\\)。 \\(b\\) 存在乘法逆元的充要条件是 \\(b\\) 与模数 \\(m\\) 互质。当模数 \\(m\\) 为质数时，\\(b^{m−2}\\) 即为 \\(b\\) 的乘法逆元。 由逆元的定义推得性质 \\(b\\cdot b^{-1}\\equiv1(\\text{mod }m)\\)​ ，推导如下： \\[ \\begin{align} \\frac{a}{b}\\equiv a\\cdot b^{-1}(\\text{mod }m)\\\\ &amp;\\Leftrightarrow b\\cdot\\frac{a}{b}\\equiv b\\cdot ab^{-1}(\\text{mod }m)\\\\ &amp;\\Leftrightarrow a\\equiv a\\cdot b\\cdot b^{-1}(\\text{mod }m)\\\\ &amp;\\Leftrightarrow b\\cdot b^{-1}\\equiv1(\\text{mod }m) \\end{align} \\] 因为 \\(m\\) 为质数，根据费马小定理有 \\(b^{m-1}\\equiv1(\\text{mod }m)\\) 成立，则有 \\(b\\cdot b^{m-2}\\equiv1(\\text{mod }m)\\) ，由上述逆元性质，则可推知 \\(b^{-1}=b^{p-2}\\) ，即 \\(b\\) 的逆元是 \\(b^{p-2}\\) ，那么问题就变成了快速幂求 \\(b^{p-2}\\) 。 三、扩展欧几里得算法 3.1 裴蜀定理 裴蜀定理的内容： 对任何整数 \\(a\\) 、\\(b\\) 和它们的最大公约数 \\(d\\)，关于未知数 \\(x\\) 和 \\(y\\)​​ 的线性丢番图方程（称为裴蜀等式）： \\(ax + by = m\\) 有解当且仅当 \\(m\\) 是 \\(d\\) 的倍数。 求解上述方程中 \\(x,y\\) 的过程即为扩展欧几里得算法。 3.2 扩展欧几里得算法 欧几里得算法 int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125; 扩展欧几里得算法 扩展欧几里得算法可以求得裴蜀定理中方程 \\(ax+by=m\\) 的 \\(x,y\\)​ 值，算法基于原欧几里得算法进行扩展，算法思想推导如下： \\[ \\begin{align} (a,b)=(b,a\\text{ mod }b)=d\\\\ &amp;\\Leftrightarrow \\left\\{ \\begin{array}{c} ax+by=d\\\\ bx+(a\\text{ mod }b)y=d\\\\ \\end{array}\\tag{*}\\label{c} \\right.\\\\ &amp;\\text{where }a\\text{ mod b}=a-\\lfloor\\frac{a}{b}\\rfloor \\cdot b\\\\ &amp;\\text{Now Eq\\ref{c}(b)}\\\\ &amp;\\Rightarrow bx+(a-\\lfloor\\frac{a}{b}\\rfloor \\cdot b)y=d\\\\ &amp;\\text{Swap }x\\text{ and }y\\text{ to simplify calculate and corresponding to eq(*)(1)}\\\\ &amp;\\Rightarrow by+(a-\\lfloor\\frac{a}{b}\\rfloor \\cdot b)x=d\\\\ &amp;\\Leftrightarrow ax+b(y-\\lfloor\\frac{a}{b}\\rfloor \\cdot b)=d\\\\ &amp;\\Leftrightarrow \\begin{cases} x&#39;=x\\\\ y&#39;=y-\\displaystyle\\lfloor\\frac{a}{b}\\rfloor \\cdot b \\end{cases}\\\\ \\end{align} \\] 则得到通过递归写出的代码如下： int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; 3.3 求解线性同余方程 给出值 \\(a,b,m\\) ，求解线性同余方程 \\[ ax\\equiv b(\\text{mod }m) \\] 该方程等价于 \\(ax-my=b\\) 。由离散数学知识，该方程在 \\((a,m)|b\\) 条件下有解。则由扩展欧几里得算法可求出方程 \\(ax+my&#39;=d=(a,m)\\) 的解，其中 \\(y&#39;=-y\\) 。最后将解变为其 \\(\\displaystyle\\frac{b}{d}\\) 倍即可得到原线性同余方程的解。 typedef long long LL; int d = exgcd(a, m, x, y); if (b % d) puts(\"impossible\"); else printf(\"%d\\n\", (LL)x * (b / d) % m); 四、中国剩余定理 给定若干数 \\(m_1,m_2,\\cdots,m_k\\)​ ，其中 \\(\\forall m_i,m_j(i\\ne j)\\)​ 两两互质。 求解线性同余方程组： \\[ \\left\\{ \\begin{array}{c} x\\equiv a_1(\\text{mod }m_1)\\\\ x\\equiv a_2(\\text{mod }m_2)\\\\ \\vdots\\\\ x\\equiv a_k(\\text{mod }m_k)\\\\ \\end{array} \\right. \\] 令 \\(M=m_1m_2\\cdots m_k\\)​ ，\\(\\forall i\\in[1,k],M_i=\\displaystyle\\frac{M}{m_i}\\)​​ ，\\(M_i^{-1}\\)​ 表示 \\(M_i(\\text{mod }m_i)\\)​​ 的逆即 \\(M_iM_i^{-1}=1\\)​，则有 \\[ x=a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+\\cdots+a_kM_kM_k^{-1} \\] 推导过程： 以两个方程为例： \\[ \\begin{cases} x\\equiv m_1(\\text{mod }a_1)\\\\ x\\equiv m_2(\\text{mod }a_2)\\\\ \\end{cases} \\] 由合同定义，有以下方程成立： \\[ \\begin{gather} x=k_1a_1+m_1\\\\ x=k_2a_2+m_2\\\\ \\end{gather} \\] 则有如下过程： \\[ \\begin{gather} \\Rightarrow k_1a_1+m_1=k_2a_2+m_2\\\\[3px] \\Leftrightarrow k_1a_1-k_2a_2=m_2-m_1\\\\[5px] \\text{let }m=m_2-m_1\\text{ then }\\\\k_1a_1-k_2a_2=m\\tag{a}\\label{eq1}\\\\ \\text{Eq.\\ref{eq1} has solution when }(a_1,a_2)|m_2-m_1 \\end{gather} \\] 待求解方程 \\(k_1a_1-k_2a_2=m\\)​ 符合扩展欧几里得算法的适用范围，则可用扩展欧几里得算法解出 \\(k_1,k_2\\) 的值。 则 \\(x\\) 的所有解的形式为 \\[ \\begin{align} \\text{change variables }k_1,k_2\\text{ to }\\theta_1,\\theta_2\\text{ then we have Eq.\\ref{eq1} as}\\\\ \\theta_1a_1-\\theta_2a_2=m\\tag{b}\\label{1}\\\\[10px] \\text{bring into solution of Eq.\\ref{1}} \\begin{cases} \\theta_1=k_1+k\\frac a d\\\\ \\theta_2=k_2+k\\frac a d\\\\ \\end{cases}\\ (k\\in\\mathbb{Z}) \\text{ then }\\Rightarrow\\ x&amp;=(k_1+k\\frac{a_2}d)a_1+m_1&amp;\\\\ &amp;=a_1k_1+m_1+k\\frac{a_1a_2}d&amp;\\\\ \\end{align} \\] \\[ \\begin{align} \\text{because } \\begin{cases} (a_1,a_2)=d\\\\ [a_1,a_2]=\\frac{a_1a_2}d \\end{cases}\\Rightarrow\\\\ &amp;x=a_1k_1+m_1+k[a_1,a_2]&amp;\\\\ \\text{let } \\begin{cases} x_0=a_1k_1+m_1\\\\ a=[a_1,a_2] \\end{cases}\\ \\text{ then}\\\\ &amp;x=ka+x_0\\tag{c}\\label{a}&amp;\\\\ \\text{the form of Eq.\\ref{a} is similar to}\\\\ &amp;\\begin{array}{c} x=k_1a_1+m_1\\\\ x=k_2a_2+m_2\\\\ \\end{array}\\\\&amp; \\end{align} \\] 方程组中的两个不定方程就可以合并成一个方程，即 \\(x=ka+x_0\\)​ 。 推广至 \\(k\\)​​​​​ 个方程式构成的方程组，将这些方程式两两合并成一个方程 \\(x=ka+x_0\\)​​​​​ 即 \\(x\\equiv x_0(\\text{mod }a)\\)​​​​​ ，解出 \\(x\\)​​​​​​ 的最小正整数解即可。那么问题就转化成了求解 \\(x_0\\text{ mod }a\\)​​​​​ 的值了。 typedef long long LL; LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main() &#123; /* read in */ bool hasAnswer = true; LL a1, m1; cin >> a1 >> m1; for (int i = 0; i &lt; n - 1; i++) &#123; // 方程两两合并 LL a2, m2; cin >> a2 >> m2; LL k1, k2; LL d = exgcd(a1, a2, k1, k2); if ((m2 - m1) % d) &#123; // 拿到了d，如果不整除就无解 hasAnswer = false; break; &#125; k1 *= (m2 - m1) / d; // 方程从 =d 调整倍数改到 =(m2-m1) LL t = a2 / d; // 获取 a2/d 的值 k1 = (k1 % t + t) % t; // 实现过程中 theta_1 的最小正值 m1 = a1 * k1 + m1; // 得到本次的 x0，即下次迭代方程中的 m1 a1 = abs(a1 / d * a2); // 得到本次的 a，即下轮迭代方程中的 a1 &#125; if (hasAnswer) cout &lt;&lt; (m1 % a1 + a1) % a1 &lt;&lt; endl; // get (x0 mod a) else puts(\"-1\"); return 0; &#125; 习题 AcWing 873 Acwing 873 #include &lt;iostream> using namespace std; int getEuler(int a) &#123; int res = a; for (int i = 2; i &lt;= a / i; i++) &#123; if (a % i == 0) &#123; res = res / i * (i - 1); while (a % i == 0) a /= i; &#125; &#125; if (a > 1) res = res / a * (a - 1); return res; &#125; int main() &#123; int n; cin >> n; while (n--) &#123; int a; scanf(\"%d\", &amp;a); printf(\"%d\\n\", getEuler(a)); &#125; return 0; &#125; def getEuler(a): res = a i = 2 while i &lt;= a // i: if a % i == 0: res = res // i * (i - 1) while a % i == 0: a //= i i += 1 if a > 1: res = res // a * (a - 1) return res if __name__ == '__main__': n = int(input()) for _ in range(n): a = int(input()) print(getEuler(a)) AcWing 874 AcWing 874 #include &lt;iostream> using namespace std; const int N = 1e6 + 10; typedef long long LL; int primes[N], cnt; bool st[N]; int phi[N]; void getEulers(int n) &#123; phi[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) &#123; phi[primes[j] * i] = phi[i] * primes[j]; break; &#125; else phi[primes[j] * i] = phi[i] * (primes[j] - 1); &#125; &#125; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); LL res = 0; getEulers(n); for (int i = 1; i &lt;= n; i++) res += phi[i]; printf(\"%lld\", res); return 0; &#125; def getEulers(n): global primes, cnt for i in range(1, n + 1): if i &#x3D;&#x3D; 1: phi[1] &#x3D; 1 continue if not st[i]: primes.append(i) phi[i] &#x3D; i - 1 for prime in primes: if prime * i &gt; n: break st[prime * i] &#x3D; True if i % prime &#x3D;&#x3D; 0: phi[prime * i] &#x3D; phi[i] * prime break else: phi[prime * i] &#x3D; phi[i] * (prime - 1) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: n &#x3D; int(input()) N &#x3D; n + 10 primes &#x3D; []; cnt &#x3D; 0 st &#x3D; [False] * N phi &#x3D; [0] * N getEulers(n) res &#x3D; 0 for i in range(1, n + 1): res +&#x3D; phi[i] print(res) AcWing 875 AcWing 875 #include &lt;iostream> using namespace std; typedef long long LL; void quickPow(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (LL) res * a % p; b >>= 1; a = (LL)a * a % p; &#125; printf(\"%d\\n\", res); &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; int a, b, p; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;p); quickPow(a, b, p); &#125; return 0; &#125; def quickPow(a, b, p): res &#x3D; 1 while b: if b &amp; 1: res &#x3D; res * a % p b &gt;&gt;&#x3D; 1 a &#x3D; a * a % p print(res) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: n &#x3D; int(input()) for _ in range(n): a, b, p &#x3D; map(int, input().split()) quickPow(a, b, p) AcWing 876 AcWing 876 #include &lt;iostream> using namespace std; typedef long long LL; void quickPow(int a, int k, int p) &#123; int res = 1; while (k) &#123; if (k &amp; 1) res = (LL)res * a % p; k >>= 1; a = (LL)a * a % p; &#125; printf(\"%d\\n\", res); &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; int a, p; scanf(\"%d%d\", &amp;a, &amp;p); if (a % p == 0) cout &lt;&lt; \"impossible\" &lt;&lt; endl; else quickPow(a, p - 2, p); &#125; return 0; &#125; def quickPow(a, k, p): res = 1 while k: if k &amp; 1: res = res * a % p k >>= 1 a = a * a % p print(res) if __name__ == '__main__': n = int(input()) for _ in range(n): a, p = map(int, input().split()) if a % p == 0: print(\"impossible\") else: quickPow(a, p - 2, p) AcWing 877 AcWing 877 #include &lt;iostream> using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; int a, b, x, y; scanf(\"%d%d\", &amp;a, &amp;b); int d = exgcd(a, b, x, y); printf(\"%d %d\\n\", x, y); &#125; return 0; &#125; from sys import stdin def exgcd(a, b, x, y): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b, y, x) y -= a // b * x return d, x, y if __name__ == '__main__': n = int(input()) for _ in range(n): a, b = map(int, stdin.readline().split()) x, y = 0, 0 d, x, y = exgcd(a, b, x, y) print(x, y) AcWing 878 AcWing 878 #include &lt;iostream> using namespace std; typedef long long LL; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; int a, b, m; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;m); int x, y; int d = exgcd(a, m, x, y); if (b % d) puts(\"impossible\"); else printf(\"%lld\\n\", (LL)x * (b / d) % m); &#125; &#125; from sys import stdin def exgcd(a, b, x, y): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b, y, x) y -= a // b * x return d, x, y if __name__ == '__main__': n = int(input()) for _ in range(n): a, b, m = map(int, stdin.readline().split()) x = 0; y = 0 d, x, y = exgcd(a, m, x, y) if b % d: print(\"impossible\") else: print(x * (b // d) % m) AcWing 204 AcWing 204 #include &lt;iostream> #include &lt;cmath> using namespace std; typedef long long LL; LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; LL d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125; int main() &#123; int n; cin >> n; LL a1, m1; cin >> a1 >> m1; bool hasAnswer = true; for (int i = 0; i &lt; n - 1; i++) &#123; LL a2, m2; cin >> a2 >> m2; LL k1, k2; LL d = exgcd(a1, a2, k1, k2); if ((m2 - m1) % d) &#123; hasAnswer = false; break; &#125; k1 *= (m2 - m1) / d; LL t = a2 / d; k1 = (k1 % t + t) % t; m1 = a1 * k1 + m1; a1 = abs(a1 / d * a2); &#125; if (hasAnswer) cout &lt;&lt; (m1 % a1 + a1) % a1; else puts(\"-1\"); return 0; &#125; from sys import stdin def exgcd(a, b, x, y): if not b: return a, 1, 0 d, y, x = exgcd(b, a % b, y, x) y -= a // b * x return d, x, y if __name__ == '__main__': n = int(input()) a1, m1 = map(int, stdin.readline().split()) hasAnswer = True for _ in range(n - 1): a2, m2 = map(int, stdin.readline().split()) k1, k2 = 0, 0 d, k1, k2 = exgcd(a1, a2, k1, k2) if (m2 - m1) % d: hasAnswer = False break k1 *= (m2 - m1) // d t = a2 // d k1 = k1 % t m1 = a1 * k1 + m1 a1 = a1 // d * a2 if hasAnswer: print(m1 % a1) else: print(-1)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Euler function","slug":"Euler-function","permalink":"https://www.leolang.top/tags/Euler-function/"},{"name":"Fast power multiplication","slug":"Fast-power-multiplication","permalink":"https://www.leolang.top/tags/Fast-power-multiplication/"},{"name":"Extended Euclidean algorithm","slug":"Extended-Euclidean-algorithm","permalink":"https://www.leolang.top/tags/Extended-Euclidean-algorithm/"},{"name":"Chinese remainder theorem","slug":"Chinese-remainder-theorem","permalink":"https://www.leolang.top/tags/Chinese-remainder-theorem/"}]},{"title":"AcWing 数学知识（一）","slug":"数学知识（一）数论","date":"2021-08-01T16:00:00.000Z","updated":"2021-08-25T13:24:18.000Z","comments":true,"path":"2021/08/02/数学知识（一）数论/","link":"","permalink":"https://www.leolang.top/2021/08/02/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E8%AE%BA/","excerpt":"前言 本文将介绍数论中关于质数、约数的相关内容，包括质数判定、三种质数筛等内容。","text":"前言 本文将介绍数论中关于质数、约数的相关内容，包括质数判定、三种质数筛等内容。 数学知识（一）数论 1 数论问题一定要算时间复杂度！ 一、质数 1.1 质数的定义 对于大于 \\(1\\)​ 的整数，如果其因数只有 \\(1\\)​ 和其本身，那么这个数是质数，又叫素数。 1.2 质数相关算法 1.2.1 质数的判定：试除法 暴力写法：\\(O(n)\\) bool isPrime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i &lt; n; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125; 优化写法：如果 \\(d|n\\)​ ，则一定有 \\(\\frac{n}{d}|n\\)​ 成立，其中 \\(d\\leq\\frac{n}{d}\\)​ 。那么有 \\(d^2\\leq n\\)​ 成立，得到 \\(d\\leq\\sqrt n\\)​​​ 。则我们只需要枚举这些 \\(\\leq\\sqrt n\\)​ 的整数就可以了。时间复杂度为 \\(O(\\sqrt n)\\)​ 。 bool isPrime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i &lt;= n / i; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125; 1.2.2 分解质因数：试除法 从小到大枚举所有整数，枚举出所有质因数，并得到其次数。这里所得到的一定是质数，因为当条件成立时，已经枚举过了 \\(x\\in[2,i],x\\in Z\\) 的所有质因数了，又因为合数都可以拆成质数的乘积，那么范围内合数实际上已经被去掉了。时间复杂度为 \\(O(n)\\) void divide(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (n % i == 0) &#123; int s = 0; while (n % i == 0) &#123; n /= i; s++; &#125; printf(\"%d %d\\n\", i, s); &#125; &#125; &#125; 优化写法：由于 \\(n\\)​​ 最多只包含一个 \\(\\geq\\sqrt n\\)​ 的质因子，则我们只需先试探所有 \\(\\leq\\sqrt n\\)​ 的质因子，如果最后 \\(n\\)​ 没有被拆干净，那么最后剩下的就是那个 \\(\\ge\\sqrt n\\)​ 的质因子了，这个就可以单独处理。最坏时间复杂度是 \\(O(\\sqrt n)\\) ，实际时间复杂度介于 \\(\\log n\\) 与 \\(\\sqrt n\\) 之间。 void divide(int n) &#123; for (int i = 2; i &lt;= n / i; i++) &#123; if (n % i == 0) &#123; int s = 0; while (n % i == 0) &#123; n /= i; s++; &#125; printf(\"%d %d\\n\", i, s); &#125; &#125; if (n > 1) printf(\"%d 1\\n\", n); &#125; 1.2.3 素数筛 int primes[N], cnt; bool st[N]; 朴素素数筛 将所有数列成一列，从 \\(2\\)​​​ 开始枚举所有数，在枚举每个数时删掉其倍数，即枚举到数 \\(x\\)​ 时删除掉 \\(2x,3x,4x,\\cdots,kx(k\\in Z)\\)​ 。如果在枚举 \\(x\\) 时 \\(x\\) 尚未被删除，那么它就是质数，因为他不是 \\(\\leq x\\)​ 的任何数的倍数。时间复杂度为 \\(O(n\\log n)\\) void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; &#125; &#125; 埃氏筛法 由算数基本定理，所有的合数都可以被拆成素数的乘积。那么对于整数序列中的合数，一定会被在它前面的素数删除掉，那么，我们筛选质数的时候只需要枚举质数并删除其倍数就可以了。时间复杂度为 \\(O(\\log\\log n)\\) 。 void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; for (int j = i; j &lt;= n; j += i) st[i] = true; &#125; &#125; &#125; 线性筛法 埃氏筛在某些数上还会有重复删除的情况，所以有了进一步的优化方法线性筛。线性筛法中每一个合数都只会被它的最小质因子筛掉。 如果一个数 \\(i\\)​​ 是质数，那么就将其加入质数表。同时从小到大枚举所有质数表中 \\(\\leq\\displaystyle\\frac{n}{i}\\)​​​ 的数（即删除在 \\(\\leq n\\)​​ 范围内的合数），删除该质数与 \\(i\\)​​​​ 的乘积产生的合数。记 \\(primes\\)​​ 数组中的元素为 \\(p_k\\)​​​ ，如果 \\(i\\mod p_j=0\\)​​ 成立，则 \\(p_j\\)​​ 就是 \\(i\\)​​ 的最小质因数。因为我们是从头升序枚举的，那么 \\(p_k\\)​​ 随 \\(k\\)​​ 递增是呈升序排列的，那么第一个使条件成立的 \\(p_j\\)​​​ 即是最小质因子。那么对于数 \\(p_j\\times i\\)​​ ， \\(p_j\\)​​ 也是其最小质因子，因为 \\(p_j\\) 是质数，\\(p_j|i\\) ；如果 \\(i\\mod p_j\\ne0\\) ，那么 \\(p_j\\) 一定小于 \\(i\\)​​​ 的所有质因子，那么对于数 \\(p_j\\times i\\) ， \\(p_j\\) 仍是其最小质因子。那么对于每一个被筛掉的合数 \\(p_j\\times i\\) ，都是用它的最小质因子 \\(p_j\\)​​ 筛除的。枚举的目的就是找到最小质因子 \\(p_i\\) 。 接下来证明每一个合数都会被筛掉。对于一个合数 \\(x\\)​ ，其最小质因子为 \\(p\\) ，那么当 \\(i\\) 枚举到 \\(x/p\\) 时，有 \\(x=p\\times i\\) 成立。此时 \\(x\\) 就会被 \\(p\\) ，也就是它自己的最小质因子筛掉。那么每一个合数都会被它的最小质因子筛掉。 由于每一个合数都只有一个最小质因子，那么每一个合数都只会被它的最小质因子筛掉一次，那么每个合数也就==只被筛掉一次==，那么这也就是线性筛。 void getPrimes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; &#125; 线性筛会在 \\(n=10^7\\) 时比埃氏筛大概快一倍，在 \\(n=10^6\\) 下差异不大。 二、约数 2.1 试除法求约数 同样的，如果枚举到了 \\(i\\) 能被 \\(n\\) 整除，那么它就是 \\(n\\) 的约数了。这样的写法也和上面试除法求质数一样可以优化，如果 \\(d|n\\) ，则一定有 \\(\\frac{n}{d}|n\\) 成立，其中 \\(d\\leq\\frac{n}{d}\\) 。那么有 \\(d^2\\leq n\\) 成立，得到 \\(d\\leq\\sqrt n\\) 。则我们只需要枚举这些 \\(\\leq\\sqrt n\\) 的整数就可以了，和它一对的数就是 \\(n/i\\) 。需要注意的是可能产生 \\(i^2=n\\) 的情况需要特判。时间复杂度为 \\(O(\\sqrt n)\\) 。 vector&lt;int> getDivisors(int n) &#123; vector&lt;int> res; for (int i = 1; i &lt;= n / i; i++) &#123; if (n % i == 0) &#123; res.push_back(i); if (i != n / i) res.push_back(n / i); &#125; &#125; sort(res.begin(), res.end()); return res; &#125; 2.2 约数个数 由离散数学中算数基本定理知一个数 \\(N(N&gt;1)\\)​​​​​ 一定可以唯一写成若干质数的乘积，即 \\(N=p_1^{m_1}p_2^{m_2}\\cdots p_k^{m_k}(p_1&lt;p_2&lt;\\cdots&lt;p_k)\\)​​​​​​ ，则由乘法原理有数 \\(N\\)​​​​​ 的所有正因数个数为 \\[ \\sigma_0(N)=(m_1+1)(m_2+1)\\cdots(m_k+1) \\] int 范围内的约数个数最大在 \\(1500\\)​​​​ 左右。 /** Defination for get the sum number of factors * unordered_map&lt;int> primes; // store map&lt;prime, power> of a number(factors multipled) * int x; // one factor * typedef long long LL; * const int mod = 10e9 + 7; */ void getFactors(int x) &#123; for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; x /= i; primes[i]++; &#125; &#125; if (x > 1) primes[x]++; &#125; // get result LL res = 1; for (auto &amp;prime: primes) res = res * (prime.second + 1) % mod; 2.3 约数之和 对于一个数 \\(N(N&gt;1)\\) 其标准分解式为 \\(N=p_1^{m_1}p_2^{m_2}\\cdots p_k^{m_k}(p_1&lt;p_2&lt;\\cdots&lt;p_k)\\) ，那么他的全体正因数之和为 \\[ \\begin{align} \\sigma_1(N)&amp;=(p_1^0+p_1^1+p_1^2+\\cdots+p_1^{m_1})(p_2^0+p_2^1+p_2^2+\\cdots+p_2^{m_2})\\cdots(p_k^0+p_k^1+p_k^2+\\cdots+p_k^{m_k})\\\\ &amp;=(1+p_1+p_1^2+\\cdots+p_1^{m_1})(1+p_2+p_2^2+\\cdots+p_2^{m_2})\\cdots(1+p_k+p_k^2+\\cdots+p_k^{m_k})\\\\ \\end{align} \\] 这个公式按乘法分配律展开，得到的每一项都是 \\(N\\) 的一个因数，形式为 \\(cof=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k} (i\\in[1,k],i\\in Z)(a_i\\in[0,m_i],a_i\\in Z)\\)。 /** Defination for get the sum number of factors * unordered_map&lt;int> primes; // store map&lt;prime, power> of a number(factors multipled) * int x; // one factor * typedef long long LL; * const int mod = 10e9 + 7; */ void getFactors(int x) &#123; for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; x /= i; primes[i]++; &#125; &#125; if (x > 1) primes[x]++; &#125; // get result LL res = 1; for (auto &amp;prime: primes) &#123; int p = prime.first, a = prime.second; LL t = 1; while (a--) t = (t * p + 1) % mod; // 秦九韶算法，得到公式中的每一个因式 res = res * t % mod; &#125; 2.4 最大公因数——欧几里得算法 求最大公因数的算法是欧几里得算法，也叫辗转相除法。当然也有更相减损术。辗转相除法的基本原理为 \\[ \\begin{align} (a,b) &amp;=(b,a\\text{ mod } b)=(b,r_1)\\\\ &amp;=(r_1,b\\text{ mod } r_1)=(r_1,r_2)\\\\ &amp;=\\cdots\\\\ &amp;=(r_{n-1},r_n)\\\\ &amp;=(r_n,r_{n-1}\\text{ mod } r_n)=(r_n,0)\\\\ &amp;=r_{n} \\end{align} \\] int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125; 如果 \\(b=0\\)​​ 证明上一层递归的 \\(b\\)​​ 也就是这一层的 \\(a\\)​​ 已经是最大公因数，则直接返回本层的 \\(a\\)​​ ，否则要继续向下计算 \\((b,a\\text{ mod } b)\\)​​​ 的值。欧几里得算法的时间复杂度为 \\(O(\\log n)\\)​​ 。 习题 AcWing 866 AcWing 866 #include &lt;iostream> using namespace std; bool isPrime(int n) &#123; if (n &lt; 2) return false; for (int i = 2; i &lt;= n / i; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125; int main() &#123; int n; cin >> n; while (n--) &#123; int a; scanf(\"%d\", &amp;a); if (isPrime(a)) puts(\"Yes\"); else puts(\"No\"); &#125; return 0; &#125; def isPrime(n): if n &lt; 2: return False i &#x3D; 2 while i &lt;&#x3D; n &#x2F; i: if n % i &#x3D;&#x3D; 0: return False i +&#x3D; 1 return True if __name__ &#x3D;&#x3D; &#39;__main__&#39;: n &#x3D; int(input()) for _ in range(n): a &#x3D; int(input()) if isPrime(a): print(&quot;Yes&quot;) else: print(&quot;No&quot;) AcWing 867 AcWing 867 #include &lt;iostream> using namespace std; void divide(int n) &#123; for (int i = 2; i &lt;= n / i; i++) &#123; if (n % i == 0) &#123; int s = 0; while (n % i == 0) &#123; n /= i; s++; &#125; printf(\"%d %d\\n\", i, s); &#125; &#125; if (n > 1) printf(\"%d 1\\n\", n); &#125; int main() &#123; int n; cin >> n; while (n--) &#123; int a; scanf(\"%d\", &amp;a); divide(a); cout &lt;&lt; endl; &#125; return 0; &#125; def divide(n): i = 2 while i &lt;= n / i: if n % i == 0: s = 0 while n % i == 0: n /= i s += 1 print(i, s) i += 1 if n > 1: print(int(n), '1') if __name__ == '__main__': n = int(input()) for _ in range(n): a = int(input()) divide(a) print() AcWing 868 AcWing 868 C++ 朴素筛 #include &lt;iostream> using namespace std; const int N = 1e6 + 10; int primes[N], cnt; bool st[N]; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; &#125; printf(\"%d\", cnt); return 0; &#125; 欧式筛 #include &lt;iostream> using namespace std; const int N = 1e6 + 10; int primes[N], cnt; bool st[N]; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; for (int j = i; j &lt;= n; j += i) st[j] = true; &#125; &#125; printf(\"%d\", cnt); return 0; &#125; 线性筛 #include &lt;iostream> using namespace std; const int N = 1e6 + 10; int primes[N], cnt; bool st[N]; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) primes[cnt++] = i; for (int j = 0; primes[j] &lt;= n / i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; printf(\"%d\", cnt); return 0; &#125; Python 朴素筛 n = int(input()) primes = [] st = [False] * (n + 1) i = 2 while i &lt;= n: if not st[i]: primes.append(i) j = i + i while j &lt;= n: st[j] = True j += i i += 1 print(len(primes)) 欧式筛 n = int(input()) primes = [] st = [False] * (n + 1) i = 2 while i &lt;= n: if not st[i]: primes.append(i) j = i while j &lt;= n: st[j] = True j += i i += 1 print(len(primes)) 线性筛 n = int(input()) primes = [] st = [False] * (n + 1) i = 2 while i &lt;= n: if not st[i]: primes.append(i) for prime in primes: if prime > n / i: break st[prime * i] = True if i % prime == 0: break i += 1 print(len(primes)) AcWing 869 AcWing 869 #include &lt;iostream> #include &lt;algorithm> #include &lt;vector> using namespace std; vector&lt;int> getDivisors(int n) &#123; vector&lt;int> res; for (int i = 1; i &lt;= n / i; i++) &#123; if (n % i == 0) &#123; res.push_back(i); if (i != n / i) res.push_back(n / i); &#125; &#125; sort(res.begin(), res.end()); return res; &#125; int main() &#123; int n; cin >> n; while (n--) &#123; int a; scanf(\"%d\", &amp;a); auto res = getDivisors(a); for (int i = 0; i &lt; res.size(); i++) printf(\"%d \", res[i]); cout &lt;&lt; endl; &#125; return 0; &#125; def getDivisors(n): res = [] i = 1 while i &lt;= n // i: if n % i == 0: res.append(i) if i != n // i: res.append(n // i) i += 1 print(' '.join(map(str, sorted(res)))) if __name__ == '__main__': n = int(input()) for _ in range(n): a = int(input()) res = getDivisors(a) AcWing 870 AcWing 870 #include &lt;iostream> #include &lt;algorithm> #include &lt;unordered_map> using namespace std; const int mod = 1e9 + 7; typedef long long LL; int main() &#123; int n; cin >> n; unordered_map&lt;int, int> primes; while (n--) &#123; int x; scanf(\"%d\", &amp;x); for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; primes[i]++; x /= i; &#125; &#125; if (x > 1) primes[x]++; &#125; LL res = 1; for (auto &amp;prime: primes) res = res * (prime.second + 1) % mod; printf(\"%lld\", res); return 0; &#125; from collections import defaultdict mod = int(1e9 + 7) n = int(input()) primes = defaultdict(int) for _ in range(n): x = int(input()) i = 2 while i &lt;= x // i: while x % i == 0: primes[i] += 1 x //= i i += 1 if x > 1: primes[x] += 1 res = 1 for value in primes.values(): res = res * (value + 1) % mod print(res) AcWing 871 AcWing 871 #include &lt;iostream> #include &lt;algorithm> #include &lt;unordered_map> using namespace std; const int mod = 1e9 + 7; typedef long long LL; int main() &#123; int n; cin >> n; unordered_map&lt;int, int> primes; while (n--) &#123; int x; scanf(\"%d\", &amp;x); for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; primes[i]++; x /= i; &#125; &#125; if (x > 1) primes[x]++; &#125; LL res = 1; for (auto x: primes) &#123; LL t = 1; int p = x.first, a = x.second; while (a--) t = (t * p + 1) % mod; res = res * t % mod; &#125; printf(\"%lld\", res); return 0; &#125; from collections import defaultdict mod = int(1e9 + 7) n = int(input()) primes = defaultdict(int) for _ in range(n): x = int(input()) i = 2 while i &lt;= x // i: while x % i == 0: primes[i] += 1 x //= i i += 1 if x > 1: primes[x] += 1 res = 1 for p, a in primes.items(): t = 1 for i in range(a, 0, -1): t = (t * p + 1) % mod res = res * t % mod print(res) AcWing 872 AcWing 872 #include &lt;iostream> using namespace std; int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", gcd(a, b)); &#125; return 0; &#125; def gcd(a, b): return gcd(b, a % b) if b else a if __name__ &#x3D;&#x3D; &#39;__main__&#39;: n &#x3D; int(input()) for _ in range(n): a, b &#x3D; map(int, input().split()) print(gcd(a, b))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Prime number","slug":"Prime-number","permalink":"https://www.leolang.top/tags/Prime-number/"},{"name":"Divisor","slug":"Divisor","permalink":"https://www.leolang.top/tags/Divisor/"}]},{"title":"AcWing 搜索与图论（四）","slug":"搜索与图论（四）二分图","date":"2021-07-28T16:00:00.000Z","updated":"2022-04-06T08:11:46.272Z","comments":true,"path":"2021/07/29/搜索与图论（四）二分图/","link":"","permalink":"https://www.leolang.top/2021/07/29/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"前言 本文将介绍关于二分图、匈牙利算法的相关内容，并给出相关算法的实现模板。","text":"前言 本文将介绍关于二分图、匈牙利算法的相关内容，并给出相关算法的实现模板。 搜索与图论（四）二分图 〇、二分图的概念 二分图又称作二部图。 设 \\(G=(V,E)\\)​ 是一个无向图，如果顶点 \\(V\\)​ 可分割为两个互不相交的子集 \\((A,B)\\)​ ，并且图中的每条边 \\((i，j)\\) 所关联的两个顶点 \\(i\\) 和 \\(j\\) 分别属于这两个不同的顶点集 \\((i\\in A,j \\in B)\\)，则称图 \\(G\\) 为一个二分图。 一、染色法判别二分图 染色法是一种用来判定二分图的方法，是基于 DFS 进行的（ BFS 也不是不行，目的是遍历到图中的所有点），时间复杂度为 \\(O(n+m)\\)​​​。 定理：一个图是二分图，当且仅当图中不含奇数环。 证明如下： 必要性：假设一二分图中存在奇数环，记图中存在一环为 \\((v_1,v_2,\\cdots,v_{2k+1},v_1)\\)​​​ 。记图中点属于两个集合 \\(A,B\\)​ 。假设 \\(v_1\\)​ 属于集合 \\(A\\)​ ，则 \\(v_2\\)​ 属于集合 \\(B\\)​ ，则以此类推，按此规律推下去，奇数下标点应是属于集合 \\(A\\)​ ，偶数下标点应是属于集合 \\(B\\)​​​​ ，则按此规律推导得 \\(v_1\\in B\\) ，而初始条件为 \\(v_1\\in A\\)​ ，得出矛盾，假设不成立。 充分性：有这样的构造方式，如果一个点 \\(v_k\\) 没有被分类，则该点所在的连通块内所有点的分类方式背确定。不妨设 \\(v_k\\in A\\) ，则所有与集合 \\(A\\) 内点邻接的点均属于集合 \\(B\\)​ ，反之亦然。可以通过反证法证明，由于图中不含奇数环，则这种构造方式是不会产生矛盾的。通过以上的构造方式，即可将所有的点分为两个点集 \\(A,B\\)​ 。这样即构造出一二部图。 充分性的证明中的构造方式被称为染色法，用染色法可以判断一个图是否是二部图。如果染色法出现矛盾，则该图不是二部图。 染色法的步骤如下： ​ 循环 \\(n\\)​​​ 次循环所有点，如果该点没有染色，就对该点执行 DFS 进行染色。DFS 中即依附 DFS 进行染色法。如果染色途中发现染色冲突，则染色失败，该图不是二分图。如果最后成功被二染色，则该图是二分图。 const int N = ..., M = 2 * N; int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a], h[a] = idx++; &#125; bool dfs(int u, int c) &#123; color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!color[j]) &#123; if (!dfs(j, 3 - c)) return false; &#125; else if (color[j] == c) return false; &#125; return true; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edges */ bool flag = true; for (int i = 1; i &lt;= n; i++) &#123; if (!color[i]) &#123; if (!dfs(i, 1)) &#123; flag = false; break; &#125; &#125; &#125; if (flag) puts(\"Yes\"); else puts(\"No\"); &#125; 二、匈牙利算法 匈牙利算法最坏时间复杂度为 \\(O(mn)\\) ，而实际运行时间一般远小于 \\(O(mn)\\)。 匈牙利算法用于返回一二部图中的最大匹配。匹配的意思是由一组没有公共端点的不是自环的边构成的集合，某一个点只属于且仅属于一条非自环边。最大匹配就是尽可能最大化匹配集合中的点对数。 二分图的匹配：给定一个二分图 \\(G\\)，在 \\(G\\) 的一个子图 \\(M\\) 中，\\(M\\) 的边集 \\(\\{E\\}\\) 中的任意两条边都不依附于同一个顶点，则称 \\(M\\) 是一个匹配。 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。 用抽象的数学语言描述匈牙利算法： 记二部图的两部集为 \\(A,B\\) ，其中的元素为 \\(A=\\{a_1,a_2,\\cdots,a_n\\}\\) ， \\(B=\\{b_1,b_2,\\cdots,b_m\\}\\) ，两部集之间有若干条边。遍历集合 \\(A\\) 中的所有元素，重复如下过程：设当前选中的元素为 \\(a_k\\) ，遍历其所有出边，其一出边为 \\((a_k,b_r)\\) ，若 \\(b_r\\) 尚未被之前的其他元素 \\(a_x(x&lt;k)\\)​ 选中作为一对点对，则将该边标记，将 \\(b_r\\) 标记为已配对；若 \\(b_r\\) 被某元素 \\(a_x\\) 选中作为配对点对，则查询点 \\(a_x\\) 除 \\((a_x,b_r)\\) 以外的出边，如果当中有一边 \\((a_x,b_r&#39;)\\)​ 的入点 \\(b_r&#39;\\) 未被选中，则更改 \\(a_x\\) 匹配指向为 \\((a_x,b_r&#39;)\\) ，使得 \\(a_k\\) 与 \\(b_r\\) 配对，构成点对 \\((a_k,b_r)\\)​ 。若遍历过所有出边到达的所有 \\(B\\) 集合中点对应的 \\(A\\) 集合中的点都无法改变直线，则该点配对失败，不产生配对。最终所有点遍历结束后，所有被选中的点对配对即为该二部图的最大匹配。 当然了，匈牙利算法的过程可以形象的理解成男孩选妃并且当面 ntr 的过程……这里就不详细写了。 由于只需要遍历 \\(A\\to B\\)​ 这一个方向，所以只存储这一方向的边即可。 int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; bool find(int x) &#123; // find if x can get matched for (int i = h[x]; i != -1; i++) &#123; int to = e[i]; if (!st[to]) &#123; st[to] = true; if (!match[to] || find(match[to])) &#123; match[to] = x; return true; &#125; &#125; &#125; return false; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edges */ int res = 0; for (int i = 1; i &lt;= n1; i++) &#123; memset(st, false, sizeof st); if (find(i)) res++; &#125; printf(\"%d\", res); return 0; &#125; 习题 AcWing 860 AcWing 860 DFS #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 100010, M = 200010; int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a], h[a] = idx++; &#125; bool dfs(int u, int c) &#123; color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) &#123; int to = e[i]; if (!color[to]) &#123; if (!dfs(to, 3 - c)) return false; &#125; else if (color[to] == c) return false; &#125; return true; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while (m--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b), add(b, a); &#125; bool flag = true; for (int i = 1; i &lt;= n; i++) &#123; if (!color[i]) &#123; if (!dfs(i, 1)) &#123; flag = false; break; &#125; &#125; &#125; if (flag) cout &lt;&lt; \"Yes\"; else cout &lt;&lt; \"No\"; return 0; &#125; BFS #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> #include &lt;queue> using namespace std; const int N = 100010, M = 200010; typedef pair&lt;int, int> PII; int n, m; int h[N], e[M], ne[M], idx; int color[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a], h[a] = idx++; &#125; bool bfs(int u, int c) &#123; color[u] = c; queue&lt;PII> q; q.push(&#123;u, c&#125;); while (q.size()) &#123; auto t = q.front(); q.pop(); int cur = t.first, curc = t.second; for (int i = h[cur]; i != -1; i = ne[i]) &#123; int to = e[i]; if (!color[to]) &#123; color[to] = 3 - curc; q.push(&#123;to, 3 - curc&#125;); &#125; else if (color[to] == curc) return false; &#125; &#125; return true; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while (m--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b), add(b, a); &#125; bool flag = true; for (int i = 1; i &lt;= n; i++) &#123; if (!color[i]) &#123; if (!bfs(i, 1)) &#123; flag = false; break; &#125; &#125; &#125; if (flag) cout &lt;&lt; \"Yes\"; else cout &lt;&lt; \"No\"; return 0; &#125; DFS 大法 python TLE def add(a, b): global idx e[idx] = b ne[idx] = h[a]; h[a] = idx idx += 1 def dfs(u, c): color[u] = c i = h[u] while i != -1: to = e[i] if not color[to]: if not dfs(to, 3 - c): return False elif color[to] == c: return False i = ne[i] return True if __name__ == '__main__': n, m = map(int, input().split()) N = n + 10; M = 2 * m + 10 h = [-1] * N e = [0] * M ne = [0] * M idx = 0 color = [0] * N for _ in range(m): a, b = map(int, input().split()) add(a, b); add(b, a) flag = True for i in range(1, n + 1): if not color[i]: if not dfs(i, 1): flag = False break if flag: print(\"Yes\") else: print(\"No\") BFS 大法 from collections import deque def add(a, b): global idx e[idx] = b ne[idx] = h[a]; h[a] = idx idx += 1 def bfs(u, c): color[u] = c q = deque() q.append((u, c)) while q: t, tc = q.popleft() i = h[t] while i != -1: to = e[i] if not color[to]: color[to] = 3 - tc q.append((to, 3 - tc)) elif color[to] == tc: return False i = ne[i] return True if __name__ == '__main__': n, m = map(int, input().split()) N = n + 10; M = 2 * m + 10 h = [-1] * N e = [0] * M ne = [0] * M idx = 0 color = [0] * N for _ in range(m): a, b = map(int, input().split()) add(a, b); add(b, a) flag = True for i in range(1, n + 1): if not color[i]: if not bfs(i, 1): flag = False break if flag: print(\"Yes\") else: print(\"No\") AcWing 861 AcWing 861 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 510, M = 100010; int n1, n2, m; int h[N], e[M], ne[M], idx; int match[N]; bool st[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a], h[a] = idx++; &#125; bool find(int x) &#123; for (int i = h[x]; i != -1; i = ne[i]) &#123; int to = e[i]; if (!st[to]) &#123; st[to] = true; if (!match[to] || find(match[to])) &#123; match[to] = x; return true; &#125; &#125; &#125; return false; &#125; int main() &#123; scanf(\"%d%d%d\", &amp;n1, &amp;n2, &amp;m); memset(h, -1, sizeof h); while (m--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); &#125; int res = 0; for (int i = 1; i &lt;= n1; i++) &#123; memset(st, false, sizeof st); if (find(i)) res++; &#125; printf(\"%d\", res); return 0; &#125; def add(a, b): global idx e[idx] = b ne[idx] = h[a]; h[a] = idx idx += 1 def find(x): i = h[x] while i != -1: to = e[i] if not st[to]: st[to] = True if not match[to] or find(match[to]): match[to] = x return True i = ne[i] return False if __name__ == '__main__': n1, n2, m = map(int, input().split()) N = max(n1, n2) + 10; M = m + 10 h = [-1] * N e = [0] * M ne = [0] * M idx = 0 st = [False] * N match = [0] * N for _ in range(m): a, b = map(int, input().split()) add(a, b) res = 0 for i in range(1, n1 + 1): st = [False] * N if find(i): res += 1 print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"搜索与图论","slug":"Algorithm/AcWing/算法基础课/搜索与图论","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://www.leolang.top/tags/Graph-Algorithms/"},{"name":"Bipartite Graph","slug":"Bipartite-Graph","permalink":"https://www.leolang.top/tags/Bipartite-Graph/"},{"name":"Hungarian Algorithm","slug":"Hungarian-Algorithm","permalink":"https://www.leolang.top/tags/Hungarian-Algorithm/"}]},{"title":"AcWing 搜索与图论（三）","slug":"搜索与图论（三）最小生成树","date":"2021-07-27T16:00:00.000Z","updated":"2022-04-06T08:11:39.085Z","comments":true,"path":"2021/07/28/搜索与图论（三）最小生成树/","link":"","permalink":"https://www.leolang.top/2021/07/28/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"前言 本文将介绍关于两大最小生成树算法的相关内容，分别为 \\(Prim\\) 算法、 \\(Kruskal\\) 算法。同时，将给出算法的实现模板。","text":"前言 本文将介绍关于两大最小生成树算法的相关内容，分别为 \\(Prim\\) 算法、 \\(Kruskal\\) 算法。同时，将给出算法的实现模板。 搜索与图论（三）最小生成树 最小生成树的问题对应的图都是无向图。常用的算法就是 \\(Prim\\)​​ 算法和 \\(Kruskal\\)​​ 算法。 \\(Prim\\)​​ 算法有两种，对于稠密图一般用朴素的 \\(Prim\\)​​ 算法，时间复杂度为 \\(O(n^2)\\)​​，而稀疏图一般用堆优化版的 \\(Prim\\)​​​ 算法，优化方式类似于对于朴素 \\(Dijkstra\\)​​ 的堆优化方式，时间复杂度为 \\(O(m\\log n)\\)​​ 。\\(Kruskal\\)​​ 算法的时间复杂度为 \\(O(m\\log m)\\)​​ 。一般是稠密图使用朴素的 \\(Prim\\)​​ 算法，而稀疏图一般是使用 \\(Kruskal\\)​​ 算法。 一、朴素 \\(Prim\\) 算法 朴素 \\(Prim\\)​ 算法的步骤是： 初始化：将所有点的距离初始化为正无穷，即 \\(\\forall i,dist[i]=+\\infty\\)​ 记当前已经产生的生成树中点的集合为 \\(S\\) ，即 \\(S\\) 为当前连通块内点的集合。找到集合外距离集合 \\(S\\) 最近的点为 \\(t\\) 。这里集合外一点 \\(x\\) 到集合 \\(S\\) 的距离定义为：集合 \\(S\\) 内有若干点都与 \\(x\\) 有边相连，距离分别为 \\(w_1,w_2,\\cdots,w_m\\) ，记距离为 \\(r\\) ，则有 \\(r=\\min\\{w_1,w_2,\\cdots,w_m\\}\\) 。之后，将 \\(t\\) 并入集合中，即 \\(S=S\\cup\\{t\\}\\) 。最后，用 \\(t\\) 更新其他不在 \\(S\\) 中的点与集合 \\(S\\)​ 的距离。 注：这里是先并入集合后更新距离，目的是防止数据中有自环的情况，因为树中不可能存在自环。但如果存在一个负权自环，假设先更新了距离，那么在用与 \\(t\\) 相连的所有边去更新距离数组 \\(dist\\) 时， \\(dist[t]\\)​ 就会被更新成该负权自环的权值（因为没有正数能比负数小了），那么到时候并入 \\(t\\) 也就并入了一个最小的边是负权自环边，但我们要的是刚刚的那个没被更新的 \\(dist[t]\\) 所存储的那条边，这样就相当于并入错误。 循环上述过程 \\(n\\)​​ 次，每次都获取图中的一个点，其距离对应的那一条边即为生成树中的一条边 。算法结束。 需要注意的是，该算法与朴素的 \\(Dijkstra\\) 算法的模板基本一致，但要注意的是 \\(dist\\) 数组的含义发生了变化，这里 \\(dist\\) 数组存储的是某点到当前集合 \\(S\\) 的最短距离。 const int N = ..., INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() &#123; memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[t] > dist[j])) t = j; &#125; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); st[t] = true; &#125; return res; &#125; int main() &#123; /* read in */ memset(g, 0x3f, sizeof g); /* read in edges */ int res = prim(); /* something else */ &#125; 二、 \\(Kruskal\\) 算法 \\(Kruskal\\) 算法的步骤是： 将所有边的权值从小到大排序，时间复杂度为 \\(O(m\\log m)\\) 枚举每条边，记边为三元组 \\((a,b,w)\\) ，如果 \\(a,b\\) 两点不连通，则将该边加入集合中。该步骤的实现方式是并查集。 int n, m; int p[N]; struct Edge &#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125; &#125; edges[N]; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int kruskal() &#123; sort(edges, edges + m); for (int i = 1; i &lt;= n; i++) p[i] = i; int res = 0, cnt = 1; for (int i = 0; i &lt; m; i++) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) &#123; p[a] = b; res += w; cnt++; &#125; &#125; if (cnt &lt; n) return -1; else return res; &#125; int main() &#123; /* read in */ int res = kruskal(); /* something else */ &#125; 习题 AcWing 858 AcWing 858 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; int g[N][N]; int dist[N]; bool st[N]; int prim() &#123; memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], g[t][j]); st[t] = true; &#125; return res; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m--) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); g[a][b] = g[b][a] = min(g[a][b], w); &#125; int res = prim(); if (res == INF) cout &lt;&lt; \"impossible\"; else printf(\"%d\", res); return 0; &#125; def prim(): global n res = 0 for i in range(n): t = -1 for j in range(1, n + 1): if not st[j] and (t == -1 or dist[j] &lt; dist[t]): t = j if i and dist[t] == float('inf'): return float('inf') if i: res += dist[t] st[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], g[t][j]) return res if __name__ == '__main__': n, m = map(int, input().split()) N = n + 10 g = [[float('inf')] * N for _ in range(N)] dist = [float('inf')] * N st = [False] * N for _ in range(m): a, b, w = map(int, input().split()) g[a][b] = g[b][a] = min(g[a][b], w) res = prim() if res == float('inf'): print(\"impossible\") else: print(res) AcWing 859 AcWing 859 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 200010; int n, m; int p[N]; struct Edge &#123; int a, b, w; bool operator&lt; (const Edge &amp;E)const &#123; return w &lt; E.w; &#125; &#125; edges[N]; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int kruskal() &#123; for (int i = 1; i &lt;= n; i++) p[i] = i; sort(edges, edges + m); int res = 0, cnt = 1; for (int i = 0; i &lt; m; i++) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) &#123; p[a] = b; cnt++; res += w; &#125; &#125; if (cnt &lt; n) return -1; else return res; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); edges[i] = &#123;a, b, w&#125;; &#125; int res = kruskal(); if (res == -1) cout &lt;&lt; \"impossible\"; else printf(\"%d\", res); return 0; &#125; def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] def kruskal(): global edges edges = sorted(edges, key=lambda edge: edge[-1]) res = 0; cnt = 1 for edge in edges: a, b, w = edge[:] a = find(a); b = find(b) if a != b: p[a] = b res += w cnt += 1 return -1 if cnt &lt; n else res if __name__ == '__main__': n, m = map(int, input().split()) p = [i for i in range(n + 1)] edges = [] for _ in range(m): a, b, w = map(int, input().split()) edges.append((a, b, w)) res = kruskal() if res == -1: print(\"impossible\") else: print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"搜索与图论","slug":"Algorithm/AcWing/算法基础课/搜索与图论","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://www.leolang.top/tags/Graph-Algorithms/"},{"name":"Minimum spanning tree","slug":"Minimum-spanning-tree","permalink":"https://www.leolang.top/tags/Minimum-spanning-tree/"},{"name":"Prim","slug":"Prim","permalink":"https://www.leolang.top/tags/Prim/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://www.leolang.top/tags/Kruskal/"},{"name":"Union Set","slug":"Union-Set","permalink":"https://www.leolang.top/tags/Union-Set/"}]},{"title":"AcWing 搜索与图论（二）","slug":"搜索与图论（二）最短路","date":"2021-07-27T16:00:00.000Z","updated":"2022-05-05T14:07:30.721Z","comments":true,"path":"2021/07/28/搜索与图论（二）最短路/","link":"","permalink":"https://www.leolang.top/2021/07/28/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"前言 本文将介绍关于几大最短路算法的相关内容，包括 \\(Dijkstra\\) 算法，\\(Bellman-Ford\\) 算法，\\(SPFA\\) 算法，\\(Floyed\\) 算法的相关内容，并给出算法实现模板。","text":"前言 本文将介绍关于几大最短路算法的相关内容，包括 \\(Dijkstra\\) 算法，\\(Bellman-Ford\\) 算法，\\(SPFA\\) 算法，\\(Floyed\\) 算法的相关内容，并给出算法实现模板。 搜索与图论（二）最短路 约定 \\(G=(V,E)\\) 中， \\(|V(G)|=n,|E(G)|=m\\) 常见的最短路有两种，分别为：单源最短路、多源汇最短路。单源最短路是求从一个点到其他所有点的最短距离。多源汇最短路是有多个起点，多个终点，要求求出其最短路。 单源最短路还可以分为两类：所有边的权值都是正数、存在权值为负的边。解决正边权的算法有：朴素 \\(Dijsktra\\)​​ 算法，时间复杂度为 \\(O(n^2)\\)​​ ，复杂度与边数无关，适用于边很稠密的图，一般是 \\(m\\sim n^2\\)；堆优化的 \\(Dijkstra\\) 算法 ，时间复杂度为 \\(O(m\\log n)\\) ，适用于边相对稀疏的图，一般是 \\(m\\sim n\\)。解决存在负权边的算法有： \\(Bellman-Ford\\) 算法，时间复杂度为 \\(O(nm)\\) ；\\(SPFA\\) 算法，是 \\(Bellman-Ford\\) 算法的优化，一般时间复杂度为 \\(O(m)\\) ，最坏情况下是 \\(O(nm)\\) ​​。 解决多源汇最短路的算法是 \\(Floyed\\) 算法，时间复杂度为 \\(O(n^3)\\) 。 最短路问题的难点在于如何抽象问题为一个图，如何建图。 一、朴素的 \\(Dijkstra\\)​ 算法 算法的基本思想是贪心，朴素的 \\(Dijkstra\\)​ 算法的步骤如下： 初始化：假设起点为 \\(v_1\\) ，初始化距离，记距离数组为 \\(dist\\) ，由于只知道起点，起点到他自身的距离是 \\(0\\) ，则初始化 \\(dist[1]=0,dist[i]=+\\infty(i\\neq1)\\) ，初始化 \\(S\\)​ 为当前已确定最短距离的点的集合。 找到不在 \\(S\\)​​ 中的距离最近的点（ \\(dist\\)​ 数组的最小值对应的点），记为 \\(t\\)​ ，将 \\(t\\)​ 加入 \\(S\\)​ ，即 \\(S=S\\cup\\{t\\}\\)​ 。之后用 \\(t\\)​ 更新与 \\(t\\)​ 邻接的结点与起点的距离（当然这里遍历所有点就可以了，不需要管到底与谁邻接），如果对于某一点 \\(x\\)​ 存在关系 \\(dist[x]&gt;dist[t]+w\\)​ 成立，则更新其距离值为 \\(dist[t]+w\\)​ 。 将上述过程循环 \\(n\\) 次，每一次都得到一个点的最短路。最后得到所有点的最短路。 两重循环，时间复杂度为 \\(O(n^2)\\) 。 由于该算法针对的是稠密图，所以本算法用邻接矩阵来存图，由于距离是最短距离，且边权均为正值，则自环不可能出现于最短路中。对于重边，则取最小的边存入即可。 int n, m; int g[N][N]; int dist[N]; bool st[N]; int dijkstra() &#123; memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for (int i = 0; i &lt; n; i++) &#123; // 遍历所有点 int t = -1; for (int j = 1; j &lt;= n; j++) &#123; // 循环所有的点找到未确定最短路的、最小dist值的点 if (!st[j]) &amp;&amp; (t == -1 || dist[t] > dist[j]) t = j; &#125; st[t] = true; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); // 更新dist值 &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; &#125; int main() &#123; /* read in */ memset(g, 0x3f, sizeof(g)); while (m--) &#123; /* read in */ g[a][b] = min(g[a][b], c); // 可能存在重边和自环 &#125; int res = dijkstra(); return 0; &#125; 二、堆优化的 \\(Dijkstra\\)​ 算法 如果是一个稀疏图，两重循环由于范围太大肯定会爆时间。那么就需要优化上面的朴素算法。朴素算法最慢的位置其实是在寻找最小值这一块，那么我们就能想到堆这个数据结构了，就能够将寻找最小值的时间复杂度从 \\(O(n^2)\\) 降为 \\(O(n)\\) ，但相应的，修改堆的一个值要付出的时间代价为 \\(O(\\log n)\\) ，那么用 \\(t\\) 更新距离这一步的时间复杂度就提升至 \\(O(m\\log n)\\) ，但其实时间复杂度仍然是下降的，整个算法的时间复杂度降为 \\(O(\\log n)\\)。 实现堆的方式有两种：一种是手写堆，就是第二讲里面后面讲的有两个映射的那个堆，这种写法虽然说相对麻烦，但好处就是堆中节点始终就只有 \\(n\\) 个；另一种就是优先队列，例如 STL 中的 priority_queue ，这种修改堆中元素方式就是直接向堆中插入一个元素，这样的话队列中的元素可能有 \\(m\\) 个会有冗余，时间复杂度其实是 \\(O(m\\log m)\\)​ ，但其实和 \\(O(m\\log n)\\)​ 相差不大。这样的话可能出现冗余的情况，此时就用状态数组，即这个点是否已经被找到了最短路径来判断当前最小值是否有效即可。 由于算法针对的是稀疏图，那么就要改成邻接表的方式存储图。 typedef pair&lt;int, int> PII; // pair: distance, number int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; int dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII>, greater&lt;PII>> heap; // 小根堆 heap.push(&#123;0, 1&#125;); while (heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; // redundancy 冗余 else st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > distance + w[i]) &#123; dist[to] = distance + w[i]; heap.push(&#123;dist[to], to&#125;); &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edge info */ int res = dijkstra(); return 0; &#125; 三、 \\(Bellman-Ford\\) 算法 \\(Bellman-Ford\\) 算法的思路是： 迭代 \\(n\\) 次，每次循环所有边，记边为三元组 \\((a,b,w)\\) ，更新 \\(dist\\) 数组为 \\(dist[b]=\\min\\{dist[b],dist[a]+w\\}\\) （松弛操作）。最后所有边均满足 \\(dist[b]\\leq dist[a]+w\\)​ ，被称为三角不等式。 如果图中存在负权回路，那图中可能没有最短路，如果负环不在最短路上，那么最短路仍然存在。 迭代 \\(k\\) 次的有更新的含义是，图中存在经过不超过 \\(k\\)​ 条边的最短路。则如果迭代到 \\(n\\) 还有更新，证明存在一条边数为 \\(n\\)​ 的最短路，那么路上的点数为 \\(n+1\\)​ ，由抽屉原理，路上必有两个点是相同的，证明图中存在负环。 如果是有边数限制的最短路问题（有负权边、负权回路），只能用 \\(Bellman-Ford\\)​ 算法求解。 算法要求本次更新的 \\(dist\\)​ 必须使用上一次迭代的结果，但在枚举边的过程中不排除有 \\(a\\to b\\to c\\) 的类似形式，我们可能由于读入的顺序问题首先更新了 \\(a\\to b\\) ，之后又更新 \\(b\\to c\\) ，但事实上如果没有备份 \\(dist\\) 上一次迭代的结果的话，就会发生用 \\(a\\to b\\) 的结果去更新了 \\(b\\to c\\) ，这样就违背了算法的本意了。所以我们设立备份数组 \\(backup\\) 用以存储上一次迭代的结果。 int n, m, k; int dist[N], backup[N]; // backup是dist的备份 struct Edge &#123; int a, b, w; &#125; edges[M]; int bellman_ford() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0'; for (int i = 0; i &lt; k; i++) &#123; memcpy(backup, dist, sizeof dist); for (int j = 0; j &lt; m; j++) &#123; int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); &#125; &#125; if (dist[n] > 0x3f3f3f3f / 2) return -1; // 可能两个点都无法到达，但是两个点之间存在一条负权边，那么出点会将入点的无穷更新成一个小于正无穷的数，这时就可能出现问题，这个点的dist不等于无穷，那么其实如果写成 dist == INF 就不成立了。 return dist[n]; &#125; int main() &#123; /* read in */ int res = bellman_ford(); /* something else */ &#125; 四、 \\(SPFA\\) 算法 \\(SPFA\\) 针对于 \\(Bellman-Ford\\) 算法的 \\(dist[b]=\\min\\{dist[b],dist[a]+w\\}\\) 的这一步骤进行优化，因为只有在 \\(dist[a]\\) 被更新成一个更小的值时， \\(dist[b]\\) 才有可能被更新成一个更小的值。 \\(SPFA\\) 使用 BFS 进行优化，迭代过程中创建一个辅助队列，队列中存储的是被更新后变小的结点。首先起点入队，每当队列不空，首先取出队头记为 \\(t\\) ，更新 \\(t\\) 的所有出边 \\((t,x_i,w_i)\\) ，如果当前的终点 \\(dist[x_i]\\) 被更新值减小，则将 \\(x_i\\) 入队，循环该过程，直至队列为空，更新完成。 SPFA 求最短路 int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; // if the vertex is in queue void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; int spfa() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int> q; q.push(1); st[1] = true; while (q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > dist[t] + w[i]) &#123; dist[to] = dist[t] + w[i]; if (!st[to]) &#123; q.push(to); st[to] = true; &#125; &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edge info */ int res = spfa(); /* something else */ return 0; &#125; ### SPFA 判断负环 我们增加一数组 \\(cnt\\)​​ 以记录当前最短路边的数量，每次更新 \\(dist\\)​ 数组的同时更新 \\(cnt\\)​ 数组的值。记当前点为 \\(x\\)​ ，如果更新 \\(dist[x]=dist[t]+w\\)​ ，则更新 \\(cnt[x]=cnt[t]+1\\)​​ 。因为相当于说现在的路径长度是本来的 \\(cnt[t]\\)​ 加上了一条边 \\(t\\to x\\)​ ，则有了这样的更新方式。如果 \\(cnt[x]\\geq n\\)​ ，则证明到达 \\(x\\)​ 经过了 \\(\\geq n\\)​ 的边数，那么由抽屉原理，其中两个点是相同的，证明图中存在负环。 这里需要注意两点：一是这里没必要初始化 \\(dist\\) 数组了，因为我们只看数值上的相对变化，最后并不需要一个绝对的数值；二是可能负环不一定能够从 \\(1\\) 号点走通，所以开始的时候要将所有节点全都入队，每个点都需要从它开始一次。 int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N], cnt[N]; bool st[N]; // if the vertex is in queue void add(int a, int b, int w) &#123; e[idx] = b, w[idx] = w; ne[idx] = h[a], h[a] = idx++; &#125; int spfa() &#123; queue&lt;int> q; for (int i = 1; i &lt;= n; i++) &#123; st[i] = true; q.push(i); &#125; while (q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > dist[t] + w[i]) &#123; dist[to] = dist[t] + w[i]; cnt[to] = cnt[t] + 1; if (cnt[j] >= n) return true; if (!st[to]) &#123; q.push(to); st[to] = true; &#125; &#125; &#125; &#125; return false; &#125; int main() &#123; /* read in */ memset(h, -1, sizeof h); /* read in edge info */ bool ifCircle = spfa(); /* something else */ return 0; &#125; 五、 \\(Floyed\\) 算法 使用邻接矩阵存储所有的点边，记 \\(d_{ij}\\) 为 \\(v_i\\) 到 \\(v_j\\) 的最短路长度。则经过如下的三重循环可以得到最短路的长度。 int d[N][N]; // adjacent matrix for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125; &#125; 邻接矩阵应对重边和自环 const int INF = 1e9; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) d[i][j] = 0; else d[i][j] = INF; &#125; &#125; /* read in query */ if (d[a][b] > INF / 2) cout &lt;&lt; \"impossible\" &lt;&lt; endl; else printf(\"%d\\n\", d[a][b]); 习题 AcWing 849 AcWing 849 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 510; int n, m; int g[N][N]; int dist[N]; bool st[N]; int dijkstra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 1; i &lt;= n; i++) &#123; int t = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; &#125; st[t] = true; for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while (m--) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); g[a][b] = min(g[a][b], w); &#125; int res = dijkstra(); printf(\"%d\", res); return 0; &#125; def dijkstra(): global n, m dist[1] = 0 for i in range(n): t = -1 for j in range(1, n + 1): if not st[j] and (t == -1 or dist[j] &lt; dist[t]): t = j st[t] = True for j in range(1, n + 1): dist[j] = min(dist[j], dist[t] + g[t][j]) if dist[n] == float('inf'): return -1 else: return dist[n] if __name__ == '__main__': n, m = map(int, input().split()) g = [[float('inf')] * (n + 1) for _ in range(n + 1)] dist = [float('inf')] * (n + 1) st = [False] * (n + 1) for _ in range(m): a, b, w = map(int, input().split()) g[a][b] = min(g[a][b], w) res = dijkstra() print(res) AcWing 850 AcWing 850 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> #include &lt;queue> using namespace std; typedef pair&lt;int, int> PII; const int N = 1.5e5 + 10; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; int dijsktra() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII>, greater&lt;PII>> heap; heap.push(&#123;0, 1&#125;); while (heap.size()) &#123; auto t = heap.top(); heap.pop(); int distance = t.first, vertex = t.second; if (st[vertex]) continue; else st[vertex] = true; for (int i = h[vertex]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > distance + w[i]) &#123; dist[to] = distance + w[i]; heap.push(&#123;dist[to], to&#125;); &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; &#125; int main() &#123; memset(h, -1, sizeof h); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); add(a, b, w); &#125; int res = dijsktra(); printf(\"%d\", res); return 0; &#125; import heapq def add(a, b, c): global idx e[idx] = b; w[idx] = c ne[idx] = h[a]; h[a] = idx idx += 1 def dijkstra(): dist[1] = 0 heap = [] heapq.heappush(heap, (0, 1)) while heap: t = heapq.heappop(heap) distance = t[0]; vertex = t[-1] if st[vertex]: continue st[vertex] = True i = h[vertex] while i != -1: to = e[i] if dist[to] > distance + w[i]: dist[to] = distance + w[i] heapq.heappush(heap, (dist[to], to)) i = ne[i] return -1 if dist[n] == float('inf') else dist[n] if __name__ == '__main__': n, m = map(int, input().split()) N = int(1.5e5 + 10) h = [-1] * N w = [0] * N e = [0] * N ne = [0] * N idx = 0 dist = [float('inf')] * N st = [False] * N for _ in range(m): a, b, c = map(int, input().split()) add(a, b, c) res = dijkstra() print(res) from queue import PriorityQueue as pq def add(a, b, c): global idx e[idx] = b; w[idx] = c ne[idx] = h[a]; h[a] = idx idx += 1 def dijkstra(): dist[1] = 0 heap = pq() heap.put((0, 1)) while heap.queue: t = heap.get() distance = t[0]; vertex = t[-1] if st[vertex]: continue st[vertex] = True i = h[vertex] while i != -1: to = e[i] if dist[to] > distance + w[i]: dist[to] = distance + w[i] heap.put((dist[to], to)) i = ne[i] return -1 if dist[n] == float('inf') else dist[n] if __name__ == '__main__': n, m = map(int, input().split()) N = int(1.5e5 + 10) h = [-1] * N w = [0] * N e = [0] * N ne = [0] * N idx = 0 dist = [float('inf')] * N st = [False] * N for _ in range(m): a, b, c = map(int, input().split()) add(a, b, c) res = dijkstra() print(res) 注：Python 中实现优先队列或堆的方式有两种： import heapq import heapq heap = [] # Push the value item onto the heap, maintaining the heap invariant. heapq.heappush(heap, item) # Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. # To access the smallest item without popping it, use heap[0]. heapq.heappop(heap) # Push item on the heap, then pop and return the smallest item from the heap. NewHeapTop = heapq.heappushpop(heap, item) # Transform list x into a heap, in-place, in linear time. heapq.heapify(x) # Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised. OldHeapTop = heapq.heapreplace(heap, item) # Return a list with the n largest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key, reverse=True)[:n]. heapq.nlargest(n, iterable, key=None) # Return a list with the n smallest elements from the dataset defined by iterable. key, if provided, specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). Equivalent to: sorted(iterable, key=key)[:n]. heapq.nsmallest(n, iterable, key=None) from queue import PriorityQueue from queue import PriorityQueue pq = PriorityQueue pq.put(item) item = pq.get() 关于 queue 模块有以下几点： 其实现了同步的、线程安全的队列类，包括 FIFO 的 Queue 、 LIFO 的 LifoQueue 、优先队列 PriorityQueue 常用的方法为以下几个： # create a queue Queue(maxsize: int = ...) # return size of queue Queue.qsize() # return if queue is empty Queue.empty() # return if queue is full, equals to args: maxsize Queue.full() # push item into queue Queue.put(item) # get item from queue item = Queue.get() AcWing 853 AcWing 853 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 510, M = 10010; int n, m, k; int dist[N], backup[N]; struct Edge &#123; int a, b, w; &#125; edges[M]; int bellman_ford() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) &#123; memcpy(backup, dist, sizeof dist); for (int j = 0; j &lt; m; j++) &#123; int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); &#125; &#125; if (dist[n] > 0x3f3f3f3f / 2) return -1; else return dist[n]; &#125; int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); edges[i] = &#123;a, b, w&#125;; &#125; int res = bellman_ford(); if (res == -1) cout &lt;&lt; \"impossible\"; else printf(\"%d\", res); return 0; &#125; def bellman_ford(): global n, m, k dist[1] = 0 for i in range(k): backup = dist[:] for j in range(m): a, b, w = edges[j] dist[b] = min(dist[b], backup[a] + w) return -1 if dist[n] == float('inf') else dist[n] if __name__ == '__main__': n, m, k = map(int, input().split()) N = n + 10; M = m + 10 dist = [float('inf')] * N edges = [] for _ in range(m): a, b, w = map(int, input().split()) edges.append((a, b, w)) res = bellman_ford() if res == -1: print(\"impossible\") else: print(res) AcWing 851 AcWing 851 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> #include &lt;queue> using namespace std; const int N = 100010; int n, m; int h[N], w[N], e[N], ne[N], idx; int dist[N]; bool st[N]; void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; int spfa() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int> q; q.push(1); while (q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > dist[t] + w[i]) &#123; dist[to] = dist[t] + w[i]; if (!st[to]) q.push(to), st[to] = true; &#125; &#125; &#125; if (dist[n] == 0x3f3f3f3f) return -1; else return dist[n]; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while (m--) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); add(a, b, w); &#125; int res = spfa(); if (res == -1) cout &lt;&lt; \"impossible\"; else printf(\"%d\", res); return 0; &#125; from collections import deque def add(a, b, c): global idx e[idx] = b; w[idx] = c ne[idx] = h[a]; h[a] = idx idx += 1 def spfa(): dist[1] = 0 q = deque() q.append(1) while q: t = q.popleft() st[t] = False i = h[t] while i != -1: to = e[i] if dist[to] > dist[t] + w[i]: dist[to] = dist[t] + w[i] if not st[to]: st[to] = True q.append(to) i = ne[i] return -1 if dist[n] == float('inf') else dist[n] if __name__ == '__main__': n, m = map(int, input().split()) N = n + 10 M = m + 10 h = [-1] * N w = [0] * M e = [0] * M ne = [0] * M idx = 0 dist = [float('inf')] * N st = [False] * N for _ in range(m): a, b, c = map(int, input().split()) add(a, b, c) res = spfa() if res == -1: print(\"impossible\") else: print(res) AcWing 852 AcWing 852 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> #include &lt;queue> using namespace std; const int N = 2010, M = 10010; int n, m; int h[N], w[M], e[M], ne[M], idx; int dist[N], cnt[N]; bool st[N]; void add(int a, int b, int c) &#123; e[idx] = b, w[idx] = c; ne[idx] = h[a], h[a] = idx++; &#125; bool spfa() &#123; queue&lt;int> q; for (int i = 1; i &lt;= n; i++) &#123; q.push(i); st[i] = true; &#125; while (q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (dist[to] > dist[t] + w[i]) &#123; dist[to] = dist[t] + w[i]; cnt[to] = cnt[t] + 1; if (cnt[to] >= n) return true; if (!st[to]) st[to] = true, q.push(to); &#125; &#125; &#125; return false; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while (m--) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); add(a, b, w); &#125; if (spfa()) cout &lt;&lt; \"Yes\"; else cout &lt;&lt; \"No\"; return 0; &#125; from collections import deque def add(a, b, c): global idx e[idx] = b; w[idx] = c ne[idx] = h[a]; h[a] = idx idx += 1 def spfa(): global n q = deque() for i in range(1, n + 1): q.append(i) st[i] = True while q: t = q.popleft() st[t] = False i = h[t] while i != -1: to = e[i] if dist[to] > dist[t] + w[i]: dist[to] = dist[t] + w[i] cnt[to] = cnt[t] + 1 if cnt[to] >= n: return True if not st[to]: st[to] = True q.append(to) i = ne[i] return False if __name__ == '__main__': n, m = map(int, input().split()) N = n + 10 M = m + 10 h = [-1] * N w = [0] * M e = [0] * M ne = [0] * M idx = 0 dist = [0] * N cnt = [0] * N st = [False] * N for _ in range(m): a, b, c = map(int, input().split()) add(a, b, c) print(\"Yes\") if spfa() else print(\"No\") AcWing 854 AcWing 854 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 210, INF = 1e9; int n, m, q; int d[N][N]; int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) d[i][j] = 0; else d[i][j] = INF; &#125; &#125; while (m--) &#123; int a, b, w; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w); d[a][b] = min(d[a][b], w); &#125; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (d[i][j] > d[i][k] + d[k][j]) d[i][j] = d[i][k] + d[k][j]; &#125; &#125; &#125; while (q--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); if (d[a][b] > INF / 2) cout &lt;&lt; \"impossible\" &lt;&lt; endl; else printf(\"%d\\n\", d[a][b]); &#125; return 0; &#125; if __name__ == '__main__': n, m, q = map(int, input().split()) N = n + 10; M = m + 10 d = [[float('inf')] * N for _ in range(N)] for i in range(1, n + 1): d[i][i] = 0 for _ in range(m): a, b, w = map(int, input().split()) d[a][b] = min(d[a][b], w) for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if d[i][j] > d[i][k] + d[k][j]: d[i][j] = d[i][k] + d[k][j] for _ in range(q): a, b = map(int, input().split()) if d[a][b] == float('inf'): print(\"impossible\") else: print(d[a][b])","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"搜索与图论","slug":"Algorithm/AcWing/算法基础课/搜索与图论","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://www.leolang.top/tags/Graph-Algorithms/"},{"name":"DP","slug":"DP","permalink":"https://www.leolang.top/tags/DP/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://www.leolang.top/tags/Shortest-Path/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://www.leolang.top/tags/Dijkstra/"},{"name":"SPFA","slug":"SPFA","permalink":"https://www.leolang.top/tags/SPFA/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://www.leolang.top/tags/Bellman-Ford/"},{"name":"Floyed","slug":"Floyed","permalink":"https://www.leolang.top/tags/Floyed/"}]},{"title":"AcWing 搜索与图论（一）","slug":"搜索与图论（一）DFS 与 BFS","date":"2021-07-25T16:00:00.000Z","updated":"2022-04-06T08:10:30.016Z","comments":true,"path":"2021/07/26/搜索与图论（一）DFS 与 BFS/","link":"","permalink":"https://www.leolang.top/2021/07/26/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89DFS%20%E4%B8%8E%20BFS/","excerpt":"前言 本文将介绍关于深度优先搜索（DFS）和广度优先搜索（BFS）的相关内容。同时将介绍图和树的存储，以及在图中的 DFS 与 BFS。最后将介绍拓扑序列的相关内容。","text":"前言 本文将介绍关于深度优先搜索（DFS）和广度优先搜索（BFS）的相关内容。同时将介绍图和树的存储，以及在图中的 DFS 与 BFS。最后将介绍拓扑序列的相关内容。 搜索与图论（一）DFS 与 BFS DFS 和 BFS 又名深度优先搜索和广度优先搜索，二者都可以对整个空间进行搜索，搜索的结构类似于一棵树，不过顾名思义，DFS 更优先深度，而 BFS 更优先广度。 一、普通的 DFS 与 BFS 对比 DFS 与 BFS： 相关特点 DFS BFS 数据结构 栈 stack 队列 queue 空间 \\(O(h)\\) \\(O(2^h)\\) 最短性 不具有最短性 无权图 “最短路” 回溯、剪枝 DFS 和 BFS 想不清楚可以画一棵树，用搜索树帮助分析。 1.1 DFS 1.1.1 全排列 首先给出待填入的 \\(n\\)​​​​ 个空位，逐个填入空位的过程就是 DFS 的过程，每填入一个空位深度 \\(+1\\) 。比如说 \\(n=3\\) 时，用 \\(?\\) 代表尚且未知的空位，搜索树根结点的情况是 \\(???\\) 全空，然后第一位填 \\(1\\) ，结果就是 \\(1??\\)​ ，之后由于是深度优先搜索，所以我们继续向下搜索，继续填入数字，下一层节点为 \\(12?\\) ，再向下，就是 \\(123\\) 。此时已经不能再向下加深，我们就进行回溯，返回到上一层的 \\(12?\\) ，由于只有三个数字，该节点没有继续向下的分支了，所以我们继续回溯，回溯到 \\(1??\\) 。这时我们还可以从未被搜索的分支向下加深，于是得到了下一层的分支节点 \\(13?\\) ，之后继续加深，得到 \\(132\\) 。以此类推，最后就可以得到一棵 DFS 的搜索树。 需要注意的是，回溯的过程必须要恢复现场。在递归函数退出后必须要恢复现场，否则后续的递归过程中就会出现问题， int path[N]; bool st[N]; void dfs(int u) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) printf(\"%d \", path[i]); cout &lt;&lt; endl; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!st[i]) &#123; path[u] = i; st[i] = true; dfs(u + 1); // path[u] = 0; // 可写可不写，每次path[u]都会被覆盖 st[i] = false; // 恢复现场 &#125; &#125; &#125; int main() &#123; dfs(0); &#125; 1.1.2 n 皇后问题 方法一：思路类似于全排列，按行枚举，但过程中需要剪枝。剪枝的含义是如果当前方法必定错误，那么该节点的搜索树子树就没有必要被搜索了，直接回溯回去，不再向下进行。这一过程成为剪枝。 时间复杂度为 \\(O(n!)\\) char g[N][N]; bool col[N], dg[N], udg[N]; void dfs(int u) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) puts(g[i]); cout &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; g[u][i] = 'Q'; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; g[u][i] = '.'; &#125; &#125; &#125; int main() &#123; dfs(0); &#125; 方法二：按棋盘格子枚举。一个格子可以有放和不放两种情况。按行从左向右，按列从上到下分别枚举。 时间复杂度为 \\(O(2^{n^2})\\) char g[N][N]; bool row[N], col[N], dg[N], udg[N]; void dfs(int x, int y, int s) &#123; if (y == n) y = 0, x++; if (x == n) &#123; if (s == n) &#123; for (int i = 0; i &lt; n; i++) puts(g[i]); cout &lt;&lt; endl; &#125; return; &#125; g[x][y] = '.'; dfs(x, y + 1, s); // 这个位置不放皇后 if (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[n + y - x]) &#123; g[x][y] = 'Q'; row[x] = col[y] = dg[x + y] = udg[x - y + n] = true; dfs(x, y + 1, s + 1); // 这个位置放皇后 row[x] = col[y] = dg[x + y] = udg[x - y + n] = false; g[x][y] = '.'; &#125; &#125; int main() &#123; dfs(0, 0, 0); &#125; 注：这里的 \\((u,i),(x,y)\\) 都是指在棋盘上的坐标，对于对角线和反对角线的元素可以举几个例子就能知道下标关系了。 数学推导是： 对角线方程为 \\(y=-x+b\\) ，反对角线方程为 \\(y=x+b\\) ，那么其实画一个图就能够明白，其实点在第几根对角线上就是等于它那根对角线在 \\(y\\) 轴上的截距。那么也就得到，对角线 \\(b=y+x\\) ，反对角线 \\(b=y-x\\) 。因为下标不能为负，但反对角线由于是减法，可能出现负值，所以我们直接加上一个偏移量 \\(n\\) ，使得其下标一定为正即可。 1.2 BFS queue&lt;type> q; q.push(init_state); while (q.size()) &#123; t = q.front(); q.pop(); /* extend t */ &#125; 1.2.1 走迷宫 typedef pair&lt;int, int> PII; int g[N][N]; // graph int d[N][N]; // distance PII q[N * N]; // queue int bfs() &#123; int hh = 0, tt = 0; q[0] = &#123;0, 0&#125;; memset(d, -1, sizeof(d)); d[0][0] = 0; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; while (hh &lt;= tt) &#123; auto t = q[hh++]; for (int i = 0; i &lt; 4; i++) &#123; int x = t.first + dx[i], y = t.second + dy[i]; if (x >= 0 &amp;&amp; x &lt; n &amp;&amp; y >= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123; d[x][y] = d[t.first][t.second] + 1; q[++tt] = &#123;x, y&#125;; &#125; &#125; &#125; return d[n - 1][m - 1]; &#125; int main() &#123; /* read in */ cout &lt;&lt; bfs(); &#125; 二、树和图的存储 树是一种特殊的图，是无环联通图。图分为有向图和无向图。有向图的存储有两种，分别为邻接矩阵和邻接表。邻接矩阵比较浪费空间，空间复杂度为 \\(O(n^2)\\)​ ，适合用于存储稠密图，用的很少。邻接表是对于图中每个点，每个点都有一个单链表，存储该点的邻接点。邻接表的结构与哈希表拉链法完全相同，只不过是存储的东西不同。插入操作也和哈希表拉链法完全相同，也都是头插法。 int h[N]; // head of linklist, all of the vertex int e[M], ne[M], idx; // linklist memset(h, -1, sizeof(h)); // init 插入 void add(int a, int b) &#123; // add edge a->b e[idx] = b; ne[idx] = h[a]; h[a] = idx++; &#125; 三、图的 DFS 与 BFS 3.1 图的 DFS bool st[N]; void dfs(int u) &#123; st[u] = true; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) dfs(j); &#125; &#125; int main() &#123; memset(h, -1, sizeof(h)); /* read in */ dfs(1); &#125; 3.2 图的 BFS queue&lt;int> q; q.push(1); while (q.size()) &#123; t = q.front(); q.pop(); /* extend the adjacent vertex */ if (!st[x]) &#123; q.push(x); /* do something */ &#125; &#125; 四、拓扑序列 —— 图 BFS 的应用 有向图才有拓扑序列。若一个由图中所有点构成的序列 \\(A\\)​ 满足：对于图中的每条边 \\((x,y)\\)​ ，\\(x\\)​ 在 \\(A\\)​ 中都出现在 \\(y\\)​ 之前，则称 \\(A\\)​ 是该图的一个拓扑序列。可以证明，有向无环图一定存在拓扑序列，因为有向无环图一定存在一入度为 \\(0\\) 的点。故有向无环图被称为拓扑图。 拓扑序列的起点必定是入度为 \\(0\\) 的点，因为没有点会走到这个点。 那么，拓扑排序的思路就是： 入队所有入度为 \\(0\\) 的点 当队列不空时，出队对头元素 \\(t\\) ，枚举 \\(t\\) 的所有出边，并删除这些出边。以上的操作让与 \\(t\\) 邻接的各个点的入度减 \\(1\\) 。如果某个邻接节点的入度减为 \\(0\\) ，则将其入队，作为下一次循环的起点。思路其实是递归的，邻接点的入度减为了 \\(0\\) ，那么就可以让它作为拓扑排序的 “起点” 了。 循环上述过程，直至队列为空。 bool topo_sort() &#123; int hh = 0, tt = -1; for (int i = 1; i &lt;= n; i++) &#123; if (!d[i]) q[++tt] = i; &#125; while (hh &lt;= tt) &#123; int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; d[j]--; if (d[j] == 0) q[++tt] = j; &#125; &#125; return tt == n - 1; &#125; 习题 AcWing 842 AcWing 842 #include &lt;iostream> #include &lt;cstring> using namespace std; const int N = 10; int nums[N]; bool st[N]; int n; void dfs(int u) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; nums[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!st[i]) &#123; st[i] = true, nums[u] = i; dfs(u + 1); st[i] = false, nums[u] = 0; &#125; &#125; &#125; int main() &#123; cin >> n; memset(st, false, sizeof(st)); dfs(0); return 0; &#125; def dfs(u): global n if u == n: print(' '.join(map(str, nums))) return for i in range(1, n + 1): if not st[i]: nums[u] = i; st[i] = True dfs(u + 1) nums[u] = 0; st[i] = False if __name__ == '__main__': n = int(input()) nums = [0] * n st = [False] * (n + 1) dfs(0) AcWing 843 AcWing 843 第一种搜索方式： #include &lt;iostream> #include &lt;cstring> using namespace std; const int N = 10; int n; char g[N][N]; bool col[N], dg[N], udg[N]; void dfs(int u) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) printf(\"%s\\n\", g[i]); cout &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; g[u][i] = 'Q'; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); g[u][i] = '.'; col[i] = dg[u + i] = udg[n - u + i] = false; &#125; &#125; &#125; int main() &#123; cin >> n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; g[i][j] = '.'; &#125; &#125; dfs(0); return 0; &#125; def dfs(u): global n if u == n: for i in range(n): print(''.join(map(str, g[i]))) print() return for i in range(n): if not col[i] and not dg[u + i] and not udg[n - u + i]: g[u][i] = 'Q' col[i] = dg[u + i] = udg[n - u + i] = True dfs(u + 1) g[u][i] = '.' col[i] = dg[u + i] = udg[n - u + i] = False if __name__ == '__main__': n = int(input()) g = [['.'] * n for _ in range(n)] col = [False] * (2 * n) dg = [False] * (2 * n) udg = [False] * (2 * n) dfs(0) 第二种搜索方式： #include &lt;iostream> using namespace std; const int N = 20; int n; char g[N][N]; bool row[N], col[N], dg[N], udg[N]; void dfs(int x, int y, int u) &#123; if (y == n) y = 0, x++; if (x == n) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) printf(\"%s\\n\", g[i]); cout &lt;&lt; endl; &#125; return; &#125; dfs(x, y + 1, u); if (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[n + y - x]) &#123; g[x][y] = 'Q'; row[x] = col[y] = dg[x + y] = udg[n + y - x] = true; dfs(x, y + 1, u + 1); g[x][y] = '.'; row[x] = col[y] = dg[x + y] = udg[n + y - x] = false; &#125; &#125; int main() &#123; cin >> n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; g[i][j] = '.'; &#125; &#125; dfs(0, 0, 0); return 0; &#125; def dfs(x, y, u): global n if y == n: y = 0; x += 1 if x == n: if u == n: for i in range(n): print(''.join(map(str, g[i]))) print() return dfs(x, y + 1, u) if not row[x] and not col[y] and not dg[x + y] and not udg[n + y - x]: g[x][y] = 'Q' row[x] = col[y] = dg[x + y] = udg[n + y - x] = True dfs(x, y + 1, u + 1) g[x][y] = '.' row[x] = col[y] = dg[x + y] = udg[n + y - x] = False if __name__ == '__main__': n = int(input()) g = [['.'] * n for _ in range(n)] row = [False] * (2 * n) col = [False] * (2 * n) dg = [False] * (2 * n) udg = [False] * (2 * n) dfs(0, 0, 0) 注：第二种搜索方式复杂度太高，Python 会 TLE AcWing 844 AcWing 844 #include &lt;iostream> #include &lt;cstring> using namespace std; typedef pair&lt;int, int> PII; const int N = 110; int n, m; int g[N][N]; int d[N][N]; PII q[N * N]; int bfs() &#123; q[0] = &#123;0, 0&#125;; int hh = 0, tt = 0; d[0][0] = 0; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; while (hh &lt;= tt) &#123; auto t = q[hh++]; for (int i = 0; i &lt; 4; i++) &#123; int x = t.first + dx[i], y = t.second + dy[i]; if (x >= 0 &amp;&amp; x &lt; n &amp;&amp; y >= 0 &amp;&amp; y &lt; m &amp;&amp; d[x][y] == -1 &amp;&amp; g[x][y] == 0) &#123; d[x][y] = d[t.first][t.second] + 1; q[++tt] = &#123;x, y&#125;; &#125; &#125; &#125; return d[n - 1][m - 1]; &#125; int main() &#123; cin >> n >> m; memset(d, -1, sizeof(d)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin >> g[i][j]; &#125; &#125; cout &lt;&lt; bfs(); return 0; &#125; from collections import deque def bfs(): global n, m q = deque() q.append([0, 0]) d[0][0] = 0 dx = [1, 0, -1, 0] dy = [0, -1, 0, 1] while q: t = q.popleft() for i in range(4): x = t[0] + dx[i]; y = t[-1] + dy[i] if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and d[x][y] == -1 and g[x][y] == 0: d[x][y] = d[t[0]][t[-1]] + 1 q.append([x, y]) return d[n - 1][m - 1] if __name__ == '__main__': n, m = map(int, input().split()) g = [list(map(int, input().split())) for _ in range(n)] d = [[-1] * m for _ in range(n)] print(bfs()) AcWing 845 AcWing 845 本题思维量很大，很难。首先第一个突破点就是，为什么会想到用 BFS 。我们首先要将每一个三阶方阵的数值状态抽象为一个状态，这道题中需要求得的是一个最少的交换次数。那么，其实就是相当于求从初始状态到达最后规范状态的最短路长度。那么提到了最短路，而且本题中状态之间的距离都是相同的，距离就可以设为 \\(1\\) ，这样的话就满足了使用 BFS 的所有条件了。那么好了，本题我们使用 BFS 进行搜索。 之后就需要考虑的点有两个：如何表征每个状态？状态之间应该如何转移？ 首先来看第一个问题：如何表征每个状态？事实上，不难发现，每一个状态其实对应一个唯一的 \\(3\\times3\\) 方阵， 讲这个二维方阵降为一维行值，就得到了一个唯一的字符串。那么，可以看到实际上在搜索树中，每一个字符串都和唯一的距离值对应，这里定义距离值是根结点到当前状态的搜索路径最短长度，也就是 BFS 搜索出的长度。由于这种一一对应关系，不难想到要使用哈希表进行映射。所以我们使用 unordered_map 或各个语言中的 dict 或 Hashmap 等类似的结构来构建映射关系。这样的话第一个问题就解决了，我们得到了表征每个状态的方式。 那么接下来，第二个问题，状态之间应该如何转移？事实上，对于每一个状态中的 \\(x\\)​​​​​ ，它的下一个状态只能有四种移动方式。这个移动方式其实和走迷宫问题 AcWing 844 走迷宫 是一样的。都是在这样的一个二维坐标系下进行移动。那么处理思路就可以完全照搬过来了。由于我们表征每一个状态是将二维矩阵转换成了一维的数组，首先我们找到字符 \\(x\\)​​​​ 所在一维字符串中的位置，之后需要进行运算求得其在二维中的位置。记 \\(k\\)​​ 为字符 \\(x\\)​​ 在一维字符串中的位置，矩阵大小为 \\(n\\times m\\)​​ ，则运算公式为：\\(x=\\lfloor k/n\\rfloor,y=k\\mod m\\)​ 。之后我们进行移动，移动后的坐标满足矩阵大小边界，我们就可以判定该移动后的状态就是搜索树中的一个状态点（结点）。我们得到了一个状态点的字符串形式，如果这个状态还没有被我们搜索到过，那么就更新其距离值，并加入状态与距离映射的哈希表中​​。这里不同语言的处理可能不相同，但如果是修改了原状态的字符串应注意要恢复现场，因为枚举四种移动方式时都是从原状态开始移动的。 有了以上的两个问题的解决作为基础，我们就可以套用 BFS 的模板了。将初始状态入队，之后当队列不空时持续出队队首元素，如果该元素就是最终的状态，证明已经搜索结束， BFS 也随之结束，返回搜索得出的距离最小值；如果该元素还处于中间的某一个状态的话，就需要向下继续搜索。我们枚举其状态的转移，如果状态没有出现过，便将其入队以便于后续的操作。最终如果以上的过程全都执行完毕，但还是没有搜索到最终的状态，证明以该初始状态为起点所构建的状态树（搜索树）中最后没有最终状态这一结点。则搜索结束，返回 \\(-1\\) 。 #include &lt;iostream> #include &lt;algorithm> #include &lt;string> #include &lt;queue> #include &lt;unordered_map> using namespace std; int bfs(string start) &#123; string end = \"12345678x\"; unordered_map&lt;string, int> d; queue&lt;string> q; d[start] = 0; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; q.push(start); while (q.size()) &#123; auto t = q.front(); q.pop(); if (t == end) return d[t]; int dist = d[t]; int k = t.find('x'); int x = k / 3, y = k % 3; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i], ny = y + dy[i]; if (nx >= 0 &amp;&amp; nx &lt; 3 &amp;&amp; ny >= 0 &amp;&amp; ny &lt; 3) &#123; swap(t[k], t[3 * nx + ny]); if (!d.count(t)) &#123; d[t] = dist + 1; q.push(t); &#125; swap(t[k], t[3 * nx + ny]); &#125; &#125; &#125; return -1; &#125; int main() &#123; string start; for (int i = 0; i &lt; 9; i++) &#123; char c; cin >> c; start += c; &#125; cout &lt;&lt; bfs(start); return 0; &#125; from collections import deque def swap(src, a, b): edit = list(src) edit[a], edit[b] = edit[b], edit[a] return ''.join(edit) def bfs(start): end = '12345678x' d = &#123;start: 0, &#125; q = deque() q.append(start) dx = [1, 0, -1, 0]; dy = [0, 1, 0, -1] while q: t = q.popleft() if t == end: return d[t] dist = d[t] k = t.index('x') x = k // 3; y = k % 3 for i in range(4): nx = x + dx[i]; ny = y + dy[i] if 0 &lt;= nx &lt; 3 and 0 &lt;= ny &lt; 3: cur = swap(t, k, nx * 3 + ny) if cur not in d: d[cur] = dist + 1 q.append(cur) return -1 if __name__ == '__main__': start = ''.join(input().split()) print(bfs(start)) AcWing 846 AcWing 846 依照题意，其实树的重心到底是谁并不重要，重要的是我们要寻找到每一个点被删除后，剩下的连通块点数的最大值，之后对于每一个点都比较一下，最后得出一个最小值就是答案了。 那么现在问题就在于如何统计一个节点被删除后诸连通分支的节点数。首先假设这个点被删除了，看一下此时树的情况。树被分成了几个连通分支，一部分是它的逐个子树构成几个连通分支，另一部分是除了以它自身为根结点的其他节点构成另一大个连通分支。那么好了，显而易见的，我们只需要知道以它自身为根结点的子树中有多少节点，那么我们就能够知道剩下的一共有多少节点了，因为节点的总数我们是知道的。既然要知道逐个子树的节点数，我们就必须向下搜索。当然了，对于每个节点亦是如此，所以经过以上推理，我们应该使用 DFS 进行搜索，因为我们需要不断向下，也就是深度不断加深。 那么，我们这里假设 DFS 函数可以返回以当前节点为根结点的子树的节点数。套用 DFS 的思路，对于每一个节点，我们枚举它的诸子节点，如果没有被搜索过的话，就对其调用 DFS 函数，得以得到以这个子节点为根结点的子树的节点数。在进行枚举的同时，我们也需要去统计在当前父节点下方的诸子树中节点数的最大值，因为我们最后要得到一个整个图中的最大值，而其实得到了以父节点为根结点的子树的节点数后，其余节点数是易得的，转而我们需要的就是下面整个的一个最大值，最后拿来再进行一次比较得出最大值才是有效的。同时，我们由于得到了以诸子节点为根的子树的结点数，所以我们便能够通过累加的方式很容易的统计到以父节点为子树的结点数值。这时，当前节点之下的所有工作已经做完，需要向上进行比较。我们通过比较得到当前节点被删除后的一个连通分支节点数的最大值，之后再与当前的答案值进行比较，最终得到一个最小值。最终我们由于假设了 DFS 函数能够返回一个以当前节点为根的子树的节点数，我们就将统计得到的总数返回就可以了。 最后，从某一节点起开始对整棵树使用 DFS ，我们便得到了最终的答案。 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int n; int h[N], e[2 * N], ne[N * 2], idx; bool st[N]; int ans; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++; &#125; int dfs(int u) &#123; st[u] = true; int cnt = 0, sum = 1; for (int i = h[u]; i != -1; i = ne[i]) &#123; int to = e[i]; if (!st[to]) &#123; int sub = dfs(to); cnt = max(sub, cnt); sum += sub; &#125; &#125; cnt = max(cnt, n - sum); ans = min(ans, cnt); return sum; &#125; int main() &#123; scanf(\"%d\", &amp;n); memset(h, -1, sizeof(h)); ans = inf; for (int i = 0; i &lt; n - 1; i++) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b), add(b, a); &#125; dfs(1); printf(\"%d\", ans); return 0; &#125; def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 def dfs(u): global n, ans st[u] = True sum = 1; cnt = 0 i = h[u] while i != -1: to = e[i] if not st[to]: sub = dfs(to) cnt = max(cnt, sub) sum += sub i = ne[i] cnt = max(cnt, n - sum) ans = min(ans, cnt) return sum if __name__ == '__main__': n = int(input()) m = 2 * (n + 10) h = [-1] * (n + 10) st = [False] * (n + 10) e = [0] * m ne = [0] * m idx = 0 ans = float('inf') for _ in range(n - 1): a, b = map(int, input().split()) add(a, b); add(b, a) dfs(1) print(ans) AcWing 847 AcWing 847 #include &lt;iostream> #include &lt;cstring> #include &lt;algorithm> using namespace std; const int N = 100010; int n, m; int q[N]; int h[N], e[N], ne[N], idx; int d[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++; &#125; int bfs(int u) &#123; int hh = 0, tt = 0; q[0] = u; d[1] = 0; while (hh &lt;= tt) &#123; int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; if (d[to] == -1) &#123; q[++tt] = to; d[to] = d[t] + 1; &#125; &#125; &#125; return d[n]; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof(h)); memset(d, -1, sizeof(h)); while (m--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); &#125; cout &lt;&lt; bfs(1); return 0; &#125; from collections import deque def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 def bfs(u): global n q = deque() q.append(u) d[1] = 0 while q: t = q.popleft() i = h[t] while i != -1: to = e[i] if d[to] == -1: q.append(to) d[to] = d[t] + 1 i = ne[i] return d[n] if __name__ == '__main__': n, m = map(int, input().split()) h = [-1] * (n + 1) e = [0] * (m + 1) ne = [0] * (m + 1) idx = 0 d = [-1] * (n + 1) for _ in range(m): a, b = map(int, input().split()) add(a, b) print(bfs(1)) AcWing 848 AcWing 848 #include &lt;iostream> #include &lt;cstring> using namespace std; const int N = 100010; int n, m; int h[N], e[N], ne[N], idx; int de[N]; int q[N]; void add(int a, int b) &#123; e[idx] = b; ne[idx] = h[a]; h[a] = idx++; &#125; bool topo_sort() &#123; int hh = 0, tt = -1; for (int i = 1; i &lt;= n; i++) &#123; if (!de[i]) q[++tt] = i; &#125; while (hh &lt;= tt) &#123; int t = q[hh++]; for (int i = h[t]; i != -1; i = ne[i]) &#123; int to = e[i]; de[to]--; if (!de[to]) q[++tt] = to; &#125; &#125; return tt == n - 1; &#125; int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof(h)); while (m--) &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); de[b]++; &#125; if (!topo_sort()) cout &lt;&lt; \"-1\"; else &#123; for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); &#125; return 0; &#125; def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 def topo_sort(): global n hh = 0; tt = -1 for i in range(1, n + 1): if not de[i]: tt += 1; q[tt] = i while hh &lt;= tt: t = q[hh]; hh += 1 i = h[t] while i != -1: to = e[i] de[to] -= 1 if not de[to]: tt += 1; q[tt] = to i = ne[i] return tt == n - 1 if __name__ == '__main__': n, m = map(int, input().split()) h = [-1] * (n + 1) e = [0] * m ne = [0] * m idx = 0 de = [0] * (n + 1) q = [0] * n for _ in range(m): a, b = map(int, input().split()) add(a, b) de[b] += 1 if not topo_sort(): print(-1) else: print(' '.join(map(str, q))) 总结 处理 DFS、BFS问题其实一般的和图中的还不太一样，只不过是思想是类似的。一般的 DFS 和 BFS 是没有真正搜索的媒介的，而对于在图上进行的两种搜索来说都是以图为媒介，更准确的说是以有向图为媒介的一种搜索。其实不论是不是在图里去做两种搜索，一个很关键的东西就是 “状态” 。我们前面说过，如果想不明白一般的 DFS 和 BFS 的问题就去想它的搜索树。那其实问题还是没有解决，怎么去想搜索树？搜索树最本质的东西到底是什么？我认为搜索树最本质的东西其实是 ==状态== 和 ==状态间的转移== 。 搜索树中其实每个节点都对应了当前问题的一种状态，状态即是树节点的特征。在不同的题中我们会有各种各样的方式去标记这种状态，会有各种各样的方式去表征这种状态。一般题的第一突破口应该是我们应如何去如何表征这个状态，用什么去表征这个状态。从排列数字问题中来看，我们表征状态的方式就是一个具有 \\(n\\) 个空位的数组，每当填上一个数字就产生了一个状态。从 n 皇后问题中来看，我们表征状态的方式就是对于行、列、对角线、反对角线的一个坐标是否有值，当然了棋盘上如何摆放其实也是一种状态的体现，但更直观的还是上面说过的这四个特征表现。对于走迷宫问题，人在迷宫中的坐标就是一种状态，另外一个状态就是当前坐标下，这个人到底走了多远，实际上这两个状态构成了一个映射关系。对于八数码问题，状态就是当前二维矩阵的数值填法（ \\(x\\)​ 的位置），也是从初始状态移动到当前状态需要多少步的移动，这里其实也是构成了一个映射关系，也可以统筹成一个状态去看。至于为什么走迷宫问题为什么不和八数码一样用一个哈希表去记录，我个人觉得是因为走迷宫其实是有距离数组和原迷宫矩阵可以限制住走向不走回头路的。其实反过来看它也是一个映射关系，只不过是没用哈希表存储罢了，毕竟二维矩阵之间通过下标是很容易一一对应的。对于树图来看，每一个状态就确确实实是树图中的一个节点了，这个没有什么可说的。当然了可能每一个实际的结点会在题里有几个特征值来表征当前节点的，比如说树的重心问题中以当前节点为根的子树的一个整个的节点数、连通分支中最大的节点数，图中结点层次问题中每个点到根节点的距离。这都是特征，都是状态的体现。 接下来是状态间的转移，这其实就很简单了，就是从一个状态去到下一个状态发生了什么变化，是更新了坐标，还是更新了距离，还是更新了什么什么；还有怎么变化，是坐标向各个方向试探，还是枚举各个可能的情况，还是扩展和当前节点邻接的各个节点。 弄清了状态是什么，状态之间的转移，我认为其实题目分析的就已经差不多了。接下来就是代码上的细节该如何实现了。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"搜索与图论","slug":"Algorithm/AcWing/算法基础课/搜索与图论","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"DFS","slug":"DFS","permalink":"https://www.leolang.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://www.leolang.top/tags/BFS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://www.leolang.top/tags/Graph-Algorithms/"}]},{"title":"AcWing C++ STL 使用技巧","slug":"C++ 之 STL 使用技巧","date":"2021-07-24T16:00:00.000Z","updated":"2021-08-25T11:30:14.000Z","comments":true,"path":"2021/07/25/C++ 之 STL 使用技巧/","link":"","permalink":"https://www.leolang.top/2021/07/25/C++%20%E4%B9%8B%20STL%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"前言 本文将介绍 STL 的相关内容及使用技巧。","text":"前言 本文将介绍 STL 的相关内容及使用技巧。 C++ 之 STL 使用技巧 一、容器 以下为简化代码长度，容器均用其首字母代替。 容器通用方法： container&lt;int> c; c.size(); // O(1), return the size of container c.empty(); // O(1), return if the container is empty 1.1 vector 变长数组，即数组长度是动态的，是基于倍增思想实现的。 定义 vector&lt;int> a; vector&lt;int> a(size); vector&lt;int> a(size, element); 方法 a.clear(); // clear a vector a.front(); a.back(); a.push_back(); a.pop_back(); a.begin(); // return the begin iterator of vector a.end(); // return the next iterator of the end of vector a.operator[](); // locate an element a.operator&lt;(); // compare in alphabet order 遍历：以输出为例 for (int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; ' '; for (vector&lt;int>::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' '; // or write as // for (auto i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' '; for (auto &amp;x : a) cout &lt;&lt; x &lt;&lt; ' '; 1.2 string 字符串 s.clear(); s.operator+(); s.operator+=(); s.substr(pos = 0); // return a substring of origin string, from position = pos s.substr(pos = 0, len); // return a substring of origin string, length = len s.c_str(); // return origin string as a char* type 1.3 queue, priority_queue queue：队列 q.push(item); // push an item into queue q.front(); // get the reference of the front of queue q.back(); // get the reference of the back of queue q.pop(); // pop an item from queue q = queue&lt;int>(); // clear a queue priority_queue：优先队列（堆），默认是大根堆 定义 priority_queue&lt;int> heap; // big root heap 建立小根堆 priority_queue&lt;int> heap; heap.push(-x); /** header * #include &lt;vector> * #include &lt;algorithm> * using namespace std; */ priority_queue&lt;int, vector&lt;int>, greater&lt;int>> heap; 方法 heap.push(); // push an item into heap heap.top(); // get the reference of the top of heap heap.pop(); // pop the top of heap 1.4 stack 栈 stk.push(); // push an item into stack stk.top(); // get the reference of the top of the heap stk.pop(); // pop an item from stack 1.5 deque 双端队列：队头队尾都可以插入、删除 dq.clear(); dq.front(); dq.back(); dq.push_back(); dq.pop_back(); dq.begin(); dq.end(); dq.operator[](); 1.6 pair 可以存储一个二元组 定义 template &lt;typename _type1, typename _type2> pair&lt;_type1, _type2> p; 取得二元组中元素 p.first; p.second; 支持比较运算，以 first 为第一关键字，second 为第二关键字 构造 pair 函数构造 p = make_pair(x, y); 列表初始化构造 p = &#123;x, y&#125;; 存储三元组：pair&lt;type, pair&lt;type, type&gt;&gt; 1.7 set, map, multiset, multimap 基于平衡二叉树（红黑树）实现的，能够动态维护有序序列 1.7.1 set, multiset 方法 \\(O(\\log n)\\)​ set&lt;int> S; multiset&lt;int> MS; // the following method also can be called by MS S.clear(); S.begin(); S.end(); S.operator++(); S.operator--(); S.insert(); // insert an item in set S.find(); // find an item in set and return its iterator, else return S.end() S.count(); // return the number of an item S.erase(x); // erase all these x in set O(k + log_n) S.erase(iterator); // erase this iterator in set S.lower_bound(x); // return iterator which is minimum >= x, else S.end() S.upper_bound(x); // return iterator which is minimun > x, else S.end() 1.7.2 map, multimap 方法 \\(O(\\log n)\\) map&lt;string, int> a; multimap&lt;type, type> a; a.clear(); a.begin(); a.end(); a.operator++(); a.operator--(); a.insert(pair); // insert a map(pair) a.erase(pair); // erase pair a.erase(iterator); // erase the iterator a.operator[](k); // return the value of key k O(log_n) a.lower_bound(x); // return iterator which is minimum >= x, else map.end() a.upper_bound(x); // return iterator which is minimun > x, else map.end() 1.8 unordered_xxx unordered_set , unordered_map , unordered_multiset , unordered_multimap 基于哈希表实现 和上面类似，增删改查均为 \\(O(1)\\)​ ，但不支持 lower_bound()/upper_bound() 函数以及迭代器的自增自减。 1.9 bitset 压位 bitset 可以相对于 bool 数组节省 8 倍的空间。 定义 bitset&lt;size> s; 支持所有位运算操作 方法 s.operator[](); s.count(); // return how many 1 in bitset s.any(); // return if it has a 1 as least s.none(); // return if it is all 0 s.set(); // set all bits to 1 s.set(k, v); // set bit[k] to v s.reset(); // set all bits to 0 s.flip(); // equals to ~ s.flip(k); // flip bit[k]","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"STL","slug":"STL","permalink":"https://www.leolang.top/tags/STL/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"}]},{"title":"AcWing 数据结构（七）","slug":"数据结构（七）哈希表","date":"2021-07-24T16:00:00.000Z","updated":"2021-08-25T11:25:08.000Z","comments":true,"path":"2021/07/25/数据结构（七）哈希表/","link":"","permalink":"https://www.leolang.top/2021/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%83%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"前言 本文将介绍有关哈希表的相关内容，并介绍有关字符串哈希方法的相关内容。将给出哈希表两种解决哈希冲突的存储方式的模板，以及字符串哈希方法的模板。","text":"前言 本文将介绍有关哈希表的相关内容，并介绍有关字符串哈希方法的相关内容。将给出哈希表两种解决哈希冲突的存储方式的模板，以及字符串哈希方法的模板。 数据结构（七）哈希表 一、哈希表的作用 哈希表是将值域范围比较大的一组数据映射到 \\(0\\sim N\\) 上 哈希函数：\\(h(x)\\in[0,N]\\)​​ ，哈希函数一般取 \\(x\\mod N\\)​， \\(N\\) 一般取成质数且贴近 \\(2^k\\)​ 所以一般要先找到距离所开数组最大范围的最近的一个质数，将 \\(N\\) 设置成那个数 然而哈希函数可能会产生冲突，解决散列冲突的方式就是以下两种 二、哈希表的存储结构 注：以下例子假定 \\(N=1e5\\) 1.开放寻址法 开放寻址法一般要开二到三倍的数据范围大小的数组，一般需要开 \\(2N\\sim3N\\)​​ 大的数组，在如果出现散列冲突，就继续向下寻找，直至寻找到一个空位将元素放入，就叫开放寻址法。 const int N = 200003, null = 0x3f3f3f3f; int h[N]; memset(h, 0x3f, sizeof(h)); 线性探查法：若某元素存在，则返回该元素的位置，若不存在，则返回他应该存储的一个空位置。 int find(int x) &#123; int k = (x % N + N) % N; while (h[k] != null &amp;&amp; h[k] != x) &#123; k++; if (k == N) k = 0; &#125; return k; &#125; 插入 void insert(int x) &#123; int k = find(x); h[k] = x; &#125; 查询 bool find(int x) &#123; int k = find(x); if (h[k] != null) return true; else return false; &#125; 2.拉链法 当哈希函数 \\(h(x)\\) 的值相同时，假定对于每一个 \\(hash\\) 值 \\(h(x)\\)​ ，都有一组值 \\(x_1,x_2,\\cdots,x_m\\) 的哈希值是 \\(h(x)\\) 。那么就对这一系列值形成一个单链表，就叫拉链法。 const int N = 100003; // 距离 1e5 最近的质数是 100003 int h[N]; // 拉链表的槽 int e[N], ne[N], idx; // 单链表 memset(h, -1, sizeof(h)); 插入 void insert(int x) &#123; int k = (x % N + N) % N; // 为了确保余数为正数 e[idx] = x; ne[idx] = h[k]; h[k] = idx++; // 头插法插入单链表 &#125; 查询 bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) &#123; if (e[i] == x) return true; &#125; return false; &#125; 三、字符串哈希方式 字符串前缀哈希法： 定义 \\(\\{h_n\\}\\) 为字符串 \\(str\\) 的前缀哈希值，其中 \\(h_i\\) 为前 \\(i\\) 位的哈希值。 那么该如何定义某一前缀字符串的哈希值？ ​ 假定字符串为 \\(s_1s_2\\cdots s_n\\) ，那么字符串的 \\(h_i\\) 对应的前缀为 \\(s_1s_2\\cdots s_i\\) ，定义字符串的数值为 \\(val\\) ，我们把字符串转换成一个 \\(p\\) 进制的数。那么，字符串 \\(s_1s_2\\cdots s_i\\) 对应的值为 \\(val=s_1\\times p^{i-1}+s_2\\times p^{i-2}+\\cdots+s_i\\times p^0\\) ，定义哈希函数为 \\(h(x)=x\\mod Q\\) ，则最后得到的 \\(h(val)\\) 就是 \\(h_i\\) 的值。显然，\\(h(x)\\in (0,Q)\\)​ 这里需要注意两点。首先，对于一个字符我们不能将其换算为 \\(0\\)​​ 。假如将 \\(A\\)​​ 映射成 \\(0\\)​​ ，那么 \\(AA\\)​​ 也就是 \\(0\\)​​ ，将会无法区分，这里我们采用其 ASCII 码去进行换算；第二，这里我们假设我们的哈希方法是不存在冲突的。一般经验值为 \\(p=131/13331\\)​​ 、 \\(Q=2^{64}\\)​​ 。 以上就是定义的字符串哈希方式。我们通过这样的定义方式就可以得到所有子串的哈希值。假定给出区间 \\([l,r]\\) ，那么根据前缀和的思想，我们需要的是 \\(h_r,h_{l-1}\\) 这两个数。对于字符串 \\(str\\) 内部而言，由于我们定义了要将字符串转化为一个 \\(k\\) 进制的数，则从 \\(s_1\\) 到 \\(s_n\\) 为字符串的高位到低位。那么，我们再分别单独看两个子串，这两个前缀子串当中，\\(s_1\\) 是高位，而 \\(s_{l-1},s_r\\) 是低位。但两个子串相对而言，虽然他们的高位相同，但是，其实在数值上，以 \\(s_1\\) 为例，这里我们用前缀字符串哈希值来代表某一个前缀子串，那么 \\(h_r\\) 的 \\(s_1\\) 对应的值应当是 \\(s_1\\times p^{r-1}\\) ，而相对应的 \\(h_{l-1}\\) 中是 \\(s_1\\times p^{l-2}\\) 。可以看到，其实两个字符串的哈希值差了 \\(p^{r-1-(l-2)}=p^{r-l+1}\\) 倍的。那么，如果想要进行 ”同等“ 的运算，我们就应当将小的哈希值字符串按位扩大相差的倍数才能进行运算。所以，我们就得到了计算区间 \\([l,r]\\) 的子串哈希值的公式为：\\(h_{l,r}=h_r-h_l\\times p^{r-l+1}(l\\leq r)\\) 。这里需要说明的一点是，我们定义的哈希函数是 \\(h(x)=x\\mod Q\\) ，这里并不是不进行取模运算了，我们用 unsigned long long 存储所有的哈希值，unsigned long long 的阈值是 \\(2^{64}\\) ，所以如果溢出了范围，也就相当于是对 \\(2^{64}\\)​ 进行取模运算了。 仿照我们上面扩大倍数的思想，我们得到哈希值的方式也很简单。相邻两位上相差的倍数就是 \\(p\\) ，那么就有如下公式成立：\\(h_i=h_{i-1}\\times p+s_i\\) 。 typedef unsigned long long ULL; const int P = 131; char str[N]; ULL h[N], p[N]; // h stores hash values, p stores the pow of P 预处理 p[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125; 获取某一区间内子串的哈希值 ULL get(int l, int r) &#123; return h[r] - h[l - 1] * p[r - l + 1]; &#125; 判断两个子串是否完全相同：如果两个子串的哈希值完全相同，那么就判定两者完全相同。因为对于任意的每一个不同的字符串而言，其哈希值是唯一的。 bool judge(int l1, int r1, int l2, int r2) &#123; if (get(l1, r1) == get(l2, r2)) return true; else return false; &#125; 习题 AcWing 840 AcWing 840 C++ 拉链法 #include &lt;iostream> #include &lt;cstring> using namespace std; const int N = 100003; int h[N]; int e[N], ne[N], idx; void insert(int x) &#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx++; &#125; bool find(int x) &#123; int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) &#123; if (e[i] == x) return true; &#125; return false; &#125; int main() &#123; int n; memset(h, -1, sizeof(h)); scanf(\"%d\", &amp;n); while (n--) &#123; char op[2]; int x; scanf(\"%s%d\", op, &amp;x); if (op[0] == 'I') insert(x); else &#123; if (find(x)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0; &#125; 开放寻址法 #include &lt;iostream> #include &lt;cstring> using namespace std; const int N = 200003, inf = 0x3f3f3f3f; int h[N]; int find(int x) &#123; int k = (x % N + N) % N; while (h[k] != inf &amp;&amp; h[k] != x) &#123; k++; if (k == N) k = 0; &#125; return k; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); memset(h, 0x3f, sizeof(h)); while (n--) &#123; char op[2]; int x; scanf(\"%s%d\", op, &amp;x); if (op[0] == 'I') h[find(x)] = x; else &#123; if (h[find(x)] != inf) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0; &#125; Python 拉链法 def insert(x): global idx k = (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1 def find(x): k = (x % N + N) % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return False if __name__ == '__main__': n = int(input()) N = 100003 h = [-1] * N e = [0] * N ne = [0] * N idx = 0 for _ in range(n): op, x = input().split() x = int(x) if op == 'I': insert(x) else: if find(x): print(\"Yes\") else: print(\"No\") 开放寻址法 def find(x): k = (x % N + N) % N while h[k] != float('inf') and h[k] != x: k += 1 if k == N: k = 0 return k if __name__ == '__main__': N = 200003 h = [float('inf')] * N n = int(input()) for _ in range(n): op, x = input().split() x = int(x) if op == 'I': h[find(x)] = x else: if h[find(x)] != float('inf'): print(\"Yes\") else: print(\"No\") AcWing 841 AcWing 841 #include &lt;iostream> using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; ULL h[N], p[N]; char str[N]; inline ULL gethash(int l, int r) &#123; return h[r] - h[l - 1] * p[r - l + 1]; &#125; int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s\", str + 1); p[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; &#125; while (m--) &#123; int l1, r1, l2, r2; scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2); if (gethash(l1, r1) == gethash(l2, r2)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0; &#125; def gethash(l, r): return (h[r] - h[l - 1] * p[r - l + 1]) % (1 &lt;&lt; 64) if __name__ == '__main__': n, m = map(int, input().split()) P = 131 s = ' ' + input() h = [0] * len(s) p = [0] * len(s) p[0] = 1 for i in range(1, n + 1): h[i] = (h[i - 1] * P + ord(s[i])) % (1 &lt;&lt; 64) p[i] = (p[i - 1] * P) % (1 &lt;&lt; 64) for _ in range(m): l1, r1, l2, r2 = map(int, input().split()) if gethash(l1, r1) == gethash(l2, r2): print(\"Yes\") else: print(\"No\")","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"},{"name":"Hash","slug":"Hash","permalink":"https://www.leolang.top/tags/Hash/"}]},{"title":"AcWing 数据结构（六）","slug":"数据结构（六） 堆","date":"2021-07-23T16:00:00.000Z","updated":"2021-08-25T11:17:16.000Z","comments":true,"path":"2021/07/24/数据结构（六） 堆/","link":"","permalink":"https://www.leolang.top/2021/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89%20%E5%A0%86/","excerpt":"前言 本文将介绍堆的相关内容。将介绍堆的存储结构、相关操作，并给出实现模板。","text":"前言 本文将介绍堆的相关内容。将介绍堆的存储结构、相关操作，并给出实现模板。 数据结构（六） 堆 一、什么是堆 堆是一棵完全二叉树，对于每个结点及其左右儿子，都一定满足一个关系成立。以小根堆为例，对于结点 \\(v_i\\)​ ，恒有 \\(v_i&lt;v_{2i},v_i&lt;v_{2i+1}\\) 成立。那么显然，堆顶（树的根结点）就是当前集合的最值。 堆支持的操作如下（以小根堆为例）： 插入一个数 求集合当中的最小值 删除最小值 删除任意一个元素 修改任意一个元素 二、堆的存储 堆的存储结构其实就是完全二叉树的数组存储，下标为 \\(1\\) 的结点就是根结点，对于结点下标为 \\(x\\) 的结点，其左儿子为 \\(2x\\) ，右儿子为 \\(2x+1\\) 。 三、堆的操作 堆的基操就是向上浮动和向下浮动，上面提到的这些操作都可以用这两个基操实现。 以下均以小根堆为例，大根堆亦然。 \\(down(x)\\)​​ \\(O(\\log n)\\)​ 设当前被操作节点下标为 \\(x\\)​ ，则其两个子节点下标分别为为 \\(2x,2x+1\\)​ 。如果不满足关系 \\(v_x&lt;v_{2x}\\) 且 \\(v_x&lt;v_{2x+1}\\)​​ ，这个父节点就需要向下沉。在堆中浮动无非就是交换结点的值，那么这里需要涉及到的问题就是与谁去交换，需要注意交换完毕后必须保证当前这个位置的堆性质不被破坏。为保证堆的性质，我们取三个值中最小的重新作为父节点，即将父节点与两子节点中相对较小的数进行交换。一次操作完成。 对于每个较大的结点都向下沉到一个恰当的位置就完成了一次 down 操作 \\(up(x)\\) \\(O(\\log n)\\) 上浮操作较为简单，只需将当前节点 \\(x\\)​ 与其父节点 \\(\\displaystyle\\lfloor \\frac{x}{2}\\rfloor\\)​ 进行比较，如果 \\(\\displaystyle v_x&lt;v_{\\lfloor \\frac{x}{2}\\rfloor}\\) ，就将其与其父节点进行交换。一次操作完成。 对于每个较小的结点都向上沉到一个恰当的位置就完成了一次 down 操作 那么现在就可以去实现上面一道的五个操作了： 插入一个数 向堆尾插入一个数，对这个数使用 \\(up\\) 操作，即 \\(up(size)\\)​ 。 求集合当中的最小值 堆顶即为最小值。 删除最小值 由于堆要操作堆顶相当困难，相对应的去操作堆尾很简单，于是我们就可以将堆尾的元素放到堆顶（实质上就是交换了堆顶和堆尾，而操作上赋值操作更为直接），之后减小堆的大小，也就删除了原来堆顶而保持了其他元素不变。最后在重新调整堆，对堆顶元素使用 \\(down\\) ，即 \\(down(1)\\) 。 删除任意一个元素 假定删除下标为 \\(k\\)​ 的元素，套用上面的思想，我们还是把直接堆尾的值拿到 \\(k\\) 的位置上去，之后减小堆的大小，就完成了删除操作。之后需要重新调整堆。这里需要进行判断，两种操作只可能进行一个。那么这里一个比较直接的做法就是两种操作都执行一下，毕竟只可能执行一种操作，都执行一次并没有什么影响，即 \\(up(k),down(k)\\) 修改任意一个元素 思想和上面完全相同，首先修改这个元素，之后再对这个位置执行两种操作。原因上面已经解释过了。 模板 int h[N]; //heap int cnt = n; 建堆 \\(O(n)\\) for (int i = n / 2; i; i--) down(i); 插入一个数 int x; // recieve the value to insert h[++cnt] = x; up(cnt); down void down(int u) &#123; int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; swap(h[u], h[t]); down(t); &#125; &#125; up void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] > h[u]) &#123; swap(h[u / 2], h[u]); u /= 2; &#125; &#125; 删除最小值 h[1] = h[cnt]; cnt--; down(1); 4、5操作需要额外开辟两个数组 \\(ph\\) 、\\(hp\\) ，分别记录第 \\(k\\) 个插入的数在堆中的下标、堆中第 \\(m\\)​ 个点是​第几个插入的点。两个数组构成双射。 那么交换就需要重写了： 首先交换两个节点在堆中的下标，之后由于存储中指向关系改变，所以必须改变 \\(hp\\) 中存储的次序，将两个元素的进入次序交换。最后交换堆中的这两个值。 void heap_swap(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); &#125; 相应的那些操作当中的交换也要改成这个，并且和堆顶的赋值也要搞成这个交换，因为那个赋值的本质其实就是交换。 插入一个数 int x; int m; // store the order of insert cnt++; m++; ph[m] = cnt, hp[cnt] = m; h[cnt] = x; up(cnt); 删除第 \\(k\\) 个插入的数 int k; k = ph[k]; // to find who has the k.st order heap_swap(k, cnt); size--; down(k), up(k); 修改第 \\(k\\) 个插入的数 int k; int x; k = ph[k]; h[k] = x; down(k), up(k); 习题 AcWing 838 AcWing 838 #include &lt;iostream> using namespace std; const int N = 100010; int h[N]; int cnt; void down(int u) &#123; int t = u; if (2 * u &lt;= cnt &amp;&amp; h[2 * u] &lt; h[t]) t = 2 * u; if (2 * u + 1 &lt;= cnt &amp;&amp; h[2 * u + 1] &lt; h[t]) t = 2 * u + 1; if (u != t) &#123; swap(h[t], h[u]); down(t); &#125; &#125; int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); cnt = n; for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); for (int i = n / 2; i; i--) down(i); for (int i = 1; i &lt;= m; i++) &#123; printf(\"%d \", h[1]); h[1] = h[cnt]; cnt--; down(1); &#125; return 0; &#125; def down(u): global cnt t = u if 2 * u &lt;= cnt and heap[2 * u] &lt; heap[t]: t = 2 * u if 2 * u + 1 &lt;= cnt and heap[2 * u + 1] &lt; heap[t]: t = 2 * u + 1 if u != t: heap[t], heap[u] = heap[u], heap[t] down(t) if __name__ == '__main__': n, m = map(int, input().split()) heap = [0] + list(map(int, input().split())) cnt = n for i in range(n // 2, 0, -1): down(i) res = [] for i in range(1, m + 1): res.append(heap[1]) heap[1] = heap[cnt] cnt -= 1 down(1) print(' '.join(map(str, res))) AcWing 839 AcWing 839 #include &lt;iostream> #include &lt;string> using namespace std; const int N = 100010; int h[N]; int hp[N], ph[N]; int cnt, m; void heap_swap(int a, int b) &#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); &#125; void down(int u) &#123; int t = u; if (2 * u &lt;= cnt &amp;&amp; h[2 * u] &lt; h[t]) t = 2 * u; if (2 * u + 1 &lt;= cnt &amp;&amp; h[2 * u + 1] &lt; h[t]) t = 2 * u + 1; if (u != t) &#123; heap_swap(u, t); down(t); &#125; &#125; void up(int u) &#123; while (u / 2 &amp;&amp; h[u / 2] > h[u]) &#123; heap_swap(u / 2, u); u /= 2; &#125; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; string op; int x, k; cin >> op; if (op == \"I\") &#123; scanf(\"%d\", &amp;x); cnt++; m++; h[cnt] = x; ph[m] = cnt; hp[cnt] = m; up(cnt); &#125; else if (op == \"PM\") printf(\"%d\\n\", h[1]); else if (op == \"DM\") &#123; heap_swap(1, cnt); cnt--; down(1); &#125; else if (op == \"D\") &#123; scanf(\"%d\", &amp;k); k = ph[k]; heap_swap(k, cnt); cnt--; down(k), up(k); &#125; else &#123; scanf(\"%d%d\", &amp;k, &amp;x); k = ph[k]; h[k] = x; down(k), up(k); &#125; &#125; return 0; &#125; def heap_swap(a, b): ph[hp[a]], ph[hp[b]] = ph[hp[b]], ph[hp[a]] hp[a], hp[b] = hp[b], hp[a] h[a], h[b] = h[b], h[a] def down(u): global cnt t = u if 2 * u &lt;= cnt and h[2 * u] &lt; h[t]: t = 2 * u if 2 * u + 1 &lt;= cnt and h[2 * u + 1] &lt; h[t]: t = 2 * u + 1 if u != t: heap_swap(u, t) down(t) def up(u): while u // 2 and h[u // 2] > h[u]: heap_swap(u // 2, u) u //= 2 if __name__ == '__main__': n = int(input()) h = [0] * (n + 1) hp = [0] * (n + 1) ph = [0] * (n + 1) cnt, m = 0, 0 for _ in range(n): op = input().split() if op[0] == 'I': x = int(op[-1]) m += 1; cnt += 1 h[cnt] = x ph[m] = cnt hp[cnt] = m up(cnt) elif op[0] == 'PM': print(h[1]) elif op[0] == 'DM': heap_swap(1, cnt) cnt -= 1 down(1) elif op[0] == 'D': k = int(op[-1]) k = ph[k] heap_swap(k, cnt) cnt -= 1 down(k); up(k) elif op[0] == 'C': k, x = map(int, op[1:]) k = ph[k] h[k] = x down(k); up(k)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"},{"name":"Heap","slug":"Heap","permalink":"https://www.leolang.top/tags/Heap/"}]},{"title":"AcWing 数据结构（五）","slug":"数据结构（五） 并查集","date":"2021-07-22T16:00:00.000Z","updated":"2021-08-25T11:14:34.000Z","comments":true,"path":"2021/07/23/数据结构（五） 并查集/","link":"","permalink":"https://www.leolang.top/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89%20%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"前言 本文将介绍有关并查集的相关内容。将介绍并查集的数组实现及相关操作，并介绍多维护信息的并查集的变体。习题中会出现有关带权并查集的相关内容。","text":"前言 本文将介绍有关并查集的相关内容。将介绍并查集的数组实现及相关操作，并介绍多维护信息的并查集的变体。习题中会出现有关带权并查集的相关内容。 数据结构（五） 并查集 一、什么是并查集 并查集支持的操作： 将两个集合合并 询问两个元素是否在一个集合当中 二、并查集的基本原理 每个集合用一棵树表示，树根的编号就是集合的编号。每个节点都存储其父节点。 如何判断树根？ 其父节点为其自身，即 \\(p_x=x\\) 如何求 \\(x\\) 的编号？ 不断向上寻找其父节点，直到寻找到其根结点，根结点的性质如上所述 如何合并两个集合？ 将一个集合的树作为另一个集合的子树直接给予另一个集合。设两棵树分别是 \\(x\\) 、 \\(y\\) ，那么操作就是 \\(p_x=y\\)​ 三、并查集的优化 路径压缩：一旦第一次从节点 \\(k\\) 找到了其根结点 \\(root(k)\\) ，那么就将路径上的所有节点的父节点全都指向其根结点 \\(root(k)\\)​ ，这样的话后续再查找一步就能够找到其根结点 通过路径压缩，并查集的时间复杂度就可以降到近似 \\(O(1)\\) 模板 int p[N]; // store the father of each node for (int i = 1; i &lt;= n; i++) p[i] = i; // set each node a leaf node find() 返回 \\(x\\) 的集合编号（即根结点），同时路径压缩优化 int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; 合并：将 \\(a\\) 树插到 \\(b\\) 树上去以合并两集合，\\([v]_b\\leftarrow [v]_a\\) int a, b; // recieve the merge opertation targets p[find(a)] = find(b); 判断是否属于同一个集合 int a, b; // recieve the merge opertation targets find(a) == find(b) ? 四、维护额外信息 返回每个集合中节点的数量 多增加一个数组 \\(size\\) 以记录节点数量 int cnt[N]; for (int i = 1; i &lt;= n; i++) cnt[i] = 1; 我们只保证根结点的 \\(size\\)​ 值是有意义的，则上述的合并操作需要有所更改，如果两节点不在同一个集合就进行 \\(size\\) 数组值的更新： p[find(a)] = find(b); if (find(a) != find(b)) cnt[find(b)] += cnt[find(a)]; 那么我们就可以统计某一节点所在连通分量的节点个数了 int a; //which node to find cnt[find(a)]; 习题 AcWing 836 AcWing 836 #include &lt;iostream> using namespace std; const int N = 100010; int p[N]; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i] = i; while (m--) &#123; char op[2]; int a, b; scanf(\"%s%d%d\", op, &amp;a, &amp;b); if (op[0] == 'M') &#123; p[find(a)] = find(b); &#125; else &#123; if (find(a) == find(b)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0; &#125; def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] if __name__ == '__main__': n, m = map(int, input().split()) p = [i for i in range(n + 1)] for _ in range(m): op = input().split() a, b = map(int, op[1:]) if op[0] == 'M': p[find(a)] = find(b) else: if find(a) == find(b): print(\"Yes\") else: print(\"No\") AcWing 837 AcWing 837 #include &lt;iostream> using namespace std; const int N = 100010; int p[N], tot[N]; int find(int x) &#123; if (p[x] != x) p[x] = find(p[x]); return p[x]; &#125; int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i] = i, tot[i] = 1; while (m--) &#123; char op[3]; int a, b; scanf(\"%s\", op); if (op[0] == 'C') &#123; scanf(\"%d%d\", &amp;a, &amp;b); a = find(a), b = find(b); p[a] = b; if (a != b) tot[b] += tot[a]; &#125; else if (op[1] == '1') &#123; scanf(\"%d%d\", &amp;a, &amp;b); if (find(a) == find(b)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; else &#123; scanf(\"%d\", &amp;a); printf(\"%d\\n\", tot[find(a)]); &#125; &#125; return 0; &#125; def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] if __name__ == '__main__': n, m = map(int, input().split()) p = [i for i in range(n + 1)] cnt = [1] * (n + 1) for _ in range(m): op = input().split() if op[0] == 'C': a, b = map(int, op[1:]) a, b = find(a), find(b) p[a] = b if a != b: cnt[b] += cnt[a] elif op[0] == 'Q1': a, b = map(int, op[1:]) if find(a) == find(b): print(\"Yes\") else: print(\"No\") else: a = int(op[-1]) print(cnt[find(a)]) AcWing 240 AcWing 240 本题的实质其实是一个带权并查集。所有能产生关系的元素最后都应该属于一个大集合，区别元素种类的方式就是节点到根结点的距离。对于这道题而言，我们把他提到的产生的关系（不论是谁吃谁还是谁和谁是同类）都扔进一个集合中。原因是只要两个元素之间产生关系，那么扔进集合当中必定可以推断出他们之间的关系。有了这个基础之后，我们应当怎样推断出并查集树中两个节点直接的关系呢？我们需要定义节点间的距离，这也就是带权并查集的核心所在。我们定义如果存在食物链 \\(A\\to B\\)​ ，那么两节点间距离为 \\(1\\)​ ，每个节点到其自身的距离为 \\(0\\)​ 。那么对于两个任意节点 \\(A,B\\)​ 我们不难发现其关系如下：（假设两点之间距离小于等于 \\(3\\)​） \\[ d(A,B):= \\begin{cases} 0&amp;A=B\\\\ 1&amp;B\\to A\\\\ 2&amp;A\\to B \\end{cases} \\] 其中 \\(d(A,B)\\)​​ 代表了两点间的距离。 那么，我们就很容易能通过距离知道任意节点 \\(A\\)​ 和根结点 \\(r\\)​ 的关系： \\[ d(A)-d(r)=d(A)\\equiv \\begin{cases} 0&amp;A=r\\\\ 1&amp;r\\to A\\\\ 2&amp;A\\to r \\end{cases}\\ \\ (\\text{mod } 3) \\] 定义 \\(d(x)\\) 为节点 \\(x\\) 进行路径压缩后到根结点的距离。 推广到任意节点，将 \\(r\\) 替换成任意节点 \\(B\\)​​ ，我们就能得到并查集树中两个节点之间的关系： \\[ d(A)-d(B)\\equiv \\begin{cases} 0&amp;A=B\\\\ 1&amp;A\\to B\\\\ 2&amp;A\\leftarrow B \\end{cases}\\ \\ (\\text{mod } 3) \\] 思路清楚了，接下来来分析代码如何实现。我们定义数组 \\(\\{d_n\\}\\) 为每个节点到其父节点的距离。首先将两种一定为假话的情况抛去。之后来看剩下的情况。 我们首先应该重定义 find() 函数，因为我们需要在 find() 结束后同时去维护过某一个节点到其根结点的距离，也就是进行路径压缩后到其父节点的距离。由于我们之前实现的 find() 函数使用递归实现了路径压缩的原理，所以我们这里维护一轮递归中的思路就是每次都要将当前所选中的结点向上提到其父节点的父亲上去，能够和其父节点在同一层级上。所以我们每轮递归中都需要找到其父亲的父节点，也就是 find(p[x]) ，之后，由于路径压缩，这时当前节点的父节点已经改变。那么同时的我们就需要维护这个结点到其父节点的距离 \\(d_x\\) 了。显然，距离需要增加其父节点到父节点的父节点之间的距离，即 \\(d_{p_x}\\)​ 。最后，重新绑定父节点为原结点的父节点的再上一层父节点。一轮递归完成。当所有递归都退出后，正好我们完成了路径压缩的全过程，而此时，我们的 \\(d_x\\) 存储的也恰好就是当前节点到根结点的距离了。 所以我们重定义了 find() 函数，我们就可以先使用该函数来判断输入进来的两个节点是否属于同一个集合当中。此时也同时完成了对两个节点的路径压缩。我们也知晓了两个节点到根结点的距离，我们也就能够通过与根结点之间的关系推断两个节点之间之间的关系了。 第一种情况，两个节点当前属于同一个集合中，证明这两个节点之前必定能产生某种关系。那么此时这句话就可能是假的。那么就套用对于并查集树中任意两节点关系的定义，我们不难得到两个条件语句中的条件。当然假话应当是怎么样的也显而易见。第一种情况结束。 第二种情况，如果两个节点当前不属于同一个集合中，证明两个节点之前没有任何关系，那这句话必定是真话。此时我们要做的就是更新两个节点之间的关系和距离数组的值。显然，我们首先需要将两个集合合并。这里不妨设合并的方式是将 \\(x\\)​​ 作为 \\(y\\)​​ 的子树。这时就需要从节点 \\(p_x\\)​​ 向节点 \\(p_y\\)​​ 增加一条边，\\(p_y\\)​​​ 作为新的根结点，并赋予距离值使得输入的关系成立。 设新增加的边的权值为 \\(i\\)​​ 。如果输入两个节点是同类，即 \\(y=x\\)​​，那么有 \\(d(x)+i-d(y)\\equiv0(\\text{mod }3)\\)​​ 成立，不妨设 \\(d(x)+i-d(y)=0\\)​​ ，解得 \\(d(p_x)=i=d(y)-d(x)\\)​​ ；如果输入的关系是 \\(y\\to x\\)​​ ，那么有 \\(d(x)+i-d(y)\\equiv1(\\text{mod }3)\\)​ 成立，不妨设 \\(d(x)+i-d(y)=1\\) ，解得 \\(d(p_x)=i=1+d(y)-d(x)\\) 。需要说明的是，此处的 \\(d(k)\\) 仍表示节点 \\(k\\)​ 到其父节点的距离。 本题结束。​ #include &lt;iostream> using namespace std; const int N = 50010; int p[N], d[N]; int res; int find(int x) &#123; if (p[x] != x) &#123; int pa = find(p[x]); d[x] += d[p[x]]; p[x] = pa; &#125; return p[x]; &#125; int main() &#123; int n, k; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) p[i] = i; int att, x, y; while (k--) &#123; scanf(\"%d%d%d\", &amp;att, &amp;x, &amp;y); if (x > n || y > n) res++; else if (att == 2 &amp;&amp; x == y) res++; else &#123; int px = find(x), py = find(y); if (px == py) &#123; if (att == 1 &amp;&amp; (d[x] - d[y]) % 3) res++; if (att == 2 &amp;&amp; (d[x] - d[y] - 1) % 3) res++; &#125; else &#123; p[px] = py; if (att == 1) d[px] = d[y] - d[x]; if (att == 2) d[px] = 1 + d[y] - d[x]; &#125; &#125; &#125; printf(\"%d\", res); return 0; &#125; def find(x): if p[x] != x: pa = find(p[x]) d[x] += d[p[x]] p[x] = pa return p[x] if __name__ == '__main__': n, k = map(int, input().split()) p = [i for i in range(n + 1)] d = [0] * (n + 1) res = 0 for _ in range(k): att, x, y = map(int, input().split()) if x > n or y > n: res += 1 elif att == 2 and x == y: res += 1 else: px = find(x); py = find(y) if px == py: if att == 1 and (d[x] - d[y]) % 3: res += 1 if att == 2 and (d[x] - d[y] - 1) % 3: res += 1 else: p[px] = py if att == 1: d[px] = d[y] - d[x] if att == 2: d[px] = 1 + d[y] - d[x] print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"},{"name":"Union Set","slug":"Union-Set","permalink":"https://www.leolang.top/tags/Union-Set/"}]},{"title":"AcWing 数据结构（四）","slug":"数据结构（四）Trie 树","date":"2021-07-22T16:00:00.000Z","updated":"2021-08-25T11:11:48.000Z","comments":true,"path":"2021/07/23/数据结构（四）Trie 树/","link":"","permalink":"https://www.leolang.top/2021/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89Trie%20%E6%A0%91/","excerpt":"前言 本文将介绍有关 Trie 树的相关内容。","text":"前言 本文将介绍有关 Trie 树的相关内容。 数据结构（四）Trie 树 Trie 树是用来高效存储和查找字符串集合的数据结构。 创建 Trie 树的方法： 设立根结点 遍历每个单词，如果出现树中没有的字母的话就创建这个字母，每次都从根结点起开始遍历。 对每个单词结尾创建一个标记，表示这里是一个单词的结尾。 模板 int son[N][26]; // 存储每个节点的儿子，最大维度是26个字母就是26，维度可变，等于共有多少种字符可能 int cnt[N]; // 存储以当前节点为结尾的单词有多少个 int idx; //存储当前节点是谁（编号） 下标为 \\(0\\)​ 的点，既是根节点，又是空节点 插入 void insert(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++; &#125; 思想： 遍历该字符串，首先转化每个字符成为相对应的下标，范围为 \\(0\\sim25\\)​ 。如果这里没有这个字符，就为此字符新创立一个节点。之后游标向当前这个节点移动使得后续能够继续刚才的操作。循环结束后，最后，通过 cnt[] 数组的自增，标记这里是一个单词的结尾。该单词插入完毕。 查询：查询该字符串出现了多少次 int query(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p]; &#125; 思想： 同插入操作，遍历字符串，如果发现某一字符没有，这个字符在 Trie 树中不存在，那么证明这个单词也就不存在。如果遍历到结束的话，相应的 \\(p\\) 也就移动到了单词最末尾的那个节点，由于每个单词的结尾都是叶节点，编号是唯一的，那么相应的也就可以通过查询记录数组 cnt[] 去找到以当前编号为结尾的单词（当然也是唯一的）出现了多少次了。 习题 AcWing 835 AcWing 835 #include &lt;iostream> #include &lt;string> using namespace std; const int N = 100010; int son[N][26], cnt[N]; int idx; char str[N]; void insert(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++; &#125; int query(char str[]) &#123; int p = 0; for (int i = 0; str[i]; i++) &#123; int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p]; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; char op[2]; scanf(\"%s\", op); if (op[0] == 'I') &#123; scanf(\"%s\", str); insert(str); &#125; else &#123; scanf(\"%s\", str); printf(\"%d\\n\", query(str)); &#125; &#125; return 0; &#125; def insert(s): global idx p = 0 for i in range(len(s)): u = ord(s[i]) - ord('a') if not son[p][u]: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1 def query(s): p = 0 for i in range(len(s)): u = ord(s[i]) - ord('a') if not son[p][u]: return 0 p = son[p][u] return cnt[p] if __name__ == '__main__': n = int(input()) N = int(1e5 + 10) son = [[0] * 26 for _ in range(N)] cnt = [0] * N idx = 0 for _ in range(n): op = input().split() if op[0] == 'I': insert(op[-1]) else: print(query(op[-1])) AcWing 143 AcWing 143 先想暴力做法：首先读入这一堆的数，之后进行二重循环遍历，每次都将两个数进行异或运算，最后输出一个异或结果得到的最大值。 代码实现如下： #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 100010; int a[N]; int main() &#123; int n; scanf(\"%d\", &amp;n); int res = 0; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; res = max(res, a[i] ^ a[j]); &#125; &#125; printf(\"%d\", res); return 0; &#125; 显而易见的这个 \\(O(n^2)\\)​ 复杂度的算法绝对会 TLE 。那么如何优化呢？ 这里实际上涉及到了贪心的思想。我们这样考虑，异或实质上就是一个数展开成为二进制之后的运算。我们假设当前我们选中了数 \\(a_k\\) ，其对应的二进制展开为 \\(b_1b_2\\cdots b_r\\) 。每一次我们都想找到在所有数中与我们选中的数进行异或值最大的那个数。那么我们怎么才能让最后的异或值最大呢？当然是越高位产生越多的 \\(1\\)​ ，这个值就会越大。那么好了，我们怎么才能产生更多的 \\(1\\) 呢？这里就要回到异或的定义上来，相对应二进制位不同，异或值当前位值为 \\(1\\) 。那么，我们也就希望被运算的那个数（不是 \\(k\\) ）尽可能的能够更多的有和数 \\(k\\)​ 产生反的值。这里也就是贪心的体现。思想有了，接下来就应该去优化数据结构从而能够实现这种想法了。可以看到，按照我们这个思想，实质上思维的过程就类似一个决策树的结构。那么相应的，我们这个题也就可以用 Trie 树去存储每个数的二进制展开，由于 Trie 树可以从根结点知道每一个数的信息，而且这个题中一个节点最多有两个子节点，因为二进制只有0，1两个数。所以通过 Trie 树可以很方便查询到从当前展开位的取反（0，1取反）位是否可以向下走，如果可以，那么这个位就产生最后异或的一个 \\(1\\) ，最后结果要加上 \\(1\\)​ 在这个位置上所产生的一个值。循环过二进制展开的所有位后，我们便得到了这一个数所对应的这个最大异或值了。那么遍历过整个数组都进行一遍这个过程之后，我们便得到了答案。 #include &lt;iostream> #include &lt;algorithm> using namespace std; const int N = 100010, M = 31 * 100010; int a[N]; int son[M][2]; int idx; void insert(int x) &#123; int p = 0; for (int i = 30; i >= 0; i--) &#123; int b = x >> i &amp; 1; if (!son[p][b]) son[p][b] = ++idx; p = son[p][b]; &#125; &#125; int doxor(int x) &#123; int p = 0; int res = 0; for (int i = 30; i >= 0; i--) &#123; int b = x >> i &amp; 1; if (son[p][!b]) &#123; p = son[p][!b]; res += 1 &lt;&lt; i; &#125; else p = son[p][b]; &#125; return res; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;a[i]); insert(a[i]); &#125; int res = 0; for (int i = 0; i &lt; n; i++) res = max(res, doxor(a[i])); printf(\"%d\", res); return 0; &#125; def insert(x): global idx p = 0 for i in range(30, -1, -1): b = x >> i &amp; 1 if not son[p][b]: idx += 1 son[p][b] = idx p = son[p][b] def doxor(x): p = 0 res = 0 for i in range(30, -1, -1): b = x >> i &amp; 1 if son[p][not b]: p = son[p][not b] res += 1 &lt;&lt; i else: p = son[p][b] return res if __name__ == '__main__': n = int(input()) nums = list(map(int, input().split())) M = 31 * n son = [[0] * 2 for _ in range(M)] idx = 0 for num in nums: insert(num) res = 0 for num in nums: res = max(res, doxor(num)) print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Trie","slug":"Trie","permalink":"https://www.leolang.top/tags/Trie/"},{"name":"Data Struture","slug":"Data-Struture","permalink":"https://www.leolang.top/tags/Data-Struture/"}]},{"title":"AcWing 数据结构（三）","slug":"数据结构（三）KMP","date":"2021-07-21T16:00:00.000Z","updated":"2021-08-25T11:10:02.000Z","comments":true,"path":"2021/07/22/数据结构（三）KMP/","link":"","permalink":"https://www.leolang.top/2021/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89KMP/","excerpt":"前言 本文将介绍 KMP 算法的相关内容，并给出算法模板","text":"前言 本文将介绍 KMP 算法的相关内容，并给出算法模板 数据结构（三）KMP 记原串为 \\(S\\) ，模式串为 \\(P\\) ，默认算法的下标从 \\(1\\) 开始 一、暴力算法 朴素的字符串匹配算法就是每次都从 \\(S_i\\) 起，不断地与模式串比较，若匹配失败则 \\(i=i+1\\) ，继续重新从 \\(S_{i+1}\\) 开始，再次和 \\(P_1\\) 匹配。这样做无疑是有许许多多的地方是无用的比较。 二、如何优化 我们期待的是能够下一次不会再从头开始匹配，这样的话就需要模式串向后移动之后和原来的那个位置上的模式串子串是等效的。那么移动多少呢？可以看到，这个移动的大小其实就只是和模式串有关系的。举个例子，假定模式串子串 \\(P_1P_2\\cdots P_m=P_iP_{i+1}\\cdots P_k\\) ，其实对于原串 \\(S\\) 这两段都是匹配的，那么其实模式串怎么移动只和模式串自己有关系。再看上面举的例子，实际上就是对于第 \\(k\\) 位来说前缀和后缀相等的一个表现 。 而 \\(next\\) 数组其实就是表征了前缀和后缀相等的大小。如果 \\(next[i]=j\\) ，就代表了 \\(P_1P_2\\cdots P_j=P_{i-j+1}\\cdots P_i\\) ，那么也就可以去移动模式串使得原来和 \\(P_{i-j+1}\\) 对齐的位置改变成和 \\(P_1\\) 对齐，即和 \\(next[i]\\) 值的位置对齐（这里的字母并不是 KMP 当中的下标或指针的字母，只是说讲清思想） 三、模板 代码中一定注意 \\(i,j\\) 的起点位置 /** * Defination for KMP * int n, m; // length of String, n for P, m for S * char p[N], s[M]; // two String * int ne[N]; //array next */ // get array next for (int i = 2, j = 0; i &lt;= n; i++) &#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; &#125; // KMP matching for (int i = 1, j = 0; i &lt;= m; i++) &#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // back to the location where may match if (s[i] == p[j + 1]) j++; // if this location matches? if (j == n) &#123; // matching succeed printf(\"%d\", i - n); j = ne[j]; &#125; &#125; 习题 AcWing 831 AcWing 831 #include &lt;iostream> using namespace std; const int N = 1e5 + 10; const int M = 1e6 + 10; char p[N], s[M]; int ne[N]; int main() &#123; int n, m; scanf(\"%d\", &amp;n); scanf(\"%s\", p + 1); scanf(\"%d\", &amp;m); scanf(\"%s\", s + 1); for (int i = 2, j = 0; i &lt;= n; i++) &#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j++; ne[i] = j; &#125; for (int i = 1, j = 0; i &lt;= m; i++) &#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j++; if (j == n) &#123; printf(\"%d \", i - n); j = ne[j]; &#125; &#125; return 0; &#125; n = int(input()) p = ' ' + input() m = int(input()) s = ' ' + input() ne = [0] * (n + 1) j = 0 res = [] for i in range(2, n + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = j j = 0 for i in range(1, m + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == n: res.append(i - n) j = ne[j] print(' '.join(map(str, res)))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"KMP","slug":"KMP","permalink":"https://www.leolang.top/tags/KMP/"}]},{"title":"AcWing 数据结构（二）","slug":"数据结构（二）栈和队列","date":"2021-07-20T16:00:00.000Z","updated":"2021-08-25T11:07:26.000Z","comments":true,"path":"2021/07/21/数据结构（二）栈和队列/","link":"","permalink":"https://www.leolang.top/2021/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"前言 本文将介绍关于栈和队列的相关内容。将给出栈和队列的数组模拟实现、栈和队列的相关操作的模板。最后，将介绍单调队列、单调栈的相关内容。","text":"前言 本文将介绍关于栈和队列的相关内容。将给出栈和队列的数组模拟实现、栈和队列的相关操作的模板。最后，将介绍单调队列、单调栈的相关内容。 数据结构（二）栈和队列 一、栈 FILO 数组模拟栈 int stk[N], tt = 0; //tt store the top of stack stk[++tt] = x; //push tt--; //pop tt > 0 ? //empty? stk[tt]; //get top int stk[N], tt = -1; //tt store the top of stack stk[++tt] = x; //push tt--; //pop tt >= 0 ? //empty? stk[tt]; //get top int stk[N], tt = 0; //tt store the top empty location of stack stk[tt++] = x; //push tt--; //pop tt == 0 ? //empty? stk[tt - 1]; //get top 二、队列 FIFO 数组模拟队列 int q[N]; int hh, tt = -1; //head and tail q[++tt] = x; //push hh++; //pop hh &lt;= tt ? //empty? q[hh]; //get front q[tt]; //get tail 三、单调栈、单调队列 单调栈、单调队列的做题思路和双指针类似，都是先想一个正常的暴力做法，然后去看怎么能去掉没用的元素，这样就可以出现单调性，就能够优化这个做法。 1.单调栈 给定一个序列，求出其左边离它最近的小于它的数的位置 先想暴力做法，暴力搜索就是两重循环，第二个指针从第一指针的左一个元素起，向左移动，直至找到符合条件的元素。 这时如何优化呢？我们可以设立一个栈来存储第一个遍历指针遍历过的所有数。每次找的时候都是从栈中弹出元素，直到找到符合要求的元素即是答案。那么栈中是否是有一些元素永远不可能是答案呢？举个例子，假如 \\(a_3\\geq a_5\\) ，如果后续遍历到的元素 \\(a_i\\) 取了 \\(a_3\\) 作为答案，那么 \\(a_5\\) 就更应该是答案，所以其实对于 \\(i&gt;5\\) 的逐个元素而言， \\(a_3\\) 已经永远不可能作为后续元素的答案了，所以它在栈中也就没有存在的必要了。所以总结出的规则如下：若 \\(a_i\\geq a_j\\) ，而 \\(i&lt;j\\) 成立，则对于 \\(\\forall a_k(k&gt;j)\\) 取得答案时 \\(a_j\\) 一定更优于 \\(a_i\\) ，则后续搜索时不必要再搜索到 \\(a_i\\) ，则 \\(a_i\\) 不应该出现在搜索栈中，应该被删掉。而现在我们可以看到， \\(a_i\\geq a_j,i&lt;j\\) 其实是一个逆序关系 ，我们删掉了这样的逆序关系之后，栈中的元素其实就是单调的了，当然了在这里是单调上升的，对于 \\(\\forall i&lt;j,stk_i&lt;stk_j\\) 。（这里的 \\(stk\\) 代表栈） 那么，对于遍历到的元素 \\(a_i\\) 和待搜索栈 \\(stk\\) ，我们需要完成两个工作，找到满足题中条件的关于元素 \\(a_i\\) 的答案，同时要向栈中压入元素 \\(a_i\\) 从而能够使得后续依然能够进行查找，而且压入后应保持栈的性质成立。如果 \\(stk_{tt}\\geq a_i\\) ，那么这个元素就不是我们想要找到的元素，同时在压入 \\(a_i\\) 的时候这个元素也会破坏掉栈的性质，我们同样不希望这个元素出现，于是我们就不断弹栈，直到找到了元素 \\(stk_{tt}\\) 满足了 \\(stk_{tt}&lt;a_i\\) 的关系成立， 这个元素就是元素 \\(a_i\\) 对应的答案。如果弹空，就证明没有元素满足性质，那么答案就是 \\(-1\\) 。做完这些后，后续的元素搜索答案时一定要用到 \\(a_i\\) ，这时将其压栈，当然这个操作也不会破坏栈的单调性，因为我们之前已经进行过操作保护了栈的性质了。这样一次操作结束。 2.单调队列 滑动窗口，求滑动窗口中的最大值、最小值 窗口可以用队列来维护，因为窗口新框入的元素可以入队，而脱离窗口的元素就可以出队。暴力做法就是直接遍历队列中的元素，找到两个最值。这时如果窗口大小为 \\(k\\) ，那么复杂度就是 \\(O(nk)\\) 。可以看到复杂度很高。 这时应该如何优化呢？队列中一定是有一些元素是无用的，因为很多元素都不是答案，遍历中会有很多无用遍历。以寻找最小值的情况为例。假如队列中入队了 \\(-3\\) ，而队列中有 \\(3\\) ，因为我们要找到最小值，而且 \\(-3&lt;3\\) 永远成立，那么 \\(3\\) 存在与队列中永远不会是答案，那么它就不应该存在于这个被搜索的队列中。那么总结出的规则如下：设被搜索队列为 \\(\\{q_n\\}\\) ，规定队列按下标递增为入队顺序。若 \\(q_i\\geq q_j\\) ，而 \\(i&lt;j\\) 成立，那么对于 \\(\\forall q_k\\in\\{q_n\\}\\) ，假设想取得答案是 \\(q_i\\) ，那么 \\(q_j\\) 就一定比 \\(q_i\\) 更优，那么 \\(q_i\\) 其实就永远不会不存在于我们搜索到的答案序列中了，这时就可以在队列中删掉 \\(q_i\\) 也无妨。那么同样的，可以看到 \\(q_i\\geq q_j,i&lt;j\\) 也是一个逆序关系，删除掉了这样的关系之后，队列中的元素也就是单调的了。 那么，对于每次的滑动窗口所构建的单调队列而言，队首元素就是当前窗口内的最小值，当然了在输出的时候需要判断一下队首元素的合理性是否能让其输出，一个元素只能入队一次、出队一次，因为在这里可能队首元素已经超出了窗口的范围了。和单调栈的分析一样，当窗口滑动的时候，就向队列中入队元素 \\(a_i\\) ，如果队尾元素 \\(q_{-1}\\) （这里沿用了 python 的语法）满足关系 \\(q_{-1}\\geq a_i\\) 那么要维护单调增队列就应该删除队尾的 \\(q_{-1}\\) 。不断重复这个过程直到 \\(q_{-1}&lt;a_i\\) 为止，就可以将 \\(a_i\\) 入队，从而结束单调队列的维护。 总结 单调栈和单调队列的用法其实就是首先应该是此题能够用栈或队列暴力的去求解，暴力的求解中一定会有很多元素的搜索是浪费的，那么这些没用的元素就不应该存在于这个栈或者队列中了。假如说删除掉这些元素后有单调性的话，取最值就可以直接去取堆头进行优化了，查找元素就可以用二分进行优化了，等等一系列的和单调性挂钩的优化方式就可以去使用了。 习题 AcWing 828 AcWing 828 #include &lt;iostream> #include &lt;string> using namespace std; const int N = 100010; int stk[N], tt; int main() &#123; tt = -1; int n; scanf(\"%d\", &amp;n); while (n--) &#123; string op; int x; cin >> op;a if (op == \"push\") &#123; scanf(\"%d\", &amp;x); stk[++tt] = x; &#125; else if (op == \"pop\") tt--; else if (op == \"empty\") &#123; if (tt == -1) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; else printf(\"%d\\n\", stk[tt]); &#125; return 0; &#125; n = int(input()) stk = [0] * n tt = 0 for _ in range(n): op = input().split() if op[0] == 'push': stk[tt] = int(op[-1]) tt += 1 elif op[0] == 'pop': tt -= 1 elif op[0] == 'empty': if tt == 0: print(\"YES\") else: print(\"NO\") else: print(stk[tt - 1]) LeetCode 150 LeetCode 150 class Solution &#123; public: stack&lt;int> stk; void eval(string op) &#123; int b = stk.top(); stk.pop(); int a = stk.top(); stk.pop(); if (op == \"+\") stk.push(a + b); else if (op == \"-\") stk.push(a - b); else if (op == \"*\") stk.push(a * b); else stk.push(a / b); &#125; int evalRPN(vector&lt;string>&amp; tokens) &#123; unordered_set&lt;string> S&#123;\"+\", \"-\", \"*\", \"/\"&#125;; for (auto &amp;token: tokens) &#123; if (S.count(token)) eval(token); else stk.push(stoi(token)); &#125; return stk.top(); &#125; &#125;; class Solution: def evalRPN(self, tokens: List[str]) -> int: stk = [] ops = [\"+\", \"-\", \"*\", \"/\"] for token in tokens: if token in ops: b = stk.pop() a = stk.pop() stk.append(self.evaluate(a, b, token)) else: stk.append(int(token)) return int(stk[0]) def evaluate(self, a, b, op): if op == \"+\": return a + b elif op == \"-\": return a - b elif op == \"*\": return a * b else: return int(a / b) AcWing 3302 AcWing 3302 #include &lt;iostream> #include &lt;cctype> #include &lt;string> #include &lt;stack> #include &lt;unordered_map> using namespace std; stack&lt;int> nums; stack&lt;char> ops; void eval() &#123; int b = nums.top(); nums.pop(); int a = nums.top(); nums.pop(); int op = ops.top(); ops.pop(); int res; if (op == '+') res = a + b; else if (op == '-') res = a - b; else if (op == '*') res = a * b; else res = a / b; nums.push(res); &#125; int main() &#123; unordered_map&lt;char, int> pr&#123;&#123;'+', 1&#125;, &#123;'-', 1&#125;, &#123;'*', 2&#125;, &#123;'/', 2&#125;&#125;; string str; cin >> str; for (int i = 0; i &lt; str.size(); i++) &#123; char c = str[i]; if (isdigit(c)) &#123; int x = 0, j = i; while (j &lt; str.size() &amp;&amp; isdigit(str[j])) x = x * 10 + str[j++] - '0'; nums.push(x); i = j - 1; &#125; else if (c == '(') ops.push(c); else if (c == ')') &#123; while (ops.top() != '(') eval(); ops.pop(); &#125; else &#123; while (ops.size() &amp;&amp; ops.top() != '(' &amp;&amp; pr[ops.top()] >= pr[c]) eval(); ops.push(c); &#125; &#125; while (ops.size()) eval(); cout &lt;&lt; nums.top(); return 0; &#125; def evaluate(): b = nums.pop() a = nums.pop() op = ops.pop() res = 0 if op == '+': res = a + b elif op == '-': res = a - b elif op == '*': res = a * b else: res = int(a / b) nums.append(res) if __name__ == '__main__': s = input() nums = [] ops = [] pr = &#123;'+': 1, '-': 1, '*': 2, '/': 2&#125; i = 0 while i &lt; len(s): c = s[i] if c.isdigit(): x = 0 j = i while j &lt; len(s) and s[j].isdigit(): x = x * 10 + int(s[j]) j += 1 nums.append(x) i = j - 1 elif c == '(': ops.append(c) elif c == ')': while ops[-1] != '(': evaluate() ops.pop() else: while len(ops) and ops[-1] != '(' and pr[ops[-1]] >= pr[c]: evaluate() ops.append(c) i += 1 while len(ops): evaluate() print(nums[-1]) 注意：Python 当中 for i in range(n) 无法强制改变 i 的值！ AcWing 829 AcWing 892 #include &lt;iostream> #include &lt;string> using namespace std; const int N = 100010; int q[N]; int hh, tt; int main() &#123; int n; hh = 0, tt = -1; scanf(\"%d\", &amp;n); while (n--) &#123; string op; int x; cin >> op; if (op == \"push\") &#123; scanf(\"%d\", &amp;x); q[++tt] = x; &#125; else if (op == \"pop\") hh++; else if (op == \"empty\") &#123; if (hh > tt) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; else printf(\"%d\\n\", q[hh]); &#125; return 0; &#125; n = int(input()) q = [0] * n hh = 0; tt = -1 for _ in range(n): op = input().split() if op[0] == 'push': tt += 1 q[tt] = int(op[-1]) elif op[0] == 'pop': hh += 1 elif op[0] == 'empty': if hh > tt: print(\"YES\") else: print(\"NO\") else: print(q[hh]) AcWing 830 AcWing 830 #include &lt;iostream> using namespace std; const int N = 100010; int stk[N]; int a[N]; int tt; int main() &#123; tt = -1; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; n; i++) &#123; while (tt >= 0 &amp;&amp; stk[tt] >= a[i]) tt--; if (tt == -1) printf(\"-1 \"); else printf(\"%d \", stk[tt]); stk[++tt] = a[i]; &#125; return 0; &#125; n = int(input()) stk = [0] * n tt = -1 nums = list(map(int, input().split())) res = [] for num in nums: while tt >= 0 and stk[tt] >= num: tt -= 1 if tt == -1: res.append(-1) else: res.append(stk[tt]) tt += 1 stk[tt] = num print(' '.join(map(str, res))) AcWing 154 AcWing 154 #include &lt;iostream> using namespace std; const int N = 1e6 + 10; int q[N], a[N]; int hh, tt; int main() &#123; hh = 0, tt = -1; int n, k; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; n; i++) &#123; // min while (hh &lt;= tt &amp;&amp; a[q[tt]] >= a[i]) tt--; q[++tt] = i; while (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + 1) hh++; if (i >= k - 1) printf(\"%d \", a[q[hh]]); &#125; cout &lt;&lt; endl; hh = 0, tt = -1; for (int i = 0; i &lt; n; i++) &#123; // max while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++tt] = i; while (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + 1) hh++; if (i >= k - 1) printf(\"%d \", a[q[hh]]); &#125; return 0; &#125; n, k = map(int, input().split()) nums = list(map(int, input().split())) q = [0] * n res = [] hh = 0 tt = -1 for i in range(n): while hh &lt;= tt and nums[q[tt]] >= nums[i]: tt -= 1 tt += 1 q[tt] = i while hh &lt;= tt and q[hh] &lt; i - k + 1: hh += 1 if i >= k - 1: res.append(nums[q[hh]]) print(' '.join(map(str, res))) res.clear() hh = 0 tt = -1 for i in range(n): while hh &lt;= tt and nums[q[tt]] &lt;= nums[i]: tt -= 1 tt += 1 q[tt] = i while hh &lt;= tt and q[hh] &lt; i - k + 1: hh += 1 if i >= k - 1: res.append(nums[q[hh]]) print(' '.join(map(str, res)))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"},{"name":"Stack","slug":"Stack","permalink":"https://www.leolang.top/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"https://www.leolang.top/tags/Queue/"}]},{"title":"AcWing 数据结构（一）","slug":"数据结构（一）链表","date":"2021-07-19T16:00:00.000Z","updated":"2021-08-25T11:07:08.000Z","comments":true,"path":"2021/07/20/数据结构（一）链表/","link":"","permalink":"https://www.leolang.top/2021/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E9%93%BE%E8%A1%A8/","excerpt":"前言 本文将介绍关于链表的相关内容。将介绍链表的数组模拟实现及相关链表操作。","text":"前言 本文将介绍关于链表的相关内容。将介绍链表的数组模拟实现及相关链表操作。 数据结构（一）链表 结构体模拟的链表： struct Node &#123; int val; Node* next; &#125; 动态链表很慢，想要提高效率使用数组模拟链表 一、单链表 单链表最常用的是邻接表，邻接表常用于存储图和树 用数组模拟涉及到两个部分，数组各元素值、数组各元素的下一个元素的下标。 这里一般设立两个数组来记录这两个东西，分别是 \\(\\{e_n\\}\\) 、\\(\\{ne_n\\}\\) ，关联点是两个数组的下标 \\[ e_i :=val(v_i)\\\\ ne_i:= \\begin{cases} k&amp; next(v_i)=k\\\\ -1&amp;next(v_i)=\\text{null} \\end{cases} \\] int head; int e[N], ne[N]; int idx; //store where is empty 初始化 void init() &#123; head = -1; idx = 0; &#125; 头插 void add_to_head(int x) &#123; e[idx] = x; ne[idx] = head; head = idx; idx++; &#125; 插入 void add(int k, int x) &#123; e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; &#125; 删除 void remove(int k) &#123; ne[k] = ne[ne[k]]; &#125; 二、双链表 双链表通常用来优化某些问题. 双链表每个结点有两个指针，分别指向前驱和后继。默认下标为 \\(0\\) 是头，下标为 \\(1\\) 是尾。需要三个数组，分别是 \\(\\{e_n\\}\\) 、 \\(\\{l_n\\}\\) 、 \\(\\{r_n\\}\\) int m; int e[N], l[N], r[N]; int idx; 注意！！！ \\(0\\) 、\\(1\\) 是两个空结点！！！ 初始化 void init &#123; r[0] = 1; l[1] = 0; idx = 2; &#125; 插入 void add(int k, int x) &#123; e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx++; &#125; 头插要插到 \\(0\\) 的右边，尾插要插到 \\(l[1]\\) 的右边 删除 void remove(int k) &#123; r[l[k]] = r[k]; l[r[k]] = l[k]; &#125; 习题 AcWing 826 AcWing 826 #include &lt;iostream> using namespace std; const int N = 100010; int e[N], ne[N]; int idx, head; void init() &#123; head = -1; idx = 0; &#125; void addHead(int x) &#123; e[idx] = x; ne[idx] = head; head = idx; idx++; &#125; void add(int k, int x) &#123; e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx++; &#125; void remove(int k) &#123; ne[k] = ne[ne[k]]; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); init(); char op; int k, x; while (n--) &#123; cin >> op; if (op == 'H') &#123; scanf(\"%d\", &amp;x); addHead(x); &#125; else if (op == 'I') &#123; scanf(\"%d%d\", &amp;k, &amp;x); add(k - 1, x); &#125; else &#123; scanf(\"%d\", &amp;k); if (k == 0) head = ne[head]; else remove(k - 1); &#125; &#125; for (int i = head; i != -1; i = ne[i]) printf(\"%d \", e[i]); return 0; &#125; def addHead(x): global idx, head e[idx] = x ne[idx] = head head = idx idx += 1 def add(k, x): global idx e[idx] = x ne[idx] = ne[k] ne[k] = idx idx += 1 def remove(k): ne[k] = ne[ne[k]] if __name__ == '__main__': head = -1 idx = 0 n = int(input()) e = [0] * n ne = [0] * n for _ in range(n): op = input().split() if op[0] == 'H': addHead(int(op[-1])) elif op[0] == 'D': k = int(op[-1]) if k == 0: head = ne[head] else: remove(k - 1) elif op[0] == 'I': k = int(op[1]) x = int(op[-1]) add(k - 1, x) res = [] while head != -1: res.append(e[head]) head = ne[head] print(' '.join(map(str, res))) AcWing 827 AcWing 827 #include &lt;iostream> #include &lt;string> using namespace std; const int N = 100010; int e[N], l[N], r[N]; int idx; void init() &#123; r[0] = 1; l[1] = 0; idx = 2; &#125; void add(int k, int x) &#123; e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx++; &#125; void remove(int k) &#123; l[r[k]] = l[k]; r[l[k]] = r[k]; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); init(); while (n--) &#123; string op; int k, x; cin >> op; if (op == \"R\") &#123; scanf(\"%d\", &amp;x); add(l[1], x); &#125; else if (op == \"L\") &#123; scanf(\"%d\", &amp;x); add(0, x); &#125; else if (op == \"IR\") &#123; scanf(\"%d%d\", &amp;k, &amp;x); add(k + 1, x); &#125; else if (op == \"IL\") &#123; scanf(\"%d%d\", &amp;k, &amp;x); add(l[k + 1], x); &#125; else &#123; scanf(\"%d\", &amp;k); remove(k + 1); &#125; &#125; for (int i = r[0]; i != 1; i = r[i]) printf(\"%d \", e[i]); return 0; &#125; def add(k, x): global idx e[idx] = x r[idx] = r[k] l[idx] = k l[r[k]] = idx r[k] = idx idx += 1 def remove(k): l[r[k]] = l[k] r[l[k]] = r[k] if __name__ == '__main__': n = int(input()) e = [0] * (n + 2) l = [0] * (n + 2) r = [0] * (n + 2) idx = 2 l[1] = 0 r[0] = 1 for _ in range(n): op = input().split() if op[0] == 'R': add(l[1], int(op[-1])) elif op[0] == 'L': add(0, int(op[-1])) elif op[0] == 'IL': k, x = map(int, op[1::1]) add(l[k + 1], x) elif op[0] == 'IR': k, x = map(int, op[1::1]) add(k + 1, x) elif op[0] == 'D': remove(int(op[-1]) + 1) res = [] p = r[0] while p != 1: res.append(e[p]) p = r[p] print(' '.join(map(str, res)))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"},{"name":"Link list","slug":"Link-list","permalink":"https://www.leolang.top/tags/Link-list/"}]},{"title":"AcWing 基础算法（六）","slug":"基础算法（六）位运算_离散化_区间合并","date":"2021-07-17T16:00:00.000Z","updated":"2022-06-22T17:24:21.586Z","comments":true,"path":"2021/07/18/基础算法（六）位运算_离散化_区间合并/","link":"","permalink":"https://www.leolang.top/2021/07/18/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%BD%8D%E8%BF%90%E7%AE%97_%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/","excerpt":"前言 本文将介绍有关位运算、离散化、区间合并的相关内容及模板实现。","text":"前言 本文将介绍有关位运算、离散化、区间合并的相关内容及模板实现。 基础算法（六）位运算 一、求整数 \\(n\\) 的二进制表示中第 \\(k\\) 位数 思路： 把第 \\(k\\) 位移到最后一位，使用 &gt;&gt; 运算符 n &gt;&gt; k 看个位是几，取出个位： x &amp; 1 则公式为： n &gt;&gt; k &amp; 1 二、\\(\\texttt{lowbit}\\) 操作 \\(lowbit(x)\\) 为返回 \\(x\\) 的二进制数中最后一位 \\(1\\) 及其之后的部分。 例如： \\[ x=5=(1010)_2\\\\ \\Rightarrow lowbit(x)=(10)_2 \\] 返回最后一位 \\(1\\) 的位置公式： x &amp; -x 推导：设 \\(x=(1010\\cdots10\\cdots0)_2\\) ，则 \\(\\sim x=(0101\\cdots01\\cdots1)_2\\) \\[ -x=\\sim x + 1\\\\ x\\&amp;(-x)=x\\&amp;(\\sim x+1)=\\\\ \\begin{align} &amp;1010\\cdots100\\cdots0\\\\ \\&amp;&amp;0101\\cdots100\\cdots0\\\\ =&amp;0000\\cdots100\\cdots0 \\end{align} \\] 应用：统计数 \\(x\\) 中 \\(1\\) 的个数 思路：应用 \\(lowbit(x)\\) 求出最后一个 \\(1\\) 的位置（二进制），之后去掉这个 \\(1\\) 及其之后的部分，即是减去当前位置的这个 \\(1\\) 及其后面的 \\(0\\) 转换成二进制之后的数 ，也就是减去 \\(lowbit(x)\\) 。 循环上述操作，直至 \\(x\\) 减为 \\(0\\) 。 int lowbit(int x) &#123; return x &amp; -x; &#125; ​ 习题 AcWing 801 AcWing 801 #include &lt;iostream> using namespace std; const int N = 100010; int lowbit(int x) &#123; return x &amp; -x; &#125; int main() &#123; int n; int x; cin >> n; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;x); int res = 0; while (x) &#123; x -= lowbit(x); res++; &#125; printf(\"%d \", res); &#125; return 0; &#125; def lowbit(x): return x &amp; -x if __name__ == '__main__': n = int(input()) nums = list(map(int, input().split())) ress = [] for num in nums: res = 0 while num: num -= lowbit(num) res += 1 ress.append(res) print(' '.join(map(str, ress))) 基础算法（七）离散化 整数有序、保序离散化 假定有序列 \\(\\{a_n\\}\\) ，其中对于 \\(\\forall a_i,a_i\\in[0, 10^9]\\) ，值域的跨度非常大，但实际上 \\(n\\) 的值很小，序列非常稀疏。我们之后要使用这些数作为下标。如果为这么一些数去开辟一个 \\(10^9\\) 大小的数组很不值当，这时就要将这些数和自然数序列构建双射。这个过程就被称之为整数的离散化。 几个问题： 序列中可能有重复元素：去重 使用 &lt;algorithm&gt; 的 unique(egin, end) 进行去重，之后使用 erase() 方法去掉序列后边重复的一系列元素。 /** Header * #include &lt;algorithm> * using std::sort(begin, end) to sort first. * using std::unique(begin, end) to erase repeated items, and return the end-iter of the unique-list, and it is also the begin-iter of the repeated-list. * using std::vector.erase(begin, end) to erase the repeated-list. */ vector&lt;int> alls; sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()) # Defination # alls: list alls.sort() alls = list(set(alls)) 手写被排序之后调用的 unique() ：双指针算法 C++ vector&lt;int>::iterator unique(vector&lt;int> &amp;a) &#123; int j = 0; for (int i = 0; i &lt; a.size(); i++) &#123; if (!i || a[i] != a[i - 1]) a[j++] = a[i]; &#125; return a.begin() + j; &#125; Python def unique(a: list) -> int: j = 0 for i in range(0, len(a)): if not i or a[i] != a[i - 1]: a[j] = a[i] j += 1 return j 如何算出某一值 \\(x\\) 离散化后 在序列中的下标是多少：二分 这里取性质为 q[mid] &gt;= x ，即二分找到第一个 \\(\\geq x\\) 的位置 int find(int x, vector&lt;int> &amp;alls) &#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; &#125; return r; // list map to 0, 1, ..., n-1 /** or write as return r + 1; // list map to 1, 2, ..., n */ &#125; def find(x: int, alls: list) -> int: l = 0 r = len(alls) - 1 while l &lt; r: mid = l + r >> 1 if alls[mid] >= x: r = mid else: l = mid + 1 return r # or write as # return r + 1 习题 AcWing 802 AcWing 802 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> using namespace std; const int N = 300010; int a[N], s[N]; vector&lt;int> alls; vector&lt;pair&lt;int, int>> adds, lrs; int find(int x) &#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r >> 1; if (alls[mid] >= x) r = mid; else l = mid + 1; &#125; return r + 1; &#125; int main() &#123; int n, m; cin >> n >> m; for (int i = 0; i &lt; n; i++) &#123; int x, c; scanf(\"%d%d\", &amp;x, &amp;c); adds.push_back(&#123;x, c&#125;); alls.push_back(x); &#125; for (int i = 0; i &lt; m; i++) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); lrs.push_back(&#123;l, r&#125;); alls.push_back(l); alls.push_back(r); &#125; sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); for (auto &amp;add: adds) a[find(add.first)] += add.second; for (int i = 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; for (auto &amp;lr: lrs) printf(\"%d\\n\", s[find(lr.second)] - s[find(lr.first) - 1]); return 0; &#125; def find(nums, x): l = 0 r = len(nums) - 1 while l &lt; r: mid = l + r >> 1 if nums[mid] >= x: r = mid else: l = mid + 1 return r + 1 if __name__ == '__main__': n, m = map(int, input().split()) alls = [] adds = [list(map(int, input().split())) for _ in range(n)] lrs = [list(map(int, input().split())) for _ in range(m)] for add in adds: alls.append(add[0]) for lr in lrs: alls += lr alls = sorted(list(set(alls))) a = [0] + [0] * len(alls) for add in adds: a[find(alls, add[0])] += add[1] for i in range(1, len(alls) + 1): a[i] += a[i - 1] for lr in lrs: print(a[find(alls, lr[1])] - a[find(alls, lr[0]) - 1]) 基础算法（八）区间合并 给一系列区间，将区间中有交集的区间进行合并，得到并集。区间合并算法即快速的将两个存在交集的区间合并得到其并集。规定两个区间端点相同也可以合并。 步骤： 按照所有区间的左端点排序。需注意，已经按左端点排好序了，则之后不会再出现 \\(l_i&gt;l_{i+k}(k&gt;0)\\) 的情况 对于当前维护区间 \\([s, e]\\) ，第 \\(i\\) 个区间 \\([l_i, r_i]\\) 而言有如下三种情况： 当 \\(s\\geq l_i,e\\leq r_i\\) 时，被查看区间 \\([l_i,r_i]\\) 正处于维护区间内部，则该区间被维护区间吸收，当前维护区间不发生变化。 当 \\(s\\geq l_i,e&gt;r_i\\) 时，则被查看区间的右边界处于当前维护区间外侧，且有公共部分即存在交集。则需要更新当前维护区间的右边界为 \\(r_i\\) ，即 \\(e=r_i\\) 当 \\(s&lt;e&lt;l_i&lt;r_i\\) 时，被查看边界已经完全地处于当前维护边界之外了。由于左边界升序排列，那么当前这一区间 \\([s,e]\\) 已经不可能和后续区间产生任何交集，不可能进行任何操作了。所以也就得到了一个答案，答案数加一，当前维护的区间焦点转向了区间 \\([l_i,r_i]\\) 总结如下： \\[ \\text{Check intersection and union: }[s,e],[l_i,r_i]\\\\ [s,e]\\Rightarrow \\begin{cases} [s,e]&amp;s\\geq l_i,e\\leq r_i\\\\ [s,r_i]&amp;s\\geq l_i,e&gt;r_i\\\\ [l_i,r_i],res=[s,e]&amp;s&lt;e&lt;l_i&lt;r_i \\end{cases} \\] 习题 AcWing 803 #include &lt;iostream> #include &lt;vector> #include &lt;algorithm> using namespace std; vector&lt;pair&lt;int, int>> segs, res; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); segs.push_back(&#123;l, r&#125;); &#125; sort(segs.begin(), segs.end()); int s = segs[0].first, e = segs[0].first; for (auto &amp;seg: segs) &#123; if (e &lt; seg.first) &#123; if (e != segs[0].first) res.push_back(&#123;s, e&#125;); s = seg.first, e = seg.second; &#125; else e = max(e, seg.second); &#125; res.push_back(&#123;s, e&#125;); printf(\"%d\", res.size()); return 0; &#125; n = int(input()) segs = [list(map(int, input().split())) for _ in range(n)] segs.sort() res = [] s = segs[0][0] e = segs[0][0] for seg in segs: if e &lt; seg[0]: if e != segs[0][0]: res.append([s, e]) s = seg[0] e = seg[1] else: e = max(e, seg[1]) res.append([s, e]) print(len(res)) 、","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"},{"name":"Bit operation","slug":"Bit-operation","permalink":"https://www.leolang.top/tags/Bit-operation/"},{"name":"Discretization","slug":"Discretization","permalink":"https://www.leolang.top/tags/Discretization/"},{"name":"Interval merging","slug":"Interval-merging","permalink":"https://www.leolang.top/tags/Interval-merging/"}]},{"title":"AcWing 基础算法（五）","slug":"基础算法（五）双指针算法","date":"2021-07-16T16:00:00.000Z","updated":"2021-08-10T04:10:46.000Z","comments":true,"path":"2021/07/17/基础算法（五）双指针算法/","link":"","permalink":"https://www.leolang.top/2021/07/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/","excerpt":"前言 本文将介绍双指针算法的有关内容。","text":"前言 本文将介绍双指针算法的有关内容。 基础算法（五）双指针算法 回忆归并排序的过程，那个实质上就是一类双指针算法。双指针算法有两类：指针指向两个不同序列、指针指向同一个序列。代码的通用的模板都是一样的。 通用模板 for (int i = 0, j = 0; i &lt; n; i++) &#123; while (j &lt; i &amp;&amp; check(i, j)) j++; /* 具体逻辑 */ &#125; 双指针算法的作用 二维的朴素暴力遍历即用两个指针扫描一个序列的话复杂度是 \\(O(n^2)\\) 的，正常暴力的写法是这样的： for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; /* something else */ &#125; &#125; 可以看到，两个指针在序列中游走最多也就是游动 \\(2n\\) 次。双指针算法就是为了优化这种复杂度极高的遍历操作，能够通过==某些性质==将其降到 \\(O(n)\\) 复杂度。 例子 输入一个字符串，换行分别输出字符串中每个单词 #include &lt;iostream> #include &lt;cstring> using namespace std; int main() &#123; char str[1000]; cin.getline(str, sizeof(str)); int n = strlen(str); for (int i = 0; i &lt; n; i++) &#123; int j = i; while (j &lt; n &amp;&amp; str[j] != ' ') j++; for (int k = i; k &lt; j; k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; &#125; return 0; &#125; 总结 双指针算法都是要先有一个双遍历的暴力的双遍历，之后再去观察是否对于两个指针是否有某种性质，有某种单调关系。如果有的话就可以想办法只遍历一次，即只用单一个指针进行遍历，而在遍历的过程中加入双指针进行操作和判断，将复杂度降至 \\(O(n)\\) 。 习题 AcWing 799 AcWing 799 #include &lt;iostream> using namespace std; const int N = 100010; int q[N], tot[N]; int res; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); for (int i = 0, j = 0; i &lt; n; i++) &#123; tot[q[i]]++; while (tot[q[i]] > 1) &#123; tot[q[j]]--; j++; &#125; res = max(res, i - j + 1); &#125; printf(\"%d\", res); return 0; &#125; n = int(input()) q = list(map(int, input().split())) tot = [0] * 100010 j = 0 res = 0 for i in range(n): tot[q[i]] += 1 while tot[q[i]] > 1: tot[q[j]] -= 1 j += 1 res = max(res, i - j + 1) print(res) AcWing 800 AcWing 800 #include &lt;iostream> using namespace std; const int N = 100010; int a[N], b[N]; int main() &#123; int n, m, x; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;x); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; m; i++) scanf(\"%d\", &amp;b[i]); for (int i = 0, j = m - 1; i &lt; n; i++) &#123; while (j >= 0 &amp;&amp; a[i] + b[j] > x) j--; if (a[i] + b[j] == x) &#123; printf(\"%d %d\", i, j); break; &#125; &#125; return 0; &#125; n, m, x = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) i = 0 j = m - 1 for i in range(n): while j >= 0 and a[i] + b[j] > x: j -= 1 if a[i] + b[j] == x: print(i, j) break AcWing 2816 AcWing 2816 #include &lt;iostream> using namespace std; const int N = 100010; int a[N], b[N]; int main() &#123; int n, m; cin >> n >> m; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; m; i++) scanf(\"%d\", &amp;b[i]); int i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; if (a[i] == b[j]) i++; j++; &#125; if (i == n) cout &lt;&lt; \"Yes\"; else cout &lt;&lt; \"No\"; return 0; &#125; n, m = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) i = 0 j = 0 while i &lt; n and j &lt; m: if a[i] == b[j]: i += 1 j += 1 if i == n: print(\"Yes\") else: print(\"No\")","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"},{"name":"Double pointer algorithm","slug":"Double-pointer-algorithm","permalink":"https://www.leolang.top/tags/Double-pointer-algorithm/"}]},{"title":"AcWing 基础算法（四）","slug":"基础算法（四）前缀和与差分","date":"2021-07-14T16:00:00.000Z","updated":"2021-08-10T04:01:26.000Z","comments":true,"path":"2021/07/15/基础算法（四）前缀和与差分/","link":"","permalink":"https://www.leolang.top/2021/07/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/","excerpt":"前言 本文将介绍有关前缀和与差分的相关概念，将分别介绍一维、二维的前缀和与差分，并给出实现模板。","text":"前言 本文将介绍有关前缀和与差分的相关概念，将分别介绍一维、二维的前缀和与差分，并给出实现模板。 基础算法（四）前缀和与差分 一、前缀和 （一）一维前缀和 有长度为 \\(n\\) 的数组 \\(\\{a_n\\}\\) ，前缀和数组 \\(S\\) 定义为 \\[ S_0=0\\\\ \\begin{align} S_i &amp;=a_1+a_2+\\cdots+a_i\\\\ &amp;=\\displaystyle\\sum_{i=1}^na_i\\\\ \\end{align} \\] 1.如何求 \\(S_i\\) 递归计算： \\[ S_0=0\\\\ \\text{for i in range }[1,n]\\text{ do}\\\\ S_i=S_{i-1}+a_i \\] s[0] = 0; for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; 2.前缀和数组的作用 前缀和数组可以很快的求数组中一段的和。例如数组中的区间 \\([l,r]\\) ，有了前缀和数组 \\(S\\) 后，若希望得到区间 \\([l,r]\\) 的数值之和，则有如下的式子成立： \\[ \\begin{align} \\sum_{i=l}^ra_i &amp;=a_l+a_{l+1}+\\cdots+a_r\\\\ &amp;=S_r-S_{l-1} \\end{align} \\] 即可以通过前缀和的运算快速的得到结果，复杂度为 \\(O(1)\\) ，相较于遍历进行求值的 \\(O(n)\\) 快了很多。 上述公式的推导如下： ​ 由前缀和数组定义有： \\[ \\begin{align} S_r=\\sum_{i=1}^ra_i&amp;=a_1+a_2+\\cdots+a_{l-1}+a_l+a_{l+1}+\\cdots+a_r\\\\[5px] S_{l-1}=\\sum_{i=1}^{l-1}a_i&amp;=a_1+a_2+\\cdots+a_{l-1}\\\\ \\end{align} \\] ​ 则易得 \\[ a_l+a_{l+1}+\\cdots+a_r=S_r-S_{l-1} \\] ​ 成立，则公式 \\[ \\sum_{i=l}^r=S_r-S_{l-1} \\] ​ 成立。 即区间 \\([l,r]\\) 的数值和计算公式为：\\(\\sum_{i=l}^r=S_r-S_{l-1}\\) 模板 int l, r; scanf(\"%d%d\", &amp;l, &amp;r); res = s[r] - s[l - 1]; （二）二维前缀和 有矩阵 \\(A_{nm}\\) ，记矩阵元素为 \\(a_{ij}\\) ，定义矩阵的前缀和 \\(S_{ij}\\) 为 \\[ S_{ij}= \\begin{align} &amp;a_{11}+a_{12}+\\cdots+a_{1j}+\\\\ &amp;a_{21}+a_{22}+\\cdots+a_{2j}+\\\\ &amp;\\cdots+\\\\ &amp;a_{i1}+a_{i2}+\\cdots+a_{ij} \\end{align} =\\sum_{x=1}^i\\sum_{y=1}^ja_{xy} \\] 计算 \\(S_{ij}\\) 的方法和一维类似，仍是递归计算，结果为 \\[ S_{ij}=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{ij} \\] 推导如下： ​ 首先一定要注意，矩阵的元素是离散的！！！记忆的时候要记得矩阵是离散的数的点而不是连续的图形。 ​ 给定矩阵内部两点 \\((x_1,y_1),(x_2,y_2)\\) ，其中 \\(x_1&lt;x_2,y_1&lt;y_2\\) ，这里的点可以理解成矩阵的 “边” 。记以 \\(a_{x_1y_1}\\) 为左上角边界，以 \\(a_{x_2y_2}\\) 为右下角边界的子矩阵为 \\(\\Big[(x_1,y_1),(x_2,y_2)\\Big]\\) ，记子矩阵中各元素之和（后简称为子矩阵和）为 \\({Sub}\\Big[(x_1,y_1),(x_2,y_2)\\Big]\\) 。 ​ \\(S_{ij}\\) 其实代表的是以元素 \\(a_{11},a_{ij}\\) 分别作为左上顶点与右下顶点的子矩阵和。可以看到，去除点 \\(a_{ij}\\) 后， \\(S_{ij}-a_{ij}\\) 实际上是子矩阵 \\(\\Big[(0,0),(i-1,j)\\Big]\\) 加上 \\(\\Big[(0,0),(i,j-1)\\Big]\\) 的子矩阵和，由于两者的共有部分被计算了两次，所以要减去共有部分 \\(\\Big[(0,0),(i-1,j-1)\\Big]\\) 的子矩阵和。则可以计算出 \\(S_{ij}\\) 的值为 \\[ \\begin{align} S_{ij}&amp;={Sub}\\Big[(0,0),(i-1,j)\\Big]+{Sub}\\Big[(0,0),(i,j-1)\\Big]-{Sub}\\Big[(0,0),(i-1,j-1)\\Big]+a_{ij}\\\\ &amp;=S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}+a_{ij} \\end{align} \\] 那么，如果任意给定矩阵内部两点 \\((x_1,y_1),(x_2,y_2)\\) ，其中 \\(x_1&lt;x_2,y_1&lt;y_2\\) ，就可以求得 \\({Sub}\\Big[(x_1,y_1),(x_2,y_2)\\Big]\\) 的值为 \\[ {Sub}\\Big[(x_1,y_1),(x_2,y_2)\\Big]=S_{x_2y_1}-S_{x_2,y_1-1}-S_{x_1-1,y2}+S_{x_1-1,y_1-1} \\] 推导如下： ​ 和计算 \\(S_{ij}\\) 的想法相同，矩阵内部的子矩阵和 \\({Sub}\\Big[(x_1,y_1),(x_2,y_2)\\Big]\\) 为大矩阵 \\(\\Big[(1,1),(x_2,y_2)\\Big]\\) 的子矩阵和减去两个小长方形子矩阵 \\(\\Big[(0,0),(x_1-1,y_2)\\Big]\\) 、 \\(\\Big[(0,0),(x_2,y_1-1)\\Big]\\) 的子矩阵和，最后，由于左上角的小子矩阵 \\(\\Big[(0,0),(x_1-1,y_1-1)\\Big]\\) 被多余的减去了一次，所以要将其加回来，则加上其子矩阵和。相对应的子矩阵和 \\(Sub\\Big[(0,0),(x,y)\\Big]\\) 即为其前缀和 \\(S_{xy}\\) 。 模板 for (int i = 1; i &lt;= n; i++) &#123; for (int = j = 1; j &lt;= m; j++) &#123; s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; &#125; &#125; for i in range(1, n + 1): for j in range(1, m + 1): s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); res = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; 二、差分 差分与前缀和互为逆运算 （一）一维差分 给定数组 \\(\\{a_n\\}\\) ，构造数组 \\(\\{b_n\\}\\) ，使得数组 \\(\\{a_n\\}\\) 是数组 \\(\\{b_n\\}\\) 的前缀和，则数组 \\(\\{b_n\\}\\) 称为数组 \\(\\{a_n\\}\\) 的差分，且有如下关系成立： \\[ a_i=\\sum_{k=1}^ib_k=b_1+b_2+\\cdots+b_i \\] 那么，由前缀和的定义，我们其实很容易的能得到如何去构造差分数组 \\[ \\begin{align} &amp;b_1=a_1\\\\ &amp;b_2=a_2-a_1\\\\ &amp;b_3=a_3-a_2\\\\ &amp;\\cdots\\\\ &amp;b_n=a_n-a_{n-1}\\\\ \\end{align} \\] 那么，显然的，由差分数组，进行一遍扫描，即可以用 \\(O(n)\\) 的时间求出前缀和数组。 那么差分有什么用？ 有这样的操作，数组 \\(\\{a_n\\}\\) 内的 \\([l,r]\\) 区间的所有元素都加上 \\(c\\) ，那么，这个时候就可以只修改 \\(\\{a_n\\}\\) 的差分数组 \\(\\{b_n\\}\\) 的两个元素 \\(b_l\\) 、 \\(b_{r+1}\\) 为 \\(b_l+c\\) 、 \\(b_{r+1}-c\\) 即可。 推导如下： \\[ \\begin{align} &amp;[l,r]=a_l,a_{l+1},\\cdots,a_r\\\\[10px] &amp;\\text{Step 1: }b_l\\Rightarrow b_l+c\\\\ &amp;[l,n]\\Rightarrow a_l+c,a_{l+1}+c,\\cdots,a_r+c,a_{r+1}+c,\\cdots,a_n+c\\\\[5px] &amp;\\text{Step 2: }b_{r+1}\\Rightarrow b_{r+1}-c\\\\ &amp;[r+1,n]\\Rightarrow a_{r+1},\\cdots,a_n\\\\[10px] &amp;[l,r]=a_l+c,a_{l+1}+c,\\cdots,a_r+c \\end{align} \\] 这样，就可以用 \\(O(1)\\) 的时间去给原数组修改一整段的数据了。 这样的话，其实就可以用上面的操作去构造原数组了，可以视原数组为 \\(0,0,\\cdots,0\\) ，它的差分数组也是 \\(0,0,\\cdots,0\\) ，构造原数组的过程就是在原数组区间 \\([i,i]\\) 上都加上 \\(a_i\\) 就可以了，这么做其实也构造好了差分数组。 模板 一次插入操作 void insert(int l, int r, int c) &#123; b[l] += c; b[r + 1] -= c; &#125; def insert(arr: list, l: int, r: int, c: int): arr[l] += c arr[r + 1] -= c 构造原数组、差分数组 for (int i = 1, i &lt;= n; i++) insert(i, i, a[i]); 操作 while (m--) &#123; int l, r, c; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; 重新计算新的前缀和，应用差分数组 \\(\\{b_n\\}\\) 直接存储新的前缀和 b[0] = 0; for (int i = 1; i &lt;= n; i++) b[i] += b[i - 1]; /* output array b[] */ （二）二维差分 记原矩阵为 \\(A_{nm}\\) ，其中元素为 \\(a_{ij}\\) ，同时，其差分矩阵为 \\(B_{nm}\\) ，元素为 \\(b_{ij}\\) 。 构造 \\(B\\) ，使得 \\(A\\) 是 \\(B\\) 的前缀和，即 \\(a_{ij}=S_{ij}(B)\\) 。 和一维差分中的思路完全相同的，假定初始时 \\(\\forall a_{ij}\\in A,a_{ij}=0\\) ，则显然有 \\(\\forall b_{ij}\\in B,b_{ij}=0\\) 。这时遍历 \\(A\\) 中元素进行类似于一维差分的插入操作即可。 同样的，类比一维差分，二维矩阵中想让一个子矩阵内部的所有元素全都加上 \\(c\\) 应该如何操作？ 给定左上、右下两点 \\((x_1,y_1),(x_2,y_2)\\) 划定边界，其中 \\(x_1&lt;x_2,y_1&lt;y_2\\)。让子矩阵 \\(\\Big[(x_1,y_1),(x_2,y_2)\\Big]\\) 内部的所有元素都加上 \\(c\\) ，步骤推导如下： $$ \\[\\begin{align} &amp;\\Big[(x_1,y_1),(x_2,y_2)\\Big]= \\begin{bmatrix} b_{x_1y_1}&amp;\\cdots&amp;b_{x_2y_2}\\\\ \\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{x_2y_1}&amp;\\cdots&amp;b_{x_2y_2} \\end{bmatrix}\\\\[10px] = &amp;\\left[ \\begin{array}{ccc:ccc} b_{x_1y_1}&amp;\\cdots&amp;b_{x_1y_2}&amp;b_{x_1,y_2+1}&amp;\\cdots&amp;b_{x_1m}\\\\ \\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{x_2y_1}&amp;\\cdots&amp;b_{x_2y_2}&amp;b_{x_2,y_2+1}&amp;\\cdots&amp;b_{x_2m}\\\\ \\hdashline b_{x_2+1,y_1}&amp;\\cdots&amp;b_{x_2+1,y_2}&amp;b_{x_2+1,y_2+1}&amp;\\cdots&amp;b_{x_2+1,m}\\\\ \\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{ny_1}&amp;\\cdots&amp;b_{ny_2}&amp;b_{n,y_2+1}&amp;\\cdots&amp;b_{nm} \\end{array} \\right]\\\\[20px] &amp;\\text{Step 1: }b_{x_1y_1}\\Rightarrow b_{x_1y_1}+c\\\\ &amp;\\Big[(x_1,y_1),(n,m)\\Big]\\Rightarrow \\begin{bmatrix} b_{x_1y_1}+c&amp;\\cdots&amp;b_{x_1m}+c\\\\ \\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{ny_1}+c&amp;\\cdots&amp;b_{nm}+c\\\\ \\end{bmatrix}\\\\[10px] &amp;\\text{Step 2: }b_{x_2+1,y_1}\\Rightarrow b_{x_2+1,y_1}-c\\\\ &amp;\\Big[(x_2+1,y_1),(n,m)\\Big]\\Rightarrow \\begin{bmatrix} b_{x_2+1,y_1}&amp;\\cdots&amp;b_{x_2+1,m}\\\\ \\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{ny_1}&amp;\\cdots&amp;b_{nm}\\\\ \\end{bmatrix}\\\\[10px] &amp;\\text{Step 3: }b_{x_1,y_2+1}\\Rightarrow b_{x_1,y_2+1}-c\\\\ &amp;\\Big[(x_1,y_2+1),(n,m)\\Big]\\Rightarrow \\begin{bmatrix} b_{x_1,y_2+1}&amp;\\cdots&amp;b_{x_1m}\\\\ \\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{x_2,y_2+1}&amp;\\cdots&amp;b_{x_2m}\\\\ b_{x_2+1,y_2+1}-c&amp;\\cdots&amp;b_{x_2+1,m}-c\\\\ \\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{n,y_2+1}-c&amp;\\cdots&amp;b_{nm}-c \\end{bmatrix}\\\\[10px] &amp;\\text{Step 4: }b_{x_2+1,y_2+1}\\Rightarrow b_{x_2+1,y_2+1}+c\\\\ &amp;\\Big[(x_2+1,y_2+1),(n,m)\\Big]\\Rightarrow \\begin{bmatrix} b_{x_2+1,y_2+1}&amp;\\cdots&amp;b_{x_2+1,m}\\\\ \\vdots&amp;\\ddots&amp;\\vdots\\\\ b_{x_2+1,y_2+1}&amp;\\cdots&amp;b_{nm}\\\\ \\end{bmatrix}\\\\[10px] \\end{align}\\] $$ 其实根据二维前缀和的想法也不难想到上方繁杂的数学推导中的想法了，我们只需要改变 \\(B\\) 中的四个元素就可以改变前缀和矩阵 \\(A\\) 的一个子矩阵区域内的所有元素了。 有了上面的操作，我们也就有了去通过前缀和矩阵构造差分矩阵的方法了，假设插入元素 \\(a_{ij}(\\forall a_{ij}\\in A)\\) ，只需要对 \\(A\\) 的 \\(1\\times1\\) 子矩阵 \\(\\Big[(i,j),(i,j)\\Big]\\) 加上 \\(a_{ij}\\) 就可以了。 当然，上面的操作并不是只用来进行构造差分矩阵了，也可以用来对矩阵的某一子矩阵进行操作了。 模板 一次插入操作 void insert(int x1, int y1, int x2, int y2, int c) &#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; &#125; 构造原矩阵、差分矩阵 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; insert(i, j, i, j, a[i][j]); &#125; &#125; 操作 while (q--) &#123; int x1, y1, x2, y2, c; cin >> x1 >> y1 >> x2 >> y2 >> c; insert(x1, y1, x2, y2, c); &#125; 重新计算前缀和并输出 for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; &#125; &#125; /* output matrix b[][] */ 补充：注意在 python 下差分要多在数组里加一个位置，就是除了脚标为 \\(0\\) 的位置外的最最后面的位置，因为执行 insert() 去构造最后一个元素的如果没有这一位会出现下标越界的问题。 习题 AcWing 795 AcWing 795 #include &lt;iostream> using namespace std; const int N = 100010; int a[N], s[N]; int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); s[i] = s[i - 1] + a[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", s[r] - s[l - 1]); &#125; return 0; &#125; n, m = map(int, input().split()) nums = list(map(int, input().split())) a = [0] + nums s = [0] * (n + 1) for i in range(1, n + 1): s[i] = s[i - 1] + a[i] for i in range(0, m): l, r = map(int, input().split()) print(s[r] - s[l - 1]) AcWing 796 AcWing 796 #include &lt;iostream> using namespace std; const int N = 1010; int a[N][N], s[N][N]; int main() &#123; int n, m, q; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%d\", &amp;a[i][j]); s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; &#125; &#125; for (int i = 1; i &lt;= q; i++) &#123; int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(\"%d\\n\", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); &#125; return 0; &#125; n, m, q = map(int, input().split()) a = [[0] * (m + 1)] + [[0] for _ in range(n)] s = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): a[i] += list(map(int, input().split())) for i in range(1, n + 1): for j in range(1, m + 1): s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j] for _ in range(q): x1, y1, x2, y2 = map(int, input().split()) print(s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]) AcWing 797 AcWing 797 #include &lt;iostream> using namespace std; const int N = 100010; int a[N], b[N]; void insert(int l, int r, int c) &#123; b[l] += c; b[r + 1] -= c; &#125; int main() &#123; int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); insert(i, i, a[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; int l, r, c; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; for (int i = 1; i &lt;= n; i++) &#123; b[i] += b[i - 1]; printf(\"%d \", b[i]); &#125; return 0; &#125; def insert(arr, l, r, c): arr[l] += c arr[r + 1] -= c if __name__ == '__main__': n, m = map(int, input().split()) a = [0] + list(map(int, input().split())) b = [0] * (len(a) + 1) for i in range(1, n + 1): insert(b, i, i, a[i]) for _ in range(m): l, r, c = map(int, input().split()) insert(b, l, r, c) for i in range(1, n + 1): b[i] += b[i - 1] print(' '.join(map(str, b[1:n + 1]))) AcWing 798 AcWing 798 #include &lt;iostream> using namespace std; const int N = 1010; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) &#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; &#125; int main() &#123; int n, m, q; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%d\", &amp;a[i][j]); insert(i, j, i, j, a[i][j]); &#125; &#125; while (q--) &#123; int x1, y1, x2, y2, c; scanf(\"%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c); insert(x1, y1, x2, y2, c); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; printf(\"%d \", b[i][j]); &#125; cout &lt;&lt; endl; &#125; return 0; &#125; def insert(mat, x1, y1, x2, y2, c): mat[x1][y1] += c mat[x2 + 1][y1] -= c mat[x1][y2 + 1] -= c mat[x2 + 1][y2 + 1] += c if __name__ == '__main__': n, m, q = map(int, input().split()) a = [[0] * (m + 1)] + [[0] for _ in range(n)] for i in range(1, n + 1): a[i] += list(map(int, input().split())) b = [[0] * (m + 2) for _ in range(n + 2)] for i in range(1, n + 1): for j in range(1, m + 1): insert(b, i, j, i, j, a[i][j]) for _ in range(q): x1, y1, x2, y2, c = map(int, input().split()) insert(b, x1, y1, x2, y2, c) for i in range(1, n + 1): for j in range(1, m + 1): b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] for i in range(1, n + 1): print(' '.join(map(str, b[i][1:m + 1])))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"},{"name":"Prefix sum","slug":"Prefix-sum","permalink":"https://www.leolang.top/tags/Prefix-sum/"},{"name":"Difference","slug":"Difference","permalink":"https://www.leolang.top/tags/Difference/"}]},{"title":"AcWing 基础算法（三）","slug":"基础算法（三）高精度","date":"2021-07-13T16:00:00.000Z","updated":"2021-08-10T03:57:00.000Z","comments":true,"path":"2021/07/14/基础算法（三）高精度/","link":"","permalink":"https://www.leolang.top/2021/07/14/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E9%AB%98%E7%B2%BE%E5%BA%A6/","excerpt":"前言 本文将介绍关于四则运算的高精度算法以及其在 C++ 中的具体实现。","text":"前言 本文将介绍关于四则运算的高精度算法以及其在 C++ 中的具体实现。 基础算法（三）高精度 〇、大整数的表示 创建一 int 数组，将大整数的每一位存入数组，倒序存储，目的是方便进位，C++ 中常用 std::vector&lt;int&gt; 读入数 \\(A\\) ，应用字符串 \\(a\\) 读入： string a; vector&lt;int> A; cin >> a; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); 输出结果数 \\(C\\) ： for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]); 一、高精度加法 \\(A+B:len(10^6)+ len(10^6)\\) 设两存储大整数的数组是 \\(A\\) 、 \\(B\\) ，最后得到的结果为 \\(C\\) ，记进位值为 \\(t\\) ，则第 \\(i\\) 位的结果是 \\(C_i=A_i+B_i+t \\mod 10\\) ，\\(t\\) 被更新为 \\(t=\\displaystyle\\lfloor\\frac{A_i+B_i+t}{10}\\rfloor\\) 模板 vector&lt;int> add(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123; if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(1); return C; &#125; ​ 默认 \\(len(A)&gt;len(B)\\) ： vector&lt;int> add(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; if (B.size() > A.size()) return add(B, A); for (int i = 0; i &lt; A.size(); i++) &#123; t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(1); return C; &#125; 二、高精度减法 \\(A-B:len(10^6)- len(10^6)\\) 默认应保证 \\(A\\geq B\\) ，若 \\(A&lt;B\\) 则转换为 \\(C=-(B-A)\\) ，记借位值为 \\(t\\) ，则 \\(C\\) 的第 \\(i\\) 位为 \\[ C_i=|A_i-B_i-t|\\mod10\\\\[5px] A_i-B_i-t= \\begin{cases} A_i-B_i-t&amp;A_i-B_i-t\\geq 0\\\\[3px] A_i-B_i-t+10&amp;A_i-B_i-t&lt;0 \\end{cases} \\mod 10 \\] 其中，\\(t\\) 的值应该更新为 \\[ t= \\begin{cases} 1&amp;A_i-B_i-t&gt; 0\\\\[5px] 0&amp;A_i-B_i-t\\leq 0\\\\ \\end{cases} \\] 模板 判断 \\(A\\) 、\\(B\\) 大小： bool cmp(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; if (A.size() != B.size()) return A.size() > B.size(); for (int i = A.size() - 1; i >= 0; i--) &#123; if (A[i] != B[i]) return A[i] > B[i]; &#125; return true; &#125; if (cmp(A, B)) &#123; auto C = sub(A, B); /* output C */ &#125; else &#123; auto C = sub(B, A); printf(\"-\"); /* output C */ &#125; 上述两种情况对于 \\(C_i\\) 的处理可以统一成 \\(C_i=(A_i+B_i-t+10)\\mod10\\) ，最后要去掉高位产生的前导 \\(0\\) vector&lt;int> sub(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size(); i++) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125; 三、高精度乘法 \\(A\\times b:len(10^6）\\times 10^9\\) 记进位为 \\(t\\) ，结果 \\(C\\) 为 \\(C_i=A_i\\times b+t\\mod 10\\) ，\\(t\\) 被更新为 \\(t=\\lfloor\\displaystyle\\frac{A_i\\times b+t}{10}\\rfloor\\) 模板 vector&lt;int> mul(vector&lt;int> A, const int b) &#123; if (b == 0) return &#123;0&#125;; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size() || t; i++) &#123; t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; return C; &#125; 四、高精度除法 高精除以低精求商和余数 \\(A\\div b:len(10^6)\\div10^4\\) 记最后所得余数为 \\(r\\) ，每次运算得到的余数为 \\(r_i\\) 运算过程可表示如下： \\(A\\div b=C\\dots\\dots r\\) ，其中对于每一步运算有如下式： \\[ \\begin{align} &amp;C_i=\\frac{r_{i-1}\\times10+A_i}b\\\\ &amp;r_i=r_{i-1}\\times10+A_i\\mod 10\\\\ \\end{align} \\] 除法是正序运算的，如果一道题里只用除法，那么正序存储进数组就可以了 模板 除法必须从高位算起！！！ 由于要求存储方式是倒序存储，但得到的 \\(C\\) 是正序存入 vector&lt;int&gt; 的，所以最后必须进行反转，调用 reverse(iterator begin, iterator end); 最后需要去掉高位产生的前导 \\(0\\) vector&lt;int> div(vector&lt;int>, const int b, int &amp;r) &#123; vector&lt;int> C； r = 0; for (int i = A.size() - 1; i >= 0; i--) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125; 习题 AcWing 791 AcWing 791 #include &lt;iostream> #include &lt;vector> #include &lt;string> using namespace std; const int N = 100010; vector&lt;int> add(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123; if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(1); return C; &#125; int main() &#123; string a, b; cin >> a >> b; vector&lt;int> A, B; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); vector&lt;int> C = add(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]); return 0; &#125; AcWing 792 AcWing 792 #include &lt;iostream> #include &lt;vector> #include &lt;string> using namespace std; const int N = 10010; bool cmp(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; if (A.size() != B.size()) return A.size() > B.size(); for (int i = A.size() - 1; i >= 0; i--) &#123; if (A[i] != B[i]) return A[i] > B[i]; &#125; return true; &#125; vector&lt;int> sub(vector&lt;int> &amp;A, vector&lt;int> &amp;B) &#123; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size(); i++) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125; int main() &#123; string a, b; vector&lt;int> A, B; cin >> a >> b; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0'); if (cmp(A, B)) &#123; auto C = sub(A, B); for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]); &#125; else &#123; auto C = sub(B, A); putchar('-'); for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]); &#125; return 0; &#125; AcWing 793 AcWing 793 #include &lt;iostream> #include &lt;vector> #include &lt;string> using namespace std; const int N = 100010; vector&lt;int> mul(vector&lt;int> &amp;A, const int b) &#123; if (b == 0) return &#123;0&#125;; vector&lt;int> C; int t = 0; for (int i = 0; i &lt; A.size() || t; i++) &#123; t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; return C; &#125; int main() &#123; string a; vector&lt;int> A; int b; cin >> a >> b; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); auto C = mul(A, b); for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]); return 0; &#125; AcWing 794 AcWing 794 #include &lt;iostream> #include &lt;string> #include &lt;vector> #include &lt;algorithm> using namespace std; const int N = 100010; vector&lt;int> div(vector&lt;int> &amp;A, const int b, int &amp;r) &#123; vector&lt;int> C; for (int i = A.size() - 1; i >= 0; i--) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() > 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125; int main() &#123; string a; vector&lt;int> A; int b; int r = 0; cin >> a >> b; for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0'); auto C = div(A, b, r); for (int i = C.size() - 1; i >= 0; i--) printf(\"%d\", C[i]); cout &lt;&lt; endl &lt;&lt; r; return 0; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"},{"name":"High Precision","slug":"High-Precision","permalink":"https://www.leolang.top/tags/High-Precision/"}]},{"title":"AcWing 基础算法（二）","slug":"基础算法（二）二分","date":"2021-07-09T16:00:00.000Z","updated":"2021-08-10T03:54:48.000Z","comments":true,"path":"2021/07/10/基础算法（二）二分/","link":"","permalink":"https://www.leolang.top/2021/07/10/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8C%E5%88%86/","excerpt":"前言 本文将介绍二分算法的相关内容及其模板，包括整数二分及浮点数二分的相关内容。","text":"前言 本文将介绍二分算法的相关内容及其模板，包括整数二分及浮点数二分的相关内容。 基础算法（二）二分 有单调性一定可以二分，但二分不需要单调性。二分的本质不是单调性，二分的本质是边界。 一、整数二分 给定一个区间 \\([l,r]\\) ，在该区间定义了 ”由于“ \\(x\\) 的性质 \\(\\cal A\\) 、\\(\\cal B\\) ，在区间上的一点 \\(x\\) （即分划边界）会将区间分为了两部分 \\([l,x]\\) 、 \\([x,r]\\) ，使得区间 \\([l,x]\\) 满足性质 \\(\\cal B\\) ，而区间 \\([x+1,r]\\) 满足性质 \\(\\cal A\\) 。则点 \\(x\\) 使得对于区间 \\([l,x]\\) 不满足性质 \\(\\cal A\\) ，而对于区间 \\([x+1,r]\\) 满足性质 \\(A\\) ，对于性质 \\(\\cal B\\) 亦然。则区间可以一分为二，对于一种性质而言，一个区间满足，一个区间不满足，则可以找到边界点进行二分。 寻找 \\(x\\) 的方法： 有函数 check() 是检查元素满足什么性质 check() 检查 \\(mid\\) 是否满足 \\([l,x]\\) 上的性质 \\(\\cal B\\) 取 \\(mid=\\displaystyle\\lfloor\\frac{l+r+1}2\\rfloor\\) ， $$如果满足，则更新区间为 \\([mid,r]\\) ，即 \\(l=mid\\) ，因为 \\(x\\) 应该在 \\(mid\\) 右侧的区间上；否则，如果不满足，则更新区间为 \\([l,mid-1]\\) ，即 \\(r=mid-1\\) ，因为 \\(x\\) 应该在 \\(mid\\) 左侧的区间上。 check() 检查 \\(mid\\) 是否满足 \\([x+1,r]\\) 上的性质 \\(\\cal A\\) 取 \\(mid=\\displaystyle\\lfloor\\frac{l+r}2\\rfloor\\) ，检查 \\(mid\\) 是否满足 \\([mid,r]\\) 上的条件或性质，如果满足，则更新区间为 \\([l,mid]\\) ，即 \\(r=mid\\) ；否则，如果不满足，则更新区间为 \\([mid+1,r]\\) ，即 \\(l=mid+1\\) 。 步骤： 写出 check() 函数，默认二分是取 \\(mid=\\displaystyle\\lfloor\\frac{l+r}2\\rfloor\\) 看 call 函数的时候条件为 true 应该如何更新区间，即 \\(mid\\) 应该赋给 \\(l\\) 还是 \\(r\\) 若是 \\(l=mid\\) 则取 \\(mid\\) 的条件改为 \\(mid=\\displaystyle\\lfloor\\frac{l+r+1}2\\rfloor\\) ；若是 \\(r=mid\\) 则不变 为什么要改 \\(mid\\) 为加一？ 由于除法是向下取整，当需要停止二分前，两侧区间满足条件 \\(l=r-1\\) 。\\(mid\\) 此时取值是 \\(l\\) 。这时再进行 check(mid) ，若结果为 true，则赋值句就变成了 \\(l=l\\) ，区间会永远的卡死在当前 \\([l,r]\\) 内死循环。如果该分子为加一， \\(mid\\) 即等于 \\(r\\) ，区间变为 \\([r,r]\\) ，二分停止。 模板：假设 check() 函数已经定义 bool check(int); int bsearch(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r >> 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l; &#125; def bsearch(l: int, r: int) -> int: while l &lt; r: mid = l + r >> 1 if check(mid): r = mid else: l = mid + 1 return l int bsearch(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r + 1 >> 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l; &#125; def bsearch(l: int, r: int) -> int: while l &lt; r: mid = l + r >> 1 if check(mid): l = mid else: r = mid - 1 return l 思想：更新区间，保证 \\(x\\) 一定被区间覆盖，不断缩小区间，直到区间缩小为1，即得到了 \\(x\\) 。无解就是最后的答案是小于等于 \\(x\\) 的，二分不会无解，无解是因为题目中的条件而无解，二分总是用性质判断会找到结果。 二分的几个小问题： 性质的选取？ check() 该判断什么？ 性质的选取实际上是任意的，只要是一个能够卡出边界的性质就可以了。但一定要注意更新区间的时候你设置的性质里面到底包不包含 \\(mid\\) 指向的元素，这决定了更新区间时候 \\(1\\) 的细微差别。 \\(mid\\) 是否要 \\(+1\\) ？ 计算 \\(mid\\) 到底要不要加一主要是看更新区间时语句 \\(?=mid\\) 中 \\(?\\) 到底是谁。如果是 \\(l=mid\\) 就需要改一下 \\(mid\\) 的赋值语句了。这么做的目的就是防止区间更新之后还是原来的区间，最后导致了死循环。相关推导上面已经给出了。 二、浮点数二分 浮点数二分不存在像整数二分的边界问题，答案在左边就更新区间为左区间，答案在右边就更新区间为右区间。二分停止的条件是 \\(r-l\\) 达到了一个阈值 \\(\\delta\\) ，即 \\(r-l\\leq\\delta\\) 时二分停止得到答案。 模板： double bsearch(int l, int r, int delta) &#123; while (r - l > delta) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l; &#125; def bsearch(l: float, r: float, delta: float) -> float: while r - l > delta: mid = (l + r) / 2 if check(mid): r = mid else: l = mid return l double bsearch(int l, int r, int delta) &#123; while (r - l > delta) &#123; double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; &#125; return l; &#125; def bsearch(l: float, r: float, delta: float) -> float: while r - l > delta: mid = (l + r) / 2 if check(mid): l = mid else: r = mid return l 另一种写法：直接循环100次 double bsearch(int l, int r, int delta) &#123; for (int i = 0; i &lt; 100; i++) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; return l; &#125; def bsearch(l: float, r: float, delta: float) -> float: for i in range(0, 100): mid = (l + r) / 2 if check(mid): r = mid else: l = mid return l 习题 AcWing 789 AcWing 789 找边界！！找边界！！边界将序列分为两部分，顾想到二分。 依题意，要找到被查询元素的上界和下界。首先看上界。上界的意味是第一个 \\(\\geq x\\) 的数，这时就可以定义 check() 的性质是 q[mid] &gt;= x ，当然这里定义为 q[mid] &lt; x 也未尝不可，只不过变成了反方向的寻找，找到的是上界的前一个数，更新区间的时候 \\(l\\) 应该被更新成 \\(mid+1\\) 。之后依据区间的变化和 \\(x\\) 被囊括在哪一个区间内去更新区间和判断要不要改动 \\(mid\\) 的取值即可。再看下界，下界的意味是最后一个 \\(\\leq x\\) 的数，则思路和上面一样，可以找到上下界。本题结束。 #include &lt;iostream> using namespace std; const int N = 100010; int q[N]; int main() &#123; int n, k; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); while (k--) &#123; int x; scanf(\"%d\", &amp;x); int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r >> 1; if (q[mid] >= x) r = mid; else l = mid + 1; &#125; /* or write as following while (l &lt; r) &#123; int mid = l + r >> 1; if (q[mid] &lt; x) l = mid + 1; else r = mid; &#125; */ if (q[l] != x) printf(\"-1 -1\\n\"); else &#123; printf(\"%d \", l); l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + r + 1 >> 1; if (q[mid] &lt;= x) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); &#125; &#125; return 0; &#125; n, q = map(int, input().split()) arr = list(map(int, input().split())) for i in range(1, q + 1): x = int(input()) l = 0 r = n - 1 while (l &lt; r): mid = l + r >> 1 if arr[mid] >= x: r = mid else: l = mid + 1 if (arr[l] != x): print(\"-1 -1\") else: temp = l l = 0 r = n - 1 while (l &lt; r): mid = l + r + 1 >> 1 if arr[mid] &lt;= x: l = mid else: r = mid - 1 print(' '.join(map(str, [temp, l]))) AcWing 790 AcWing 790 #include &lt;iostream> #include &lt;cmath> using namespace std; const double eps = 1e-8; int main() &#123; double n; cin >> n; double l = -10000, r = 10000; while (r - l > eps) &#123; double mid = (l + r) / 2; if (mid * mid * mid >= n) r = mid; else l = mid; &#125; printf(\"%.6f\", l); return 0; &#125; n = float(input()) l = -10000 r = 10000 eps = 1e-8 while (r - l > eps): mid = (l + r) / 2 if mid ** 3 >= n: r = mid else: l = mid print(\"%.6f\" % l)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.leolang.top/tags/Binary-Search/"}]},{"title":"AcWing 基础算法（一）","slug":"基础算法（一）排序","date":"2021-07-08T16:00:00.000Z","updated":"2021-08-10T03:55:28.000Z","comments":true,"path":"2021/07/09/基础算法（一）排序/","link":"","permalink":"https://www.leolang.top/2021/07/09/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F/","excerpt":"前言 本文将介绍基础算法中的排序算法及其模板，包括快速排序算法及归并排序算法。","text":"前言 本文将介绍基础算法中的排序算法及其模板，包括快速排序算法及归并排序算法。 基础算法（一）排序 一、快速排序 平均时间复杂度为 \\(O(n\\log n)\\) ，最坏时间复杂度为 \\(O(n^2)\\) ==思想：分治== 步骤： 确定分界点 \\(x\\) ：取左边界 q[l] 、右边界 q[r] 、中间 q[(l + r) / 2] 、随机 调整区间：使得左区间的数均 \\(\\leq x\\) ，右区间均 \\(\\geq x\\) 递归处理左右两段 如何调整区间？ 暴力做法 \\[ \\begin{align} &amp;\\text{Require: Sequence }q\\\\[3px] &amp;\\text{Step 1: Set Array }a,b\\text{; Dividing number }x\\\\ &amp;\\text{Step 2: for each in }q\\text{ do}\\\\ &amp;\\begin{cases} &amp;a\\Leftarrow q_k&amp;\\text{if }q_k&lt;x\\\\ &amp;b\\Leftarrow q_k&amp;\\text{if }q_k&gt;x\\\\ \\end{cases}\\\\ &amp;\\text{Step 3: }q\\Leftarrow a,b \\end{align} \\] 更好的做法 左侧设立指针 \\(i\\) ，右侧设立指针 \\(j\\) ，分别向左右移动。默认为分划点 \\(x\\) 左侧均满足 \\(q_k\\leq x\\) ，右侧均满足 \\(q_k\\geq x\\) 。 当两指针均移动到了不符合当前区间的条件的点时，交换两指针指向元素，此时两指针指向的数即符合要求。重复此操作，直至 \\(i\\) 、 \\(j\\) 相遇为止 算法模板 void quick_sort(int q[], int l, int r) &#123; if (l >= r) return; int x = q[l + r >> 1]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] > x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j); quick_sort(q, j + 1, r); &#125; def quick_sort(q: list, l: int, r: int): if l >= r: return x = q[l + r >> 1] i = l - 1 j = r + 1 while i &lt; j: while True: i +=1 if q[i] >= x: break while True: j -= 1 if q[j] &lt;= x: break if i &lt; j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j + 1, r) 每次都要先移动一次，所以边界指针设立在两侧外多1，处理结束之后即递归处理两边 几个可改动点： \\(x\\) 的选取： int x = q[l]; /*......*/ quick_sort(q, l, j); quick_sort(q, j + 1, r); int x = q[r]; /*......*/ quick_sort(q, l, i - 1); quick_sort(q, i ,r); int x = q[(l + r) >> 1]; //以上两种写法任意 swap 可手写 二、归并排序 时间复杂度为 \\(O(n\\log n)\\) ==思想：分治== 步骤： 确定分界点 \\(mid=\\frac{l+r}{2}\\) 递归排序左边区间、右边区间 归并：合二为一，时间复杂度为 \\(O(n)\\) 如何归并？双指针算法，二路归并 ​ 假设待合并序列 \\(q_1\\) 、 \\(q_2\\) 已有序（假设升序）。设立一新数组 \\(res\\) 作为存储空间。对两序列分别设立一头指针 \\(p_1\\) 、 \\(p_2\\) ，此时两指针指向的即为当前序列的最小值。如何获得合并序列 \\(res\\) 的第一个元素（最小元素）？比较 \\(p_1\\) 、 \\(p_2\\) 所指向的元素，显然，两元素中更小的即为合并序列的第一个元素。这里不妨设 \\(p_1\\) 更小，则执行 \\(res\\Leftarrow p_1\\) ，之后 \\(p_1\\) 向后移动一位。这时可以发现，对于 \\(p_1\\) 、 \\(p_2\\) 而言，此时仍是指向了两序列的最小值，则可以重复执行上面的步骤，直到某一指针已经移动到了序列末尾。不妨假设 \\(p_1\\) 已经移动到了序列 \\(q_1\\) 的最后了，此时对于两个指针指向的元素，由于刚刚最后是拿了 \\(p_1\\) 所指向的元素并入了 \\(res\\) ，则一定存在 \\(p_2&gt;p_1\\) ，同时由于序列有序， \\(p_2\\) 之后的序列中的元素仍是满足 \\(&gt;p_1\\) 的关系，所以就将 \\(p_2\\) 后的元素复制进入 \\(res\\) 中即可。 归并排序是稳定的排序算法，则如果 \\(p_1=p_2\\) ，通常是使用 \\(p_1\\) int temp[N]; void merge_sort(int q[], int l, int r) &#123; if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) if (q[i] &lt;= q[j]) temp[k++] = q[i++]; else temp[k++] = q[i++]; while (i &lt;= mid) temp[k++] = q[i++]; while (j &lt;= r) temp[k++] = q[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j]; &#125; def merge_sort(q: list, l: int, r: int): if l >= r: return mid = l + r >> 1 merge_sort(q, l, mid) merge_sort(q, mid + 1, r) i = l j = mid + 1 temp = [] while i &lt;= mid and j &lt;= r: if q[i] &lt;= q[j]: temp.append(q[i]) i += 1 else: temp.append(q[j]) j += 1 temp += q[i:mid + 1] temp += q[j:r + 1] q[l:r + 1] = temp 习题 AcWing 785 AcWing 785 #include &lt;iostream> using namespace std; const int N = 100010; int q[N]; void quick_sort(int q[], int l, int r) &#123; if (l >= r) return; int x = q[l + r >> 1]; int i = l - 1, j = r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] > x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j); quick_sort(q, j + 1, r); &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); quick_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0; &#125; def quick_sort(q, l, r): if l >= r: return x = q[l + r >> 1] i = l - 1 j = r + 1 while i &lt; j: while True: i += 1 if q[i] >= x: break while True: j -= 1 if q[j] &lt;= x: break if i &lt; j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j + 1, r) n = int(input()) lst = list(map(int, input().split())) quick_sort(lst, 0, n - 1) print(' '.join(map(str, lst))) AcWing 786 AcWing 786 #include &lt;iostream> using namespace std; const int N = 100010; int q[N]; void quick_sort(int q[], int l, int r) &#123; if (l >= r) return; int i = l - 1, j = r + 1; int x = q[l + r >> 1]; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] > x); if (i &lt; j) swap(q[i], q[j]); &#125; quick_sort(q, l, j); quick_sort(q, j + 1, r); &#125; int main() &#123; int n, k; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); quick_sort(q, 0, n - 1); printf(\"%d\", q[k - 1]); return 0; &#125; def quick_sort(arr, l, r): if l >= r: return i = l - 1 j = r + 1 x = arr[l + r >> 1] while i &lt; j: while True: i += 1 if arr[i] >= x: break while True: j -= 1 if arr[j] &lt;= x: break if i &lt; j: arr[i], arr[j] = arr[j], arr[i] quick_sort(arr, l, j) quick_sort(arr, j + 1, r) if __name__ == '__main__': n, k = map(int, input().split()) q = list(map(int, input().split())) quick_sort(q, 0, n - 1) print(q[k - 1]) AcWing 787 AcWing 787 #include &lt;iostream> using namespace std; const int N = 100010; int q[N]; int temp[N]; void merge_sort(int q[], int l, int r) &#123; if (l >= r) return; int mid = l + r >> 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i] &lt; q[j]) temp[k++] = q[i++]; else temp[k++] = q[j++]; &#125; while (i &lt;= mid) temp[k++] = q[i++]; while (j &lt;= r) temp[k++] = q[j++]; for (i = 0, j = l; j &lt;= r; i++, j++) q[j] = temp[i]; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(\"%d \", q[i]); return 0; &#125; def merge_sort(arr, l, r): if l >= r: return mid = l + r >> 1 merge_sort(arr, l, mid) merge_sort(arr, mid + 1, r) i = l j = mid + 1 k = 0 temp = [] while (i &lt;= mid and j &lt;= r): if arr[i] &lt; arr[j]: temp.append(arr[i]) i += 1 else: temp.append(arr[j]) j += 1 temp += arr[i:mid + 1] temp += arr[j:r + 1] arr[l:r + 1] = temp if __name__ == '__main__': n = int(input()) q = list(map(int, input().split())) merge_sort(q, 0, n - 1) print(' '.join(map(str, q))) AcWing 788 AcWing 788 由于最大是 \\(10^6\\) ，所以最坏情况会爆 int ，需要使用 long long 思路：使用归并排序，假设 merge_sort() 可以返回当前区间内的逆序对数量 递归左右区间，计算当前左右区间内部存在的逆序对数量。 合并，双指针算法。由于部分区间已有序（左右区间已分别有单调性），双指针游动时，当 \\(q_i&gt;q_j\\) 时，由于要求左区间内部所有元素均小于右区间，则对于元素 \\(q_j\\) 而言产生逆序对。又由于左区间内 \\(i\\) 后所有元素均是满足 \\(q_x&gt;q_j(x\\geq i)\\) ，则可以计算得对于 \\(q_j\\) 而言产生了逆序对数量是 \\(mid-i+1\\) 。 收尾。由于对于右区间的所有元素的逆序对数量都已经计算完毕，则左区间若剩余则直接复制下来进入序列。右区间内若剩余元素，因本来的要求就是右区间的元素应大于左区间，所以直接复制下来也没有问题。 #include &lt;iostream> using namespace std; const int N = 100010; int q[N]; int temp[N]; long long merge_sort(int q[], int l, int r) &#123; if (l >= r) return 0; int mid = l + r >> 1; long long res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r); int i = l, j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i] &lt;= q[j]) temp[k++] = q[i++]; else &#123; temp[k++] = q[j++]; res += mid - i + 1; &#125; &#125; while (i &lt;= mid) temp[k++] = q[i++]; while (j &lt;= r) temp[k++] = q[j++]; for (i = 0, j = l; j &lt;= r; i++, j++) q[j] = temp[i]; return res; &#125; int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;q[i]); long long res = merge_sort(q, 0, n - 1); printf(\"%lld\", res); return 0; &#125; def merge_sort(arr, l, r): if l >= r: return 0 mid = l + r >> 1 left = merge_sort(arr, l, mid) right = merge_sort(arr, mid + 1, r) res = left + right i = l j = mid + 1 temp = [] while i &lt;= mid and j &lt;= r: if arr[i] &lt;= arr[j]: temp.append(arr[i]) i += 1 else: temp.append(arr[j]) j += 1 res += mid - i + 1 temp += arr[i:mid + 1] temp += arr[j:r + 1] arr[l:r + 1] = temp return res if __name__ == '__main__': n = int(input()) q = list(map(int, input().split())) res = merge_sort(q, 0, n - 1) print(res)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Sort","slug":"Sort","permalink":"https://www.leolang.top/tags/Sort/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"}]}],"categories":[{"name":"杂谈回","slug":"杂谈回","permalink":"https://www.leolang.top/categories/%E6%9D%82%E8%B0%88%E5%9B%9E/"},{"name":"学习杂文","slug":"学习杂文","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/"},{"name":"计算方法","slug":"学习杂文/计算方法","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://www.leolang.top/categories/Algorithm/LeetCode/"},{"name":"Django","slug":"学习杂文/Django","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/Django/"},{"name":"数学建模","slug":"数学建模","permalink":"https://www.leolang.top/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"学习笔记","slug":"数学建模/学习笔记","permalink":"https://www.leolang.top/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python Libraries","slug":"学习杂文/Python-Libraries","permalink":"https://www.leolang.top/categories/%E5%AD%A6%E4%B9%A0%E6%9D%82%E6%96%87/Python-Libraries/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.leolang.top/categories/Deep-Learning/"},{"name":"Image Segmentation","slug":"Deep-Learning/Image-Segmentation","permalink":"https://www.leolang.top/categories/Deep-Learning/Image-Segmentation/"},{"name":"PaddlePaddle","slug":"Deep-Learning/Image-Segmentation/PaddlePaddle","permalink":"https://www.leolang.top/categories/Deep-Learning/Image-Segmentation/PaddlePaddle/"},{"name":"AcWing","slug":"Algorithm/AcWing","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/"},{"name":"算法基础课","slug":"Algorithm/AcWing/算法基础课","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"},{"name":"板子","slug":"Algorithm/AcWing/算法基础课/板子","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%9D%BF%E5%AD%90/"},{"name":"动态规划","slug":"Algorithm/AcWing/算法基础课/动态规划","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学知识","slug":"Algorithm/AcWing/算法基础课/数学知识","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"搜索与图论","slug":"Algorithm/AcWing/算法基础课/搜索与图论","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"Algorithm/AcWing/算法基础课/数据结构","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"基础算法","slug":"Algorithm/AcWing/算法基础课/基础算法","permalink":"https://www.leolang.top/categories/Algorithm/AcWing/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leolang.top/tags/Python/"},{"name":"Beautiful Soup","slug":"Beautiful-Soup","permalink":"https://www.leolang.top/tags/Beautiful-Soup/"},{"name":"HTML","slug":"HTML","permalink":"https://www.leolang.top/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"https://www.leolang.top/tags/DOM/"},{"name":"Front-end","slug":"Front-end","permalink":"https://www.leolang.top/tags/Front-end/"},{"name":"Matrix Computation","slug":"Matrix-Computation","permalink":"https://www.leolang.top/tags/Matrix-Computation/"},{"name":"Matrix Theory","slug":"Matrix-Theory","permalink":"https://www.leolang.top/tags/Matrix-Theory/"},{"name":"Numeric Calculation","slug":"Numeric-Calculation","permalink":"https://www.leolang.top/tags/Numeric-Calculation/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.leolang.top/tags/Algorithm/"},{"name":"C++","slug":"C","permalink":"https://www.leolang.top/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://www.leolang.top/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.leolang.top/tags/LeetCode/"},{"name":"DFS","slug":"DFS","permalink":"https://www.leolang.top/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://www.leolang.top/tags/BFS/"},{"name":"Graph Algorithms","slug":"Graph-Algorithms","permalink":"https://www.leolang.top/tags/Graph-Algorithms/"},{"name":"Django","slug":"Django","permalink":"https://www.leolang.top/tags/Django/"},{"name":"Front End","slug":"Front-End","permalink":"https://www.leolang.top/tags/Front-End/"},{"name":"Hash","slug":"Hash","permalink":"https://www.leolang.top/tags/Hash/"},{"name":"Mathematical Modeling","slug":"Mathematical-Modeling","permalink":"https://www.leolang.top/tags/Mathematical-Modeling/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://www.leolang.top/tags/MATLAB/"},{"name":"Linear Progress","slug":"Linear-Progress","permalink":"https://www.leolang.top/tags/Linear-Progress/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.leolang.top/tags/Deep-Learning/"},{"name":"AI","slug":"AI","permalink":"https://www.leolang.top/tags/AI/"},{"name":"PaddlePaddle","slug":"PaddlePaddle","permalink":"https://www.leolang.top/tags/PaddlePaddle/"},{"name":"Image Segmentation","slug":"Image-Segmentation","permalink":"https://www.leolang.top/tags/Image-Segmentation/"},{"name":"Module","slug":"Module","permalink":"https://www.leolang.top/tags/Module/"},{"name":"DP","slug":"DP","permalink":"https://www.leolang.top/tags/DP/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"https://www.leolang.top/tags/Number-Theory/"},{"name":"Game Theory","slug":"Game-Theory","permalink":"https://www.leolang.top/tags/Game-Theory/"},{"name":"Nim games","slug":"Nim-games","permalink":"https://www.leolang.top/tags/Nim-games/"},{"name":"SG function","slug":"SG-function","permalink":"https://www.leolang.top/tags/SG-function/"},{"name":"Inclusion and Exclusion principle","slug":"Inclusion-and-Exclusion-principle","permalink":"https://www.leolang.top/tags/Inclusion-and-Exclusion-principle/"},{"name":"Combination number","slug":"Combination-number","permalink":"https://www.leolang.top/tags/Combination-number/"},{"name":"Gauss-Jordan Elimination","slug":"Gauss-Jordan-Elimination","permalink":"https://www.leolang.top/tags/Gauss-Jordan-Elimination/"},{"name":"Euler function","slug":"Euler-function","permalink":"https://www.leolang.top/tags/Euler-function/"},{"name":"Fast power multiplication","slug":"Fast-power-multiplication","permalink":"https://www.leolang.top/tags/Fast-power-multiplication/"},{"name":"Extended Euclidean algorithm","slug":"Extended-Euclidean-algorithm","permalink":"https://www.leolang.top/tags/Extended-Euclidean-algorithm/"},{"name":"Chinese remainder theorem","slug":"Chinese-remainder-theorem","permalink":"https://www.leolang.top/tags/Chinese-remainder-theorem/"},{"name":"Prime number","slug":"Prime-number","permalink":"https://www.leolang.top/tags/Prime-number/"},{"name":"Divisor","slug":"Divisor","permalink":"https://www.leolang.top/tags/Divisor/"},{"name":"Bipartite Graph","slug":"Bipartite-Graph","permalink":"https://www.leolang.top/tags/Bipartite-Graph/"},{"name":"Hungarian Algorithm","slug":"Hungarian-Algorithm","permalink":"https://www.leolang.top/tags/Hungarian-Algorithm/"},{"name":"Minimum spanning tree","slug":"Minimum-spanning-tree","permalink":"https://www.leolang.top/tags/Minimum-spanning-tree/"},{"name":"Prim","slug":"Prim","permalink":"https://www.leolang.top/tags/Prim/"},{"name":"Kruskal","slug":"Kruskal","permalink":"https://www.leolang.top/tags/Kruskal/"},{"name":"Union Set","slug":"Union-Set","permalink":"https://www.leolang.top/tags/Union-Set/"},{"name":"Shortest Path","slug":"Shortest-Path","permalink":"https://www.leolang.top/tags/Shortest-Path/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"https://www.leolang.top/tags/Dijkstra/"},{"name":"SPFA","slug":"SPFA","permalink":"https://www.leolang.top/tags/SPFA/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"https://www.leolang.top/tags/Bellman-Ford/"},{"name":"Floyed","slug":"Floyed","permalink":"https://www.leolang.top/tags/Floyed/"},{"name":"STL","slug":"STL","permalink":"https://www.leolang.top/tags/STL/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.leolang.top/tags/Data-Structure/"},{"name":"Heap","slug":"Heap","permalink":"https://www.leolang.top/tags/Heap/"},{"name":"Trie","slug":"Trie","permalink":"https://www.leolang.top/tags/Trie/"},{"name":"Data Struture","slug":"Data-Struture","permalink":"https://www.leolang.top/tags/Data-Struture/"},{"name":"KMP","slug":"KMP","permalink":"https://www.leolang.top/tags/KMP/"},{"name":"Stack","slug":"Stack","permalink":"https://www.leolang.top/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"https://www.leolang.top/tags/Queue/"},{"name":"Link list","slug":"Link-list","permalink":"https://www.leolang.top/tags/Link-list/"},{"name":"Template","slug":"Template","permalink":"https://www.leolang.top/tags/Template/"},{"name":"Bit operation","slug":"Bit-operation","permalink":"https://www.leolang.top/tags/Bit-operation/"},{"name":"Discretization","slug":"Discretization","permalink":"https://www.leolang.top/tags/Discretization/"},{"name":"Interval merging","slug":"Interval-merging","permalink":"https://www.leolang.top/tags/Interval-merging/"},{"name":"Double pointer algorithm","slug":"Double-pointer-algorithm","permalink":"https://www.leolang.top/tags/Double-pointer-algorithm/"},{"name":"Prefix sum","slug":"Prefix-sum","permalink":"https://www.leolang.top/tags/Prefix-sum/"},{"name":"Difference","slug":"Difference","permalink":"https://www.leolang.top/tags/Difference/"},{"name":"High Precision","slug":"High-Precision","permalink":"https://www.leolang.top/tags/High-Precision/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://www.leolang.top/tags/Binary-Search/"},{"name":"Sort","slug":"Sort","permalink":"https://www.leolang.top/tags/Sort/"}]}